#include <bits/stdc++.h>
using namespace std;

// 动态规划 - 状态机 DP - 进阶
class Solution {
public:
    int countSpecialSubsequences(vector<int>& nums) {
        // 参考题解
        const int mod = 1e9 + 7;

        // f0 表示正整数个 0 组成的子序列
        // f1 表示正整数个 0 紧接着正整数个 1 组成的子序列
        // f2 表示正整数个 0 紧接着正整数个 1，最后正整数个 2 组成的子序列
        // 状态转移时
        // 当 nums[i] == 0 时，在每一个使用 nums[0..i−1] 中的元素组成的类型为 0 的子序列之后添加这个 0
        //                    此外，这个 0 也可以单独构成一个新的类型为 0 的子序列
        //                    因此转移方程为 f[i][0]=2⋅f[i−1][0]+1
        // 当 nums[i] == 1 时，在每一个使用 nums[0..i−1] 中的元素组成的类型为 1 的子序列之后添加这个 1，
        //                     得到额外的 f[i−1][1] 个类型为 1 的子序列
        //                     每一个类型为 0 的子序列之后添加这个 1，得到额外的 f[i−1][0] 个类型为 1 的子序列
        //                    因此转移方程为 f[i][1]=2⋅f[i−1][1]+f[i−1][0]
        // 当 nums[i] == 1 时，每一个使用 nums[0..i−1] 中的元素组成的类型为 2 的子序列之后添加这个 2
        //                     每一个类型为 1 的子序列之后添加这个 2
        //                     因此状态转移方程为 f[i][2]=2⋅f[i−1][2]+f[i−1][1]
        int f0 = 0, f1 = 0, f2 = 0;
        for (auto x:nums) {
            if (x == 0) f0 = ((long)f0 * 2 + 1) % mod;
            if (x == 1) f1 = ((long)f1 * 2 + f0) % mod;
            if (x == 2) f2 = ((long)f2 * 2 + f1) % mod;
        }
        
        return f2;
    }
};