#include <bits/stdc++.h>
using namespace std;

// 数学算法 - 计算几何 - 5.3 矩形、多边形
class Solution {
public:
    using Point =  vector<int>;
    double minAreaFreeRect(vector<vector<int>>& points) {
        // 自行解答 - 时间复杂度 O(N^3) 枚举三个点：
        // 1. 是否构成 直角三角形，直角坐标的对称点是否在 points 中
        // 2. 直角边的乘积即为面积，求其最小值
        int n = points.size();
        set<pair<int,int>> hash_points;
        for (auto & p: points) hash_points.insert({p[0], p[1]});

        auto distance = [&](const Point& p1, const Point& p2) -> long long{
            int dx = p1[0] - p2[0], dy = p1[1] - p2[1];
            return 1LL * dx * dx + dy * dy;
        };

        auto isRTriangle = [&](const Point& A, const Point& B, const Point& C) -> int {
            long long ab = distance(A, B), bc = distance(B, C), ac = distance(A, C);
            if (ab + ac == bc) return 1;
            else if (ab + bc == ac) return 2;
            else if (bc + ac == ab) return 3;
            else return -1;
        };

        // generated by doubao
        auto find4thPoint = [](const Point& A, const Point& B, const Point& C, int right) -> Point {
            Point fourthPoint = {-1, -1};  // 无效点默认值
            // 核心逻辑：矩形的对角线中点相同，对称点 = 对角线两端点之和 - 直角顶点
            switch (right) {
                case 1:  // 直角在A，斜边为BC（对角线是BC）
                    fourthPoint[0] = B[0] + C[0] - A[0];
                    fourthPoint[1] = B[1] + C[1] - A[1];
                    break;
                case 2:  // 直角在B，斜边为AC（对角线是AC）
                    fourthPoint[0] = A[0] + C[0] - B[0];
                    fourthPoint[1] = A[1] + C[1] - B[1];
                    break;
                case 3:  // 直角在C，斜边为AB（对角线是AB）
                    fourthPoint[0] = A[0] + B[0] - C[0];
                    fourthPoint[1] = A[1] + B[1] - C[1];
                    break;
            }

            return fourthPoint;
        };       

        double ans = INT_MAX;
        for (int a=0; a<n-2; a++) for (int b=a+1; b<n-1; b++) for (int c=b+1; c<n; c++) {
            int right = isRTriangle(points[a], points[b], points[c]);
            if (right != -1) {
                Point p4 = find4thPoint(points[a], points[b], points[c], right);
                if (hash_points.count({p4[0], p4[1]})) {
                    if (right == 1) ans = min(ans, sqrt(distance(p4, points[b]) * distance(p4, points[c])));
                    else if (right == 2) ans = min(ans, sqrt(distance(p4, points[a]) * distance(p4, points[c])));
                    else ans = min(ans, sqrt(distance(p4, points[a]) * distance(p4, points[b])));
                }
            }
        }

        return ans == INT_MAX? 0 :ans;   

    }
};