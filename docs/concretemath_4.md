# 4. Number Theory

整数在本书重点讲解的离散数学中处于核心地位。因此，我们要深入探讨数论—— 这是数学的一个重要分支，专门研究整数的各种性质。

在上一章里，我们已经浅尝了数论，引入了叫作 $mod$ 和 $gcd$ 的二元运算。现在让我们深入其中，真正沉浸在这一领域里。


## 4.1 DIVISIBILITY 可除性
我们说 $m$ 整除 $n$（或称 $n$ 可被 $m$ 整除），当且仅当 $m>0$ 且比值 $n/m$ 是整数。这一性质是整个数论的基础，因此很适合为它专门引入一种记号。我们于是记作：
```math
m\backslash n \iff m > 0\ and\ n = mk\ for\ some\ integer\ k. \tag{4.1}
```

（记号 $m|n$ 在当今数学文献中实际上比 $m\backslash n$ 更为常见。但是竖线 $|$ 已经被过度使用 —— 用于表示绝对值、集合分隔符、条件概率等等 ——而反斜杠 $\backslash$ 却很少被使用。此外，$m\backslash n$ 能让人直观地感觉到 $m$ 是某个隐含比值中的分母。因此，我们将大胆地让这个整除符号向左倾斜。）


如果 $m$ 不整除 $n$，我们记作 $m\nmid n$。


还有一个类似的关系，叫作“$n$ 是 $m$ 的倍数”，它的含义几乎与整除相同，只是$m$ 不必是正数。在这种情况下，我们的意思就是存在某个整数 $k$，使得 $n=mk$。举例来说，$0$ 只有一个倍数（就是 $0$ 本身），但没有数可以被 $0$ 整除。每个整数都是 $-1$ 的倍数，但严格来说，没有整数能被 $-1$ 整除。这些定义在 $m$ 和 $n$ 是任意实数时都成立；例如，$2\pi$ 可以被 $\pi$ 整除。但我们几乎只在 $m$ 和 $n$ 都是整数时使用它们。毕竟，这是数论。

两个整数 $m$ 和 $n$ 的最大公约数，是能够同时整除它们两者的最大整数：
```math
\gcd(m, n) = \max\{k| k\backslash m\ and\ k\backslash n\}. \tag{4.2}
```

例如，$\gcd(12,18)=6$。这是一个我们很熟悉的概念，因为四年级学生学习化简分数 $\frac{m}{n}$ 时，用到的就是这个公因子：$\frac{12}{18} = \frac{12/6}{18/6} = \frac{2}{3}$。注意，如果 $n>0$，我们有 $\gcd(0,n)=n$，因为任何正数都能整除 $0$，而且 $n$ 是它自身最大的因子。$\gcd(0,0)$ 是没有定义的。

另一个我们熟悉的概念是最小公倍数，
```math
\operatorname{lcm}(m, n) = \min\{k| k>0, m\backslash k\ and\ n\backslash k\}. \tag{4.3}
```

若 $m \le 0$ 或 $n \le 0$，则它没有定义。学习算术的学生会把它认作最小公分母，用于对分母为 $m$ 和 $n$ 的分数做加法。例如，$\operatorname{lcm}(12,18)=36$。并且四年级的学生都知道$\frac{7}{12} + \frac{1}{18}= \frac{21}{36} + \frac{2}{36}= \frac{23}{36}$。 $\operatorname{lcm}$ 与 $\gcd$ 在某种程度上是类似的，但我们不会对它同等重视，因为 $\gcd$ 拥有更良好的性质。

$\gcd$ 最优秀的性质之一是它很容易计算，使用一种有 2300 年历史的方法，称为欧几里得算法。对于给定的 $0 \le m < n$，为计算 $\gcd(m,n)$，欧几里得算法使用如下递推式：
```math
\begin{aligned}
\gcd(0, n) &= n; \\
\gcd(m, n) &= \gcd(n\mod m, m), for\ m>0. \tag{4.4}
\end{aligned}
```
因此，例如 $\gcd(12,18) = \gcd(6,12) = \gcd(0,6) = 6$。上述递推式是成立的，因为任何能同时整除 $m$ 和 $n$ 的公约数，也必定能同时整除 $m$ 和 $n \bmod m$（即 $n - \lfloor n/m \rfloor m$）。而对于 $\operatorname{lcm}(m,n)$，似乎不存在任何能与这个递推式相提并论的简单递推关系（见习题 2）。

欧几里得算法还能给我们更多信息：我们可以对其进行扩展，使其能计算出满足如下等式的整数 $m'$ 和 $n'$：
```math
m'm + n'n = gcd(m, n). \tag{4.5}
```

具体方法如下：若 $m=0$，我们只需取 $m'=0$ 且 $n'=1$。否则，令 $r = n \bmod m$，并将该方法递归地应用于 $r$ 和 $m$（替代原来的 $m$ 和 $n$），计算出满足如下等式的 $\bar{r}$ 和 $\bar{m}$：
```math
\bar{r}r + \bar{m}m = gcd(r, n).
```

因为 $r=n-\lfloor n/m \rfloor m$ 且 $\gcd(r,m)=\gcd(m,n)$，所以这个式子告诉我们:
```math
\bar{r}(n-\lfloor n/m \rfloor m) + \bar{m}m = gcd(m, n).
```

我们可以把左边重新整理，以显式表示它对 $m$ 和 $n$ 的依赖关系：
```math
(\bar{m}-\lfloor n/m \rfloor\bar{r}) + \bar{r}m = gcd(m, n);
```

因此 $m' = \bar{m} - \lfloor n/m \rfloor \bar{r}$ 且 $n' = \bar{r}$ 就是我们在式 (4.5) 中所需的整数。以我们最熟悉的例子来说，当 $m=12$，$n=18$ 时，该方法给出：$6 = 0 \cdot 0 + 1 \cdot 6 = 1 \cdot 6 + 0 \cdot 12 = (-1) \cdot 12 + 1 \cdot 18$。

但为何式 (4.5) 是如此精妙的结论呢？最主要的原因是，在某种意义上，数 $m'$ 和 $n'$ 实际上能证明欧几里得算法在任意具体情况下都给出了正确答案。假设我们的计算机经过冗长的计算后告诉我们 $\gcd(m,n)=d$，且 $m'm + n'n = d$；但我们对此存疑，认为存在一个更大的公约数，只是被机器以某种方式忽略了。然而这是不可能的，因为任何能整除 $m$ 和 $n$ 的公约数都必定能整除 $m'm + n'n$；因此它也必定能整除 $d$；所以它必定不大于 $d$。此外，我们可以轻松验证 $d$ 确实能同时整除 $m$ 和 $n$。（能输出自身正确性证明的算法被称为自验证算法。）

在本章的后续内容中，我们会频繁用到式 (4.5)。它的一个重要推论是下面这个小定理：
```math
k\backslash m\ \text{and}\ k\backslash n\ \iff \ k\backslash\gcd(m,n). \tag{4.6}
```

（证明：若 $k$ 同时整除 $m$ 和 $n$，则它整除 $m'm+n'n$，因此它整除 $\gcd(m,n)$。反之，若 $k$ 整除 $\gcd(m,n)$，则它整除 $m$ 的一个因子和 $n$ 的一个因子，因此它同时整除 $m$ 和 $n$。）我们一直都知道 $m$ 和 $n$ 的任何公约数必定不大于它们的最大公约数；这是最大公约数的定义。但现在我们知道，任何公约数实际上都是它们最大公约数的一个因子。

有些时候我们需要对 $n$ 的所有因子求和。这种情况下，使用下面这条简便的法则通常很有用：
```math
\sum_{m\backslash n} a_m = \sum_{m\backslash k} a_{n/m},\ integer\ n>0,  \tag{4.7}
```

该式成立的原因是，当 $m$ 取遍 $n$ 的所有因子时，$n/m$ 也恰好取遍 $n$ 的所有因子。例如，当 $n=12$ 时，该法则表明$a_1+a_2+a_3+a_4+a_6+a_{12}=a_{12}+a_6+a_4+a_3+a_2+a_1$。

还有一个稍微更一般的恒等式，
```math
\sum_{m\backslash n} a_m = \sum_k\sum_{m>0} a_m[n=mk],  \tag{4.8}
```

这是定义 (4.1) 的一个直接推论。若 $n$ 为正数，(4.8) 式右边即为 $\sum_{k\mid n} a_{n/k}$，因此 (4.8) 蕴含 (4.7)。并且当 $n$ 为负数时，方程 (4.8) 依然成立。（此时，右边的非零项出现在 $k$ 是 $n$ 的某个因子的相反数时。）

此外，对因子的二重求和可以按照下面的法则交换次序：
```math
\sum_{m\backslash n}\sum_{k\backslash m} a_{k,m} = \sum_{k\backslash n}\sum_{l\backslash (n/k)} a_{k,kl}.  \tag{4.9}
```

例如，当 $n=12$ 时，这条法则具有如下形式：
```math
\begin{aligned}
a_{1,1}+ &(a_{1,2}+a_{2,2})+(a_{1,3}+a_{3,3}) \\
&\qquad+(a_{1,4}+a_{2,4}+a_{4,4})+(a_{1,6}+a_{2,6}+a_{3,6}+a_{6,6}) \\
&\qquad+(a_{1,12}+a_{2,12}+a_{3,12}+a_{4,12}+a_{6,12}+a_{12,12})\\
&=(a_{1,1}+a_{1,2}+a_{1,3}+a_{1,4}+a_{1,6}+a_{1,12}) \\
&\qquad+(a_{2,2}+a_{2,4}+a_{2,6}+a_{2,12})+(a_{3,3}+a_{3,6}+a_{3,12}) \\
&\qquad+(a_{4,4}+a_{4,12})+(a_{6,6}+a_{6,12})+a_{12,12}.
\end{aligned}
```

我们可以用艾弗森约定的运算来证明式 (4.9)。左边是
```math
\sum_{j,l}\sum_{k,m>0} a_{k,m}[m=jm][m=kl] = \sum_j\sum_{k,l>0} a_{k,kl}[n=jkl];
```

右边是
```math
\sum_{j,m}\sum_{k,l>0} a_{k,kl}[n=jk][n/k=ml] = \sum_m\sum_{k,l>0} a_{k,kl}[n=mlk],
```

仅需对下标重命名，二者便是相同的。这个例子表明，我们在第 2 章学到的技巧在研究数论时将会很有用。


## 4.2 PRIMES 质数
若一个正整数 $p$ 恰好有两个因子，即 $1$ 和 $p$，则称其为素数。在本章余下的内容中，字母 $p$ 始终表示素数，即使我们没有明确说明。按照约定，$1$ 不是素数，因此素数序列开头是这样的：
```math
2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\cdots
```

有些数看似素数实则不是，例如 $91$ ($=7\cdot13$) 和 $161$ ($=7\cdot23$)。这些数以及其他拥有三个或更多因子的数被称为合数。每个大于 $1$ 的整数要么是素数，要么是合数，二者必居其一。

素数非常重要，因为它们是所有正整数的基本构成单元。任何正整数 $n$ 都可以写成素数的乘积，
```math
n = p_1\cdots p_m = \prod_{k=1}^m p_k,\quad p_1\le\cdots\le p_m. \tag{4.10}
```

例如，$12=2\cdot2\cdot3$；$11011=7\cdot11\cdot11\cdot13$；$11111=41\cdot271$。（用 $\prod$ 表示乘积与用 $\sum$ 表示和类似，如习题 2.25 中所说明的。如果 $m=0$，我们将其视为空乘积，根据定义其值为 $1$；这就是 $n=1$ 在式 $(4.10)$ 中的表示方式。）这样的分解总是可行的，因为如果 $n>1$ 不是素数，它就有一个因子 $n_1$ 满足 $1<n_1<n$；于是我们可以写成 $n=n_1\cdot n_2$，并且（由归纳法）我们知道 $n_1$ 和 $n_2$ 都可以表示为素数的乘积。

而且，式 $(4.10)$ 中的展开式是唯一的：将 $n$ 写成不降序素数乘积的方式只有一种。这个结论被称为**算术基本定理**，它看起来如此显然，以至于我们可能会疑惑为什么还需要证明。怎么可能存在两组不同的素数，它们的乘积却相同呢？事实上不可能，但原因并非简单地“由素数的定义可得”。例如，如果我们考虑所有形如 $m+n\sqrt{10}$（其中 $m,n$ 为整数）的实数集合，任意两个这样的数相乘仍然是该形式，并且我们可以把不能非平凡分解的数称为“素数”。数 $6$ 就有两种表示：$2\cdot3=(4+\sqrt{10})(4-\sqrt{10})$；而习题 36 表明，$2,3,4+\sqrt{10}$ 和 $4-\sqrt{10}$ 在这个系统中都是“素数”。

因此我们需要严格证明式 $(4.10)$ 的唯一性。当 $n=1$ 时显然只有一种可能，因为此时乘积必须是空乘积；于是假设 $n>1$，且所有更小的数都具有唯一分解。假设我们有两种分解式
```math
n = p_1\cdots p_m = q_1\cdots p_k,\quad p_1\le\cdots\le p_m\ and\ q_1\le\cdots\le q_k,
```

其中 $p_i$ 和 $q_j$ 都是素数。我们来证明 $p_1=q_1$。如果不相等，不妨设 $p_1<q_1$，使得 $p_1$ 小于所有的 $q_j$。因为 $p_1$ 和 $q_1$ 都是素数，它们的最大公约数必为 $1$；于是由欧几里得自验证算法可知，存在整数 $a$ 和 $b$ 使得 $a p_1 + b q_1 = 1$。因此
```math
ap_1q_2\cdots q_k + bq_1q_2\cdots q_k = q_2\cdots q_k.
```

现在 $p_1$ 整除左边两项，因为 $q_1 q_2 \dots q_k = n$；于是 $p_1$ 整除右边 $q_2 \dots q_k$。因此 $q_2 \dots q_k / p_1$ 是整数，且 $q_2 \dots q_k$ 有一个含 $p_1$ 的素因子分解。但 $q_2 \dots q_k < n$，由归纳假设它有唯一分解。这个矛盾表明 $p_1$ 必定等于 $q_1$。于是我们可以把 $n$ 的两个分解式都除以 $p_1$，得到 $p_2 \dots p_m = q_2 \dots q_k < n$。其余因子同样（由归纳假设）必须相等，于是唯一性的证明就完成了。

算术基本定理往往用另一种形式表述更有用：每个正整数都能被唯一地表示成
```math
n = \prod_p p^{n_p},\ n_p \ge 0. \tag{4.11}
```

右边是对无穷多个素数的乘积；但对任意给定的 $n$，除少数几个指数外其余都是 $0$，因此对应的因子都是 $1$。所以它实际上是有限乘积，就像许多“无穷”和实际上是有限的一样，因为它们的项大部分都是 $0$。

公式 $(4.11)$ 唯一表示了 $n$，因此我们可以把序列 $\langle n_2,n_3,n_5,\dots\rangle$ 看成正整数的一种数系。例如，$12$ 的素因子指数表示是 $\langle 2,1,0,0,\dots\rangle$，$18$ 的素因子指数表示是 $\langle 1,2,0,0,\dots\rangle$。两个数相乘，只需把它们的指数表示相加。换句话说，
```math
k = mn \iff k_p = m_p + n_p,\ \forall p. \tag{4.12}
```

这就意味着
```math
m\backslash n \iff m_p \le n_p,\ \forall p. \tag{4.13}
```

由此立即推出
```math
k = \gcd(m,n) \iff k_p = \min(m_p, n_p),\ \forall p \tag{4.14} 
```
```math
k = \operatorname{lcm}(m,n) \iff k_p = \max(m_p, n_p),\ \forall p \tag{4.15}
```

例如，因为 $12=2^2\cdot3^1$ 且 $18=2^1\cdot3^2$，我们可以通过取公共指数的最小值和最大值来得到它们的 $\gcd$ 和 $\operatorname{lcm}$：
```math
\gcd(12,18) = 2^{\min(2,1)} \cdot 3^{\min(1,2)} = 2^1 \cdot 3^1 = 6 \\
\operatorname{lcm}(12,18) = 2^{\max(2,1)} \cdot 3^{\max(1,2)} = 2^2 \cdot 3^2 = 36
```

如果素数 $p$ 整除乘积 $mn$，那么它一定整除 $m$ 或 $n$（可能两者都整除），这是唯一分解定理的推论。但合数没有这个性质。例如，非素数 $4$ 整除 $60=6\cdot10$，但它既不整除 $6$ 也不整除 $10$。原因很简单：在分解 $60=6\cdot10=(2\cdot3)(2\cdot5)$ 中，$4=2\cdot2$ 的两个素因子被分到了两部分里，因此 $4$ 不整除其中任何一部分。而素数是不可再分的，所以它必须整除原来的其中一个因子。

## 4.3 PRIME EXAMPLES