# 4. Number Theory

整数在本书重点讲解的离散数学中处于核心地位。因此，我们要深入探讨数论—— 这是数学的一个重要分支，专门研究整数的各种性质。

在上一章里，我们已经浅尝了数论，引入了叫作 $mod$ 和 $gcd$ 的二元运算。现在让我们深入其中，真正沉浸在这一领域里。


## 4.1 DIVISIBILITY 可除性
我们说 $m$ 整除 $n$（或称 $n$ 可被 $m$ 整除），当且仅当 $m>0$ 且比值 $n/m$ 是整数。这一性质是整个数论的基础，因此很适合为它专门引入一种记号。我们于是记作：
```math
m\backslash n \iff m > 0\ and\ n = mk\ for\ some\ integer\ k. \tag{4.1}
```

（记号 $m|n$ 在当今数学文献中实际上比 $m\backslash n$ 更为常见。但是竖线 $|$ 已经被过度使用 —— 用于表示绝对值、集合分隔符、条件概率等等 ——而反斜杠 $\backslash$ 却很少被使用。此外，$m\backslash n$ 能让人直观地感觉到 $m$ 是某个隐含比值中的分母。因此，我们将大胆地让这个整除符号向左倾斜。）


如果 $m$ 不整除 $n$，我们记作 $m\nmid n$。


还有一个类似的关系，叫作“$n$ 是 $m$ 的倍数”，它的含义几乎与整除相同，只是$m$ 不必是正数。在这种情况下，我们的意思就是存在某个整数 $k$，使得 $n=mk$。举例来说，$0$ 只有一个倍数（就是 $0$ 本身），但没有数可以被 $0$ 整除。每个整数都是 $-1$ 的倍数，但严格来说，没有整数能被 $-1$ 整除。这些定义在 $m$ 和 $n$ 是任意实数时都成立；例如，$2\pi$ 可以被 $\pi$ 整除。但我们几乎只在 $m$ 和 $n$ 都是整数时使用它们。毕竟，这是数论。

两个整数 $m$ 和 $n$ 的最大公约数，是能够同时整除它们两者的最大整数：
```math
\gcd(m, n) = \max\{k| k\backslash m\ and\ k\backslash n\}. \tag{4.2}
```

例如，$\gcd(12,18)=6$。这是一个我们很熟悉的概念，因为四年级学生学习化简分数 $\frac{m}{n}$ 时，用到的就是这个公因子：$\frac{12}{18} = \frac{12/6}{18/6} = \frac{2}{3}$。注意，如果 $n>0$，我们有 $\gcd(0,n)=n$，因为任何正数都能整除 $0$，而且 $n$ 是它自身最大的因子。$\gcd(0,0)$ 是没有定义的。

另一个我们熟悉的概念是最小公倍数，
```math
\operatorname{lcm}(m, n) = \min\{k| k>0, m\backslash k\ and\ n\backslash k\}. \tag{4.3}
```

若 $m \le 0$ 或 $n \le 0$，则它没有定义。学习算术的学生会把它认作最小公分母，用于对分母为 $m$ 和 $n$ 的分数做加法。例如，$\operatorname{lcm}(12,18)=36$。并且四年级的学生都知道$\frac{7}{12} + \frac{1}{18}= \frac{21}{36} + \frac{2}{36}= \frac{23}{36}$。 $\operatorname{lcm}$ 与 $\gcd$ 在某种程度上是类似的，但我们不会对它同等重视，因为 $\gcd$ 拥有更良好的性质。

$\gcd$ 最优秀的性质之一是它很容易计算，使用一种有 2300 年历史的方法，称为欧几里得算法。对于给定的 $0 \le m < n$，为计算 $\gcd(m,n)$，欧几里得算法使用如下递推式：
```math
\begin{aligned}
\gcd(0, n) &= n; \\
\gcd(m, n) &= \gcd(n\mod m, m), for\ m>0. \tag{4.4}
\end{aligned}
```
因此，例如 $\gcd(12,18) = \gcd(6,12) = \gcd(0,6) = 6$。上述递推式是成立的，因为任何能同时整除 $m$ 和 $n$ 的公约数，也必定能同时整除 $m$ 和 $n \bmod m$（即 $n - \lfloor n/m \rfloor m$）。而对于 $\operatorname{lcm}(m,n)$，似乎不存在任何能与这个递推式相提并论的简单递推关系（见习题 2）。

欧几里得算法还能给我们更多信息：我们可以对其进行扩展，使其能计算出满足如下等式的整数 $m'$ 和 $n'$：
```math
m'm + n'n = gcd(m, n). \tag{4.5}
```

具体方法如下：若 $m=0$，我们只需取 $m'=0$ 且 $n'=1$。否则，令 $r = n \bmod m$，并将该方法递归地应用于 $r$ 和 $m$（替代原来的 $m$ 和 $n$），计算出满足如下等式的 $\bar{r}$ 和 $\bar{m}$：
```math
\bar{r}r + \bar{m}m = gcd(r, n).
```

因为 $r=n-\lfloor n/m \rfloor m$ 且 $\gcd(r,m)=\gcd(m,n)$，所以这个式子告诉我们:
```math
\bar{r}(n-\lfloor n/m \rfloor m) + \bar{m}m = gcd(m, n).
```

我们可以把左边重新整理，以显式表示它对 $m$ 和 $n$ 的依赖关系：
```math
(\bar{m}-\lfloor n/m \rfloor\bar{r}) + \bar{r}m = gcd(m, n);
```

因此 $m' = \bar{m} - \lfloor n/m \rfloor \bar{r}$ 且 $n' = \bar{r}$ 就是我们在式 (4.5) 中所需的整数。以我们最熟悉的例子来说，当 $m=12$，$n=18$ 时，该方法给出：$6 = 0 \cdot 0 + 1 \cdot 6 = 1 \cdot 6 + 0 \cdot 12 = (-1) \cdot 12 + 1 \cdot 18$。

但为何式 (4.5) 是如此精妙的结论呢？最主要的原因是，在某种意义上，数 $m'$ 和 $n'$ 实际上能证明欧几里得算法在任意具体情况下都给出了正确答案。假设我们的计算机经过冗长的计算后告诉我们 $\gcd(m,n)=d$，且 $m'm + n'n = d$；但我们对此存疑，认为存在一个更大的公约数，只是被机器以某种方式忽略了。然而这是不可能的，因为任何能整除 $m$ 和 $n$ 的公约数都必定能整除 $m'm + n'n$；因此它也必定能整除 $d$；所以它必定不大于 $d$。此外，我们可以轻松验证 $d$ 确实能同时整除 $m$ 和 $n$。（能输出自身正确性证明的算法被称为自验证算法。）

在本章的后续内容中，我们会频繁用到式 (4.5)。它的一个重要推论是下面这个小定理：
```math
k\backslash m\ \text{and}\ k\backslash n\ \iff \ k\backslash\gcd(m,n). \tag{4.6}
```

（证明：若 $k$ 同时整除 $m$ 和 $n$，则它整除 $m'm+n'n$，因此它整除 $\gcd(m,n)$。反之，若 $k$ 整除 $\gcd(m,n)$，则它整除 $m$ 的一个因子和 $n$ 的一个因子，因此它同时整除 $m$ 和 $n$。）我们一直都知道 $m$ 和 $n$ 的任何公约数必定不大于它们的最大公约数；这是最大公约数的定义。但现在我们知道，任何公约数实际上都是它们最大公约数的一个因子。

有些时候我们需要对 $n$ 的所有因子求和。这种情况下，使用下面这条简便的法则通常很有用：
```math
\sum_{m\backslash n} a_m = \sum_{m\backslash k} a_{n/m},\ integer\ n>0,  \tag{4.7}
```

该式成立的原因是，当 $m$ 取遍 $n$ 的所有因子时，$n/m$ 也恰好取遍 $n$ 的所有因子。例如，当 $n=12$ 时，该法则表明$a_1+a_2+a_3+a_4+a_6+a_{12}=a_{12}+a_6+a_4+a_3+a_2+a_1$。

还有一个稍微更一般的恒等式，
```math
\sum_{m\backslash n} a_m = \sum_k\sum_{m>0} a_m[n=mk],  \tag{4.8}
```

这是定义 (4.1) 的一个直接推论。若 $n$ 为正数，(4.8) 式右边即为 $\sum_{k\mid n} a_{n/k}$，因此 (4.8) 蕴含 (4.7)。并且当 $n$ 为负数时，方程 (4.8) 依然成立。（此时，右边的非零项出现在 $k$ 是 $n$ 的某个因子的相反数时。）

此外，对因子的二重求和可以按照下面的法则交换次序：
```math
\sum_{m\backslash n}\sum_{k\backslash m} a_{k,m} = \sum_{k\backslash n}\sum_{l\backslash (n/k)} a_{k,kl}.  \tag{4.9}
```

例如，当 $n=12$ 时，这条法则具有如下形式：
```math
\begin{aligned}
a_{1,1}+ &(a_{1,2}+a_{2,2})+(a_{1,3}+a_{3,3}) \\
&\qquad+(a_{1,4}+a_{2,4}+a_{4,4})+(a_{1,6}+a_{2,6}+a_{3,6}+a_{6,6}) \\
&\qquad+(a_{1,12}+a_{2,12}+a_{3,12}+a_{4,12}+a_{6,12}+a_{12,12})\\
&=(a_{1,1}+a_{1,2}+a_{1,3}+a_{1,4}+a_{1,6}+a_{1,12}) \\
&\qquad+(a_{2,2}+a_{2,4}+a_{2,6}+a_{2,12})+(a_{3,3}+a_{3,6}+a_{3,12}) \\
&\qquad+(a_{4,4}+a_{4,12})+(a_{6,6}+a_{6,12})+a_{12,12}.
\end{aligned}
```

我们可以用艾弗森约定的运算来证明式 (4.9)。左边是
```math
\sum_{j,l}\sum_{k,m>0} a_{k,m}[m=jm][m=kl] = \sum_j\sum_{k,l>0} a_{k,kl}[n=jkl];
```

右边是
```math
\sum_{j,m}\sum_{k,l>0} a_{k,kl}[n=jk][n/k=ml] = \sum_m\sum_{k,l>0} a_{k,kl}[n=mlk],
```

仅需对下标重命名，二者便是相同的。这个例子表明，我们在第 2 章学到的技巧在研究数论时将会很有用。


## 4.2 PRIMES 质数
若一个正整数 $p$ 恰好有两个因子，即 $1$ 和 $p$，则称其为素数。在本章余下的内容中，字母 $p$ 始终表示素数，即使我们没有明确说明。按照约定，$1$ 不是素数，因此素数序列开头是这样的：
```math
2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\cdots
```

有些数看似素数实则不是，例如 $91$ ($=7\cdot13$) 和 $161$ ($=7\cdot23$)。这些数以及其他拥有三个或更多因子的数被称为合数。每个大于 $1$ 的整数要么是素数，要么是合数，二者必居其一。

素数非常重要，因为它们是所有正整数的基本构成单元。任何正整数 $n$ 都可以写成素数的乘积，
```math
n = p_1\cdots p_m = \prod_{k=1}^m p_k,\quad p_1\le\cdots\le p_m. \tag{4.10}
```

例如，$12=2\cdot2\cdot3$；$11011=7\cdot11\cdot11\cdot13$；$11111=41\cdot271$。（用 $\prod$ 表示乘积与用 $\sum$ 表示和类似，如习题 2.25 中所说明的。如果 $m=0$，我们将其视为空乘积，根据定义其值为 $1$；这就是 $n=1$ 在式 $(4.10)$ 中的表示方式。）这样的分解总是可行的，因为如果 $n>1$ 不是素数，它就有一个因子 $n_1$ 满足 $1<n_1<n$；于是我们可以写成 $n=n_1\cdot n_2$，并且（由归纳法）我们知道 $n_1$ 和 $n_2$ 都可以表示为素数的乘积。

而且，式 $(4.10)$ 中的展开式是唯一的：将 $n$ 写成不降序素数乘积的方式只有一种。这个结论被称为**算术基本定理**，它看起来如此显然，以至于我们可能会疑惑为什么还需要证明。怎么可能存在两组不同的素数，它们的乘积却相同呢？事实上不可能，但原因并非简单地“由素数的定义可得”。例如，如果我们考虑所有形如 $m+n\sqrt{10}$（其中 $m,n$ 为整数）的实数集合，任意两个这样的数相乘仍然是该形式，并且我们可以把不能非平凡分解的数称为“素数”。数 $6$ 就有两种表示：$2\cdot3=(4+\sqrt{10})(4-\sqrt{10})$；而习题 36 表明，$2,3,4+\sqrt{10}$ 和 $4-\sqrt{10}$ 在这个系统中都是“素数”。

因此我们需要严格证明式 $(4.10)$ 的唯一性。当 $n=1$ 时显然只有一种可能，因为此时乘积必须是空乘积；于是假设 $n>1$，且所有更小的数都具有唯一分解。假设我们有两种分解式
```math
n = p_1\cdots p_m = q_1\cdots p_k,\quad p_1\le\cdots\le p_m\ and\ q_1\le\cdots\le q_k,
```

其中 $p_i$ 和 $q_j$ 都是素数。我们来证明 $p_1=q_1$。如果不相等，不妨设 $p_1<q_1$，使得 $p_1$ 小于所有的 $q_j$。因为 $p_1$ 和 $q_1$ 都是素数，它们的最大公约数必为 $1$；于是由欧几里得自验证算法可知，存在整数 $a$ 和 $b$ 使得 $a p_1 + b q_1 = 1$。因此
```math
ap_1q_2\cdots q_k + bq_1q_2\cdots q_k = q_2\cdots q_k.
```

现在 $p_1$ 整除左边两项，因为 $q_1 q_2 \dots q_k = n$；于是 $p_1$ 整除右边 $q_2 \dots q_k$。因此 $q_2 \dots q_k / p_1$ 是整数，且 $q_2 \dots q_k$ 有一个含 $p_1$ 的素因子分解。但 $q_2 \dots q_k < n$，由归纳假设它有唯一分解。这个矛盾表明 $p_1$ 必定等于 $q_1$。于是我们可以把 $n$ 的两个分解式都除以 $p_1$，得到 $p_2 \dots p_m = q_2 \dots q_k < n$。其余因子同样（由归纳假设）必须相等，于是唯一性的证明就完成了。

算术基本定理往往用另一种形式表述更有用：每个正整数都能被唯一地表示成
```math
n = \prod_p p^{n_p},\ n_p \ge 0. \tag{4.11}
```

右边是对无穷多个素数的乘积；但对任意给定的 $n$，除少数几个指数外其余都是 $0$，因此对应的因子都是 $1$。所以它实际上是有限乘积，就像许多“无穷”和实际上是有限的一样，因为它们的项大部分都是 $0$。

公式 $(4.11)$ 唯一表示了 $n$，因此我们可以把序列 $\langle n_2,n_3,n_5,\dots\rangle$ 看成正整数的一种数系。例如，$12$ 的素因子指数表示是 $\langle 2,1,0,0,\dots\rangle$，$18$ 的素因子指数表示是 $\langle 1,2,0,0,\dots\rangle$。两个数相乘，只需把它们的指数表示相加。换句话说，
```math
k = mn \iff k_p = m_p + n_p,\ \forall p. \tag{4.12}
```

这就意味着
```math
m\backslash n \iff m_p \le n_p,\ \forall p. \tag{4.13}
```

由此立即推出
```math
k = \gcd(m,n) \iff k_p = \min(m_p, n_p),\ \forall p \tag{4.14} 
```
```math
k = \operatorname{lcm}(m,n) \iff k_p = \max(m_p, n_p),\ \forall p \tag{4.15}
```

例如，因为 $12=2^2\cdot3^1$ 且 $18=2^1\cdot3^2$，我们可以通过取公共指数的最小值和最大值来得到它们的 $\gcd$ 和 $\operatorname{lcm}$：
```math
\gcd(12,18) = 2^{\min(2,1)} \cdot 3^{\min(1,2)} = 2^1 \cdot 3^1 = 6 \\
\operatorname{lcm}(12,18) = 2^{\max(2,1)} \cdot 3^{\max(1,2)} = 2^2 \cdot 3^2 = 36
```

如果素数 $p$ 整除乘积 $mn$，那么它一定整除 $m$ 或 $n$（可能两者都整除），这是唯一分解定理的推论。但合数没有这个性质。例如，非素数 $4$ 整除 $60=6\cdot10$，但它既不整除 $6$ 也不整除 $10$。原因很简单：在分解 $60=6\cdot10=(2\cdot3)(2\cdot5)$ 中，$4=2\cdot2$ 的两个素因子被分到了两部分里，因此 $4$ 不整除其中任何一部分。而素数是不可再分的，所以它必须整除原来的其中一个因子。

## 4.3 PRIME EXAMPLES
素数有多少个？有很多。事实上，有无穷多个。欧几里得早在他的《几何原本》命题9:20中就证明了这一点，证明如下。假设素数只有有限个，设为 $k$ 个——$2,3,5,\dots,P_k$。那么，欧几里得说，我们可以考虑这样一个数：
```math
M=2\cdot 3\cdot 5\cdot \dots P_k+1
```

这 $k$ 个素数都不能整除 $M$，因为它们都能整除 $M-1$。因此一定存在某个其他素数整除 $M$；或许 $M$ 本身就是素数。这与我们假设 $2,3,\dots,P_k$ 是全部素数矛盾，所以素数一定有无穷多个。

欧几里得的证明启发我们通过递推式定义欧几里得数
```math
e_n = e_1 e_2 \dots e_{n-1} + 1,\ when\ n\ge 1. \tag{4.16}
```

该数列的前几项为
```math
\begin{aligned}
e_1 &= 1 + 1 = 2; \\
e_2 &= 2 + 1 = 3; \\
e_3 &= 2\cdot3 + 1 = 7; \\
e_4 &= 2\cdot3\cdot7 + 1 = 43;
\end{aligned}
```

这些数都是素数。但下一项 $e_5 = 1807 = 13\cdot139$ 是合数。结果表明 $e_6 = 3263443$ 是素数，而
```math
\begin{aligned}
e_7 &= 547\cdot607\cdot1033\cdot31051; \\
e_8 &= 29881\cdot67003\cdot9119521\cdot6212157481
\end{aligned}
```

已知 $e_9,\dots,e_{17}$ 都是合数，剩下的 $e_n$ 也很可能都是合数。不过欧几里得数两两互质，即
```math
\gcd(e_m,e_n)=1,\ when\ m \neq n
```

欧几里得算法（还能有别的吗？）用三步就能简单证明这一点，因为当 $n > m$ 时，$e_n \bmod e_m = 1$：
```math
\gcd(e_m,e_n) = \gcd(1,e_m) = \gcd(0,1) = 1
```

因此，如果令 $q_j$ 为 $e_j$ 的最小素因子，对所有 $j \ge 1$，那么素数 $q_1,q_2,q_3,\dots$ 互不相同。这就构成了一个无穷素数序列。

我们暂且从第1章的角度来考虑欧几里得数。能否把 $e_n$ 写成闭形式？递推式 $(4.16)$ 可以去掉省略号进行简化：若 $n > 1$，则有
```math
e_n = e_1\cdots e_{n-2}e_{n-1}+1 = (e_{n-1}-1)e_{n-1}+1 = e_{n-1}^2 - e_{n-1} + 1
```

因此 $e_n$ 的十进制位数大约是 $e_{n-1}$ 的两倍。习题37证明存在常数 $E \approx 1.264$ 使得
```math
e_n = \lfloor E^{2^n} + \frac{1}{2} \rfloor. \tag{4.17}
```

并且习题60给出了一个类似的、只生成素数的公式：
```math
p_n = \lfloor P^{3^n} \rfloor. \tag{4.18}
```

对于某个常数 $P$。但像 $(4.17)$ 和 $(4.18)$ 这样的式子并不能真正被看作闭形式，因为常数 $E$ 和 $P$ 是以一种不太直观的方式从 $e_n$ 和 $p_n$ 算出来的。目前并不存在（也不太可能存在）能把它们与其他有数学意义的常数联系起来的独立关系式。

事实上，没人知道任何既能生成任意大素数、又只生成素数的实用公式。不过在 1984 年，雪佛龙地球科学公司的计算机科学家们有了重大数学发现。他们使用由戴维·斯洛温斯基开发的程序，找到了当时已知的最大素数
```math
2^{216091}-1,
```

当时他们正在测试一台全新的 Cray X‑MP 超级计算机。如今在个人电脑上只需几毫秒就能算出这个数，因为现代计算机采用二进制，而这个数就是 $(11\dots1)_2$，它的全部 $216091$ 个比特都是 $1$。但要证明它是素数则困难得多。事实上，几乎任何涉及它的计算都非常耗时，因为它实在太大。例如，即便使用高效算法，在个人电脑上把 $2^{216091}-1$ 转换成十进制也要好几分钟。如果打印出来，它的 $65050$ 位十进制数字按美国一类邮件寄送需要 $75$ 美分邮资。

顺便一提，$2^{216091}-1$ 正是有 $216091$ 个圆盘时，求解汉诺塔问题所需的最少步数。形如
```math
2^p-1,
```

$2^p-1$（其中 $p$ 为素数，本章均如此）的数被称为**梅森数**，以17世纪研究过它们性质的马林·梅森神父命名$[269]$。迄今为止已知的梅森素数对应的 $p$ 为：$2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279,2203,2281,3217,4253,4423,9689,9941,11213,19937,21701,23209,44497,86243,110503,132049,216091$ 以及 $756839$。

若 $n$ 是合数，则 $2^n-1$ 不可能为素数，因为 $2^{km}-1$ 以 $2^m-1$ 为因子：
```math
2^{km}-1 = (2^m-1)(2^{m(k-1)} + 2^{m(k-2)} + \dots + 1).
```

但当 $p$ 为素数时，$2^p-1$ 并不总是素数；最小的反例是 $2^{11}-1=2047=23\cdot89$。（梅森本人就知道这一点。）

大数的因式分解与素性测试是如今的热门课题。截至1981年的已知成果汇总于文献[208]的4.5.4节，且新的研究成果仍在不断涌现。该书的391-394页介绍了一种测试梅森数素性的专用方法。

在过去两百年的大部分时间里，已知的最大素数均为梅森素数——尽管目前仅发现了31个梅森素数。许多人都在尝试寻找更大的梅森素数，但这件事的难度正不断增加。因此，那些真正渴望成名（哪怕不求财富）、希望登上《吉尼斯世界纪录大全》的人，或许可以转而研究形如 $2^n k + 1$ 的数（取 $k=3$ 或 $5$ 这类小值）。这类数的素性测试速度几乎与梅森数一样快；文献[208]中4.5.4节的习题27给出了具体方法。

我们尚未完全回答最初那个“素数有多少个”的问题。素数有无穷多个，但某些无穷集比另一些“更稠密”。例如，正整数中有无穷多个偶数，也有无穷多个完全平方数；然而从若干重要意义上讲，偶数比完全平方数更多。一种衡量方式是看第 $n$ 项的大小：第 $n$ 个偶数是 $2n$，第 $n$ 个完全平方数是 $n^2$；当 $n$ 很大时，$2n$ 远小于 $n^2$，第 $n$ 个偶数出现得远早于第 $n$ 个完全平方数，因此可以说偶数比完全平方数多得多。类似地，也可以看不超过 $x$ 的数的个数：不超过 $x$ 的偶数有 $\lfloor x/2 \rfloor$ 个，完全平方数有 $\lfloor \sqrt{x} \rfloor$ 个；当 $x$ 很大时，$x/2$ 远大于 $\sqrt{x}$，同样可以说偶数多得多。

从这两种意义上，我们能对素数说些什么呢？结论是：第 $n$ 个素数 $p_n$ 大约等于 $n$ 乘以 $n$ 的自然对数：
```math
p_n \sim n\ln n
```
（符号 $\sim$ 可读作“渐近等于”，它表示当 $n\to\infty$ 时，比值 $p_n/(n\ln n)$ 的极限为 $1$。）类似地，对于不超过 $x$ 的素数个数 $\pi(x)$，我们有所谓的**素数定理**：
```math
\pi(x)\sim\frac{x}{\ln x}.
```

证明这两个结论超出了本书的范围，尽管我们可以轻松证明它们彼此等价。在第9章中，我们将讨论函数趋于无穷的速度，并会看到用来近似 $p_n$ 的函数 $n\ln n$，在渐近意义下介于 $2n$ 和 $n^2$ 之间。因此，素数比偶数少，但比完全平方数多。

这些公式只在 $n$ 或 $x\to\infty$ 的极限情况下成立，我们可以用更精确的估计式来代替它们。例如，Rosser 和 Schoenfeld [312] 给出了好用的上下界：
```math
\ln x - \frac{3}{2} < \frac{x}{\pi(x)} < \ln x - \frac{1}{2},\quad \text{for } x\ge 67; \tag{4.19}
```
```math
n\!\left(\ln n+\ln\ln n-\dfrac32\right) < p_n < n\!\left(\ln n+\ln\ln n-\dfrac12\right),\quad \text{for } n\ge 20. \tag{4.20}
```

如果观察一个“随机”整数 $n$，它是素数的概率大约是 $\dfrac{1}{\ln n}$。例如，在 $10^{16}$ 附近的数中，我们大约需要检查 $\ln 10^{16}\approx 36.8$ 个数才能找到一个素数。（事实上，在 $10^{16}-370$ 到 $10^{16}-1$ 之间恰好有 $10$ 个素数。）然而素数的分布存在许多不规则性。比如，$p_1p_2\cdots p_n+2$ 到 $p_1p_2\cdots p_n+p_{n+1}-1$ 之间的所有整数都是合数。目前已知很多“孪生素数”对 $p$ 和 $p+2$（如 $5$ 和 $7$，$11$ 和 $13$，$17$ 和 $19$，$29$ 和 $31$，……，$9999999999999641$ 和 $9999999999999643$，……），但没人知道是否存在无穷多组孪生素数。（参见 Hardy 和 Wright [181, §1.4 和 §2.8]。）

计算所有不超过 $x$ 的素数（共 $\pi(x)$ 个）的一个简单方法是构造所谓的**埃拉托斯特尼筛法**：先写下从 $2$ 到 $x$ 的所有整数。接着圈出 $2$，标记为素数，并划掉 $2$ 的其余所有倍数。然后不断圈出最小的、既未圈出也未划掉的数，并划掉它的其余倍数。当所有数都被圈出或划掉后，圈出的数就是素数。例如当 $x=10$ 时，我们写下 $2$ 到 $10$，圈出 $2$，然后划掉它的倍数 $4,6,8,10$。接下来 $3$ 是最小的未圈未划数，于是圈出 $3$ 并划掉 $6,9$。现在 $5$ 最小，圈出 $5$ 并划掉 $10$。最后圈出 $7$。圈出的数是 $2,3,5,7$；因此不超过 $10$ 的素数共有 $\pi(10)=4$ 个。

## 4.4 FACTORIAL FACTORS 阶乘因子

现在我们来看一些有趣的**高合数**——阶乘的素因数分解：
```math
n! = 1\cdot 2\cdot\,\dots\,\cdot n = \prod\limits_{k=1}^{n} k,\quad \text{整数 } n\ge 0. \tag{4.21}
```

根据空乘积的约定，我们定义 $0! = 1$。于是对每个正整数 $n$，都有 $n! = (n-1)!\,n$。它是 $n$ 个不同对象的**排列数**，也就是把 $n$ 个物体排成一行的方法总数：第一个位置有 $n$ 种选择；对第一个的每种选择，第二个位置有 $n-1$ 种选择；对这 $n(n-1)$ 种选择中的每一种，第三个位置又有 $n-2$ 种选择；依此类推，总共有 $n(n-1)(n-2)\cdots 1$ 种排列。下面是阶乘函数的前几项值。

n | 1 | 2| 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10
| --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: |
n! |1 | 2 | 6 | 24 | 120 | 720 | 5040 | 40320 | 362880 | 3628800

记住一些阶乘的结论很有用，比如前六个左右的值，以及 $10!$ 大约是三百多万；另一个有趣的结论是：当 $n\ge25$ 时，$n!$ 的位数会超过 $n$。

我们可以用第 1 章里类似高斯的技巧来证明 $n!$ 是相当大的：
```math
n! = (1\cdot 2\cdots n)(n\cdots 2\cdot 1) = \prod\limits_{k=1}^{n} k(n+1-k).
```

我们有 $n \le k(n+1-k) \le \dfrac14(n+1)^2$，因为二次多项式 $k(n+1-k) = \dfrac14(n+1)^2 - \bigl(k-\dfrac12(n+1)\bigr)^2$ 在 $k=1$ 处取最小值，在 $k=\dfrac12(n+1)$ 处取最大值。因此
```math
\prod_{k=1}^{n} n \le n!^2 \le \prod_{k=1}^{n} \dfrac{(n+1)^2}{4};
```

也就是说，
```math
n^{n/2} \le n! \le \dfrac{(n+1)^n}{2^n} \tag{4.22}
```
这个式子告诉我们，阶乘函数是**指数增长**的！！

为了在 $n$ 很大时更精确地近似 $n!$，我们可以使用**斯特林公式**，这将在第 9 章推导：
```math
n! \sim \sqrt{2\pi n}\left(\dfrac{n}{e}\right)^n \tag{4.23}
```

而更精确的近似式可以给出渐近相对误差：斯特林公式对 $n!$ 的低估程度大约是 $1/(12n)$ 倍。即使对较小的 $n$，这个更精确的估计也相当不错。例如，当 $n=10$ 时，斯特林近似式 (4.23) 给出的值接近 $3598696$，比真实值小约 $0.83\% \approx 1/120$。渐近分析，真香。

但我们回到素数上来。我们希望对任意给定的素数 $p$，求出整除 $n!$ 的 $p$ 的最高次幂，也就是 $n!$ 唯一素因数分解中 $p$ 的指数。我们把这个数记为 $e_p(n!)$，并从 $p=2$、$n=10$ 的小例子开始研究。因为 $10!$ 是十个数的乘积，$e_2(10!)$ 可以通过把这十个数各自含有的 $2$ 的幂次相加得到；这个计算对应于把下面数组的列相加：
| | 1 | 2| 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | powers of 2
| --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: |
divisible by 2 |  | x |  | x |  | x |  | x |  | x | $5 = \lfloor 10/2\rfloor$
divisible by 4 |  |  |  | x |  |  |  | x |  |  | $2 = \lfloor 10/4\rfloor$
divisible by 8 |  |  |  |  |  |  |  | x |  |  | $1 = \lfloor 10/8\rfloor$
powers of 2 | 0 | 1 | 0 | 2 | 0 | 1 | 0 | 3 | 0 | 1 | 8

（这些列的和构成了有时被称为**尺规函数** $\rho(k)$ 的序列，因为它们和英寸刻度的长短线条很像。）这十列的和加起来是 $8$，因此 $2^8$ 整除 $10!$，但 $2^9$ 不整除。

还有另一种方法：我们可以按行求和。第一行标记贡献一个 2 的幂的数（即可被 2 整除），共有 $\lfloor 10/2 \rfloor=5$ 个。第二行标记再贡献一个 2 的幂的数，共有 $\lfloor 10/4 \rfloor=2$ 个。第三行标记再贡献一个的数，共有 $\lfloor 10/8 \rfloor=1$ 个。这些就覆盖了所有贡献，所以 $e_2(10!)=5+2+1=8$。

对于一般的 $n$，这个方法给出
```math
\epsilon_2(n!) = \left\lfloor\frac{n}{2}\right\rfloor + \left\lfloor\frac{n}{4}\right\rfloor + \left\lfloor\frac{n}{8}\right\rfloor + \cdots = \sum_{k\ge 1}\left\lfloor\frac{n}{2^k}\right\rfloor
```

这个和实际上是有限的，因为当 $2^k > n$ 时项为 0。所以它只有 $\lfloor\lg n\rfloor$ 个非零项，计算起来非常方便。例如当 $n=100$ 时，我们有
```math
\epsilon_2(100!)=50+25+12+6+3+1=97.
```

每一项都是前一项向下取半。这对所有 $n$ 都成立，因为作为式 $(3.11)$ 的特例，我们有 $\left\lfloor n/2^{k+1} \right\rfloor = \left\lfloor \left\lfloor n/2^k \right\rfloor / 2 \right\rfloor$。把数写成二进制时尤其容易看清这一点：
```math
\begin{align*}
100 &= (1100100)_2 &= 100 \\
\left\lfloor 100/2 \right\rfloor &= (110010)_2 &= 50 \\
\left\lfloor 100/4 \right\rfloor &= (11001)_2 &= 25 \\
\left\lfloor 100/8 \right\rfloor &= (1100)_2 &= 12 \\
\left\lfloor 100/16 \right\rfloor &= (110)_2 &= 6 \\
\left\lfloor 100/32 \right\rfloor &= (11)_2&= 3 \\
\left\lfloor 100/64 \right\rfloor &= (1)_2 &= 1 \\
\end{align*}
```
我们只需要把前一项的最低有效位去掉，就能得到下一项。

二进制表示还能帮我们推出另一个公式：
```math
\epsilon_2(m!) = m - v_2(m), \tag{4.24}
```
其中 $v_2(n)$ 是 $n$ 的二进制表示中 $1$ 的个数。这个简化式成立，是因为每个对 $n$ 的值贡献 $2^m$ 的 $1$，都会对 $\epsilon_2(n!)$ 的值贡献 $2^{m-1}+2^{m-2}+\dots+2^0=2^m-1$。

将结论推广到任意素数 $p$，我们有
```math
\epsilon_p(n!) = \left\lfloor\frac{n}{p}\right\rfloor + \left\lfloor\frac{n}{p^2}\right\rfloor + \left\lfloor\frac{n}{p^3}\right\rfloor + \cdots = \sum_{k\ge 1}\left\lfloor\frac{n}{p^k}\right\rfloor\tag{4.25}
```
由同样的推理可得。

$\epsilon_p(n!)$ 大约有多大？我们只需去掉求和项中的下取整符号，然后对无穷等比数列求和，就能得到一个简单（但很好）的上界：
```math
\begin{align*}
\epsilon_p(n!) &< \frac{n}{p} + \frac{n}{p^2} + \frac{n}{p^3} + \cdots \\
&= \frac{n}{p}\left(1 + \frac{1}{p} + \frac{1}{p^2} + \cdots\right) \\
&= \frac{n}{p} \left(\frac{p}{p-1}\right) \\
&= \frac{n}{p-1}
\end{align*}
```

当 $p=2$ 且 $n=100$ 时，这个不等式给出 $97 < 100$。可见上界 $100$ 不仅正确，而且与真实值 $97$ 非常接近。事实上，真实值 $n-v_2(n)$ 一般近似于 $n$，因为 $v_2(n)\le\lfloor\lg n\rfloor$ 相对于 $n$ 来说渐近地小得多。

当 $p=2$ 和 $p=3$ 时，我们的公式给出 $\epsilon_2(n!)\sim n$ 与 $\epsilon_3(n!)\sim n/2$，因此偶尔出现 $\epsilon_3(n!)$ 恰好等于 $\epsilon_2(n!)$ 的一半，看起来是合理的。例如，当 $n=6$ 和 $n=7$ 时就会发生这种情况，因为 $6!=2^4\cdot3^2\cdot5=7!/7$。但至今还没有人证明这样的巧合会无限次出现。

对 $\epsilon_p(n!)$ 的界反过来又给出了 $p^{\epsilon_p(n!)}$ 的界，这是 $p$ 在 $n!$ 中的贡献：
```math
p^{\epsilon_p(n!)} < p^{n/(p-1)}
```

我们可以对这个公式做进一步简化（哪怕会让上界变得更松），注意到 $p\le 2^{p-1}$；因此 $p^{n/(p-1)}\le (2^{p-1})^{n/(p-1)}=2^n$。换句话说，任意素数对 $n!$ 的贡献都小于 $2^n$。

我们可以用这个结论给出**素数有无穷多个**的另一种证明。因为如果只有 $k$ 个素数 $2,3,\dots,P_k$，那么对所有 $n>1$ 都会有 $n!<(2^n)^k=2^{kn}$，因为每个素数最多贡献 $2^n$ 的因子。但只要取足够大的 $n$，比如 $n=2^{2k}$，就能轻松推翻 $n!<2^{kn}$ 这个不等式。
```math
n! < 2^{nk} = 2^{2^{2k}k} = n^{n/2},
```

这就与我们在 $(4.22)$ 中得到的不等式 $n!\ge n^{n/2}$ 相矛盾。于是素数依然有无穷多个。

我们还可以把这个论证加强，得到关于 $\pi(n)$（不超过 $n$ 的素数个数）的一个粗略上界。每个这样的素数对 $n!$ 贡献的因子都小于 $2^n$，因此和之前一样，
```math
n! < 2^{n\pi(n)}
```

如果把这里的 $n!$ 换成斯特林近似式 $(4.23)$ 给出的下界，再取对数，就得到
```math
n\pi(n) > n\lg(n/e) + \frac12\lg(2\pi n)
```

因此
```math
\pi(n) > \lg(n/e)
```

与真实值 $\pi(n)\sim n/\ln n$ 相比，这个下界相当弱，因为当 $n$ 很大时，$\lg n$ 远小于 $n/\lg n$。但我们没费多大力气就得到了它，而且一个界终究是个界。


## 4.5 RELATIVE PRIMALITY 相对素性
当 $\gcd(m,n)=1$ 时，整数 $m$ 和 $n$ 没有公共素因子，我们称它们互素。

这个概念在实际中非常重要，我们本应为它设计一种专门的记号；但遗憾的是，数论学家们至今还没有达成一个很好的共识。所以我们呼吁：听我说，全世界的数学家们！别再等待了！现在就采用一种新记号，我们就能让许多公式变得更清晰！让我们约定：若 $m$ 与 $n$ 互素，则记作 $m\perp n$，读作“$m$ 与 $n$ 互素”。换句话说，我们定义：
```math
m\perp n\iff m,n\text{ 为整数且 }\gcd(m,n)=1.\tag{4.26}
```

分数 $m/n$ 是既约分数当且仅当 $m\perp n$。由于我们是通过约去分子和分母的最大公因子将分数化为既约形式的，因此我们猜想，一般地有
```math
\frac{m}{\gcd(m,n)} \perp \frac{n}{\gcd(m,n)}.\tag{4.27}
```

$\gcd(km,kn)=k\gcd(m,n)$，这一更一般的结论在习题 $14$ 中已证，由此即可推出上式成立。

利用数的素因子指数表示法，借助 $\gcd$ 的法则 $(4.14)$，关系 $\perp$ 可以有一个简洁的表述：
```math
m\perp n\iff \min(m_p,n_p)=0\text{ for all primes }p.\tag{4.28}
```

此外，由于 $m_p$ 和 $n_p$ 均为非负整数，我们可将其重写为
```math
m\perp n\iff m_pn_p=0\text{ for all primes }p.\tag{4.29}
```

现在我们可以证明一条重要法则，用它可以拆分与合并具有相同左边的两个 $\perp$ 关系：
```math
k\perp m\ and\ k\perp n\iff k\perp mn.\tag{4.30}
```

根据 $(4.29)$，这条法则换一种说法就是：当 $m_p$ 与 $n_p$ 均非负时，$k_p m_p=0$ 且 $k_p n_p=0$ 当且仅当 $k_p(m_p+n_p)=0$。

有一种优美的方法可以构造出所有满足 $m\perp n$ 的非负分数 $m/n$ 构成的集合，它被称为 **Stern-Brocot 树**，因为它由德国数学家 Moriz Stern [339] 与法国钟表匠 Achille Brocot [40] 各自独立发现。其思路是从两个分数 $\bigl(\frac01,\frac10\bigr)$ 开始，然后按需重复以下操作：

在两个相邻分数 $\frac{m}{n}$ 和 $\frac{m'}{n'}$ 之间插入 $\frac{m+m'}{n+n'}$。

这个新分数 $\frac{m+m'}{n+n'}$ 称为 $\frac{m}{n}$ 与 $\frac{m'}{n'}$ 的**中介分数（mediant）**。例如，第一步会在它们之间生成一个新项：
```math
\frac01,\ \frac11,\ \frac10
```

下一步再给出两个：
```math
\frac01,\ \frac12,\ \frac11,\ \frac21,\ \frac10
```

再下一步给出四个：
```math
\frac01,\ \frac13,\ \frac12,\ \frac23,\ \frac11,\ \frac32,\ \frac21,\ \frac31,\ \frac10
```

然后依次得到 $8$、$16$ 个，依此类推。整个序列可看作一棵**无限二叉树**，其顶层结构如下：
```math
\begin{array}{ccccccccc}
&&&& \dfrac{1}{1} &&&& \\
&& \swarrow && \downarrow && \searrow && \\
&& \dfrac{1}{2} &&&& \dfrac{2}{1} && \\
& \swarrow && \searrow && \swarrow && \searrow & \\
\dfrac{1}{3} &&&& \dfrac{2}{3} \quad \dfrac{3}{2} &&&& \dfrac{3}{1}
\end{array}
```

每个分数都是 $\dfrac{m+m'}{n+n'}$，其中 $\dfrac{m}{n}$ 是其左上方最近的祖先，$\dfrac{m'}{n'}$ 是其右上方最近的祖先。（“祖先”指沿着树枝向上能够到达的分数。）这棵树中可以观察到许多规律。


这种构造方式为什么有效？例如，为什么每个中介分数 $\dfrac{m+m'}{n+n'}$ 出现在这棵树中时一定是既约分数？（如果 $m$、$m'$、$n$、$n'$ 全都是奇数，我们就会得到偶数/偶数；但该构造 somehow 保证了分子分母均为奇数的分数永远不会相邻出现。）而为什么所有可能的分数 $\dfrac mn$ 都恰好出现一次？为什么某个分数不会出现两次，或者根本不出现？

所有这些问题都有着惊人简洁的答案，其依据是如下基本事实：若 $\frac{m}{n}$ 与 $\frac{m'}{n'}$ 是构造过程中任意阶段的相邻分数，则有
```math
m'n - mn' = 1.\tag{4.31}
```

该关系式在初始时成立（$1\cdot1-0\cdot0=1$）；当我们插入新的中介分数 $\frac{m+m'}{n+n'}$ 时，需要验证的新情形为
```math
(m+m')n - m(n+n') = 1; \\
m'(n+n')-(m+m')n'=1.
```
这两个等式都等价于它们所替换的原始条件 $(4.31)$。因此 $(4.31)$ 在构造的所有阶段都是不变式。

此外，如果 $\frac{m}{n}<\frac{m'}{n'}$ 且所有值均非负，那么容易验证
```math
\frac{m}{n}<\frac{m+m'}{n+n'}<\frac{m'}{n'}.
```

中介分数并不在其前驱的正中间，但确实位于两者之间。因此该构造保持了顺序，我们不可能在两个不同位置得到同一个分数。

还有一个问题：任何满足 $a\le b$ 的正分数 $\frac{a}{b}$ 会不会被漏掉？答案是不会。因为我们可以把构造过程限制在 $\frac{a}{b}$ 的紧邻区域内，而在这个区域里的性质很容易分析：初始时我们有
```math
\frac{0}{1}=0<\Bigl(\frac{a}{b}\Bigr)<\frac{1}{0}=\infty.
```

其中我们给 $\frac{a}{b}$ 加上括号，表示它目前还没有真正出现。然后如果在某一阶段我们有
```math
\frac{m}{n}<\Bigl(\frac{a}{b}\Bigr)<\frac{m'}{n'}
```

构造就会生成 $\frac{m+m'}{n+n'}$，此时有三种情况：要么 $\frac{m+m'}{n+n'}=\frac{a}{b}$，我们就找到了；要么 $\frac{m+m'}{n+n'}<\frac{a}{b}$，我们就令 $m\leftarrow m+m',n\leftarrow n+n'$；要么 $\frac{m+m'}{n+n'}>\frac{a}{b}$，我们就令 $m'\leftarrow m+m',n'\leftarrow n+n'$。这个过程不可能无限进行，因为条件
```math
m'b - na > 0\ and\ an' - bm' > 0
```

蕴含着
```math
an - bm \ge 1\ and\ bm' - an' \ge 1;
```

因此
```math
(m'+n')(an - bm) + (m + n)(bm' - an') \ge m' + n' + m + n;
```

而根据 $(4.31)$，上式等价于 $a+b \ge m+n+m'+n'$。每一步中 $m$、$n$、$m'$、$n'$ 中至少有一个会增大，因此我们最多在 $a+b$ 步内就一定能找到目标分数。

$N$ 阶法雷级数（记作 $\mathcal{F}_N$），是指 $0$ 到 $1$ 之间所有既约分数构成的集合，其分母不超过 $N$，并按递增顺序排列。例如当 $N=6$ 时，有
```math
\mathcal{F}_6 = \bigl\{\frac{0}{1},\frac{1}{6},\frac{1}{5},\frac{1}{4},\frac{1}{3},\frac{2}{5},\frac{1}{2},\frac{3}{5},\frac{2}{3},\frac{3}{4},\frac{4}{5},\frac{5}{6},\frac{1}{1}\bigr\}
```

一般地，我们可以这样得到 $\mathcal{F}_N$：从 $\mathcal{F}_1=\bigl\{\frac{0}{1},\frac{1}{1}\bigr\}$ 开始，只要分母不超过 $N$ 就不断插入中介分数。用这种方法不会漏掉任何分数，因为我们已知斯特恩‑布罗科特构造不会遗漏分数，而且分母 $\le N$ 的中介分数一定由分母 $\le N$ 的分数生成。（换句话说，$\mathcal{F}_N$ 对应斯特恩‑布罗科特树的一棵子树，通过剪去不需要的分支得到。）由此可知，当 $\frac{m}{n}$ 与 $\frac{m'}{n'}$ 是法雷级数中相邻两项时，必有 $m'n - mn' = 1$。

这种构造方式表明，可以从 $\mathcal{F}_{N-1}$ 简单得到 $\mathcal{F}_N$：只需在 $\mathcal{F}_{N-1}$ 中满足分母之和为 $N$ 的相邻两项 $\frac{m}{n}$、$\frac{m'}{n'}$ 之间插入分数 $\frac{m+m'}{N}$ 即可。例如，很容易按此规则插入相应分数，从 $\mathcal{F}_6$ 得到 $\mathcal{F}_7$。
```math
\mathcal{F}_7 = \bigl\{\frac{0}{1},\frac{1}{7},\frac{1}{6},\frac{1}{5},\frac{1}{4},\frac{2}{7},\frac{1}{3},\frac{2}{5},\frac{3}{7},\frac{1}{2},\frac{4}{7},\frac{3}{5},\frac{2}{3},\frac{5}{7},\frac{3}{4},\frac{4}{5},\frac{5}{6},\frac{6}{7},\frac{1}{1}\bigr\}
```

当 $N$ 为素数时，会出现 $N-1$ 个新分数；否则新分数个数会少于 $N-1$，因为该过程只生成与 $N$ 互质的分子。

很久以前在 $(4.5)$ 中我们已经用不同的方式证明过：只要 $m\perp n$ 且 $0<m\le n$，就一定存在整数 $a$ 和 $b$ 使得
```math
ma - nb = 1.\qquad (4.32)
```

（实际上我们当时写的是 $m'm + n'n = \gcd(m,n)$，但此处可令 $\gcd(m,n)=1$、$a=m'$、$b=-n'$。）法雷级数为 $(4.32)$ 提供了另一种证明：只需取 $\frac{b}{a}$ 作为 $\mathcal{F}_n$ 中位于 $\frac{m}{n}$ 之前的分数即可。因此式 $(4.5)$ 本质上就是式 $(4.31)$ 的重现。例如，方程 $3a - 7b = 1$ 的一组解是 $a=5, b=2$，因为 $\frac{2}{5}$ 是 $\mathcal{F}_7$ 中排在 $\frac{3}{7}$ 之前的分数。这一构造说明，若 $0<m\le n$，则总能找到满足 $0\le b<a<n$ 的解 $(a,b)$ 使得 $(4.32)$ 成立。同理，若 $0\le n<m$ 且 $m\perp n$，取 $\frac{a}{b}$ 为 $\mathcal{F}_m$ 中位于 $\frac{n}{m}$ 之后的分数，就能得到满足 $0<a\le b\le m$ 的解。

法雷级数中任意三个连续项有着一个极为精妙的性质，这会在习题 $61$ 中证明。不过我们最好不再继续讨论法雷级数，因为整个斯特恩‑布罗科特树其实更加有趣。

事实上，我们可以把斯特恩‑布罗科特树看作表示有理数的数制，因为每个正的既约分数都会恰好出现一次。我们用字母 $L$ 和 $R$ 分别表示从树根走向某分数时向左或向右走一步；那么由 $L$、$R$ 组成的字符串就唯一地对应树上的一个位置。例如，$LRRL$ 表示：从 $\frac{1}{1}$ 向左走到 $\frac{1}{2}$，再向右走到 $\frac{2}{3}$，再向右走到 $\frac{3}{4}$，再向左走到 $\frac{5}{7}$。于是我们可以把 $LRRL$ 看作 $\frac{5}{7}$ 的一种表示。每个正分数都能这样唯一地表示成一个由 $L$ 和 $R$ 构成的字符串。

不过其实有个小问题：分数 $\frac{1}{1}$ 对应空字符串，我们需要给它一个记号。约定把它记作 $I$，因为它看起来有点像 $1$，而且表示“单位元”。

这种表示法自然引出两个问题：(1) 给定互质的正整数 $m$ 和 $n$，对应 $\frac{m}{n}$ 的 $L$, $R$ 串是什么？(2) 给定一个 $L$, $R$ 串，它对应的分数是多少？问题 (2) 看起来更简单，我们先来处理它。为此定义: $f(S) =$  字符串 $S$ 对应的分数

其中 $S$ 是由 $L$ 和 $R$ 组成的字符串。例如 $f(LRRL) = \frac{5}{7}$。

根据构造规则，若 $\frac{m}{n}$ 和 $\frac{m'}{n'}$ 是树中上层里位于 $S$ 前后最近的两个分数，则 $f(S) = \frac{m+m'}{n+n'}$。初始时 $\frac{m}{n} = \frac{0}{1}$，$\frac{m'}{n'} = \frac{1}{0}$；然后在树中向右或向左移动时，我们分别用中介数 $\frac{m+m'}{n+n'}$ 依次替换 $\frac{m}{n}$ 或 $\frac{m'}{n'}$。

怎样用简洁易用的数学公式刻画这一过程？稍加尝试后会发现，最好的方法是维护一个 $2\times2$ 矩阵
```math
M(S) = \begin{pmatrix} n & n' \\ m & m'\end{pmatrix}
```

这个矩阵保存了包围 $f(S)$ 的两个“祖先分数” $\frac{m}{n}$ 与 $\frac{m'}{n'}$ 所涉及的四个量。按分数形式，我们本可以把 $m$、$m'$ 放上面，$n$、$n'$ 放下面；但这种上下颠倒的排布会更简洁优美，因为过程开始时 $M(I) = \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix}$，而 $\begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix}$ 正是通常所说的单位矩阵 $I$。

向左移动一步会将 $n'$ 替换为 $n+n'$，将 $m'$ 替换为 $m+m'$；因此
```math
M(SL) = 
\begin{pmatrix} n & n+n' \\ 
m & m+m'
\end{pmatrix} = 
\begin{pmatrix} n & n'  \\ 
m & m'
\end{pmatrix} 
\begin{pmatrix} 1 & 1 \\ 
0 & 1 
\end{pmatrix} = 
M(S) \begin{pmatrix} 1 & 1 \\ 0 & 1 \end{pmatrix}
```

（这是下述通用规则的一个特例：
```math
\begin{pmatrix} a & b \\ c & d \end{pmatrix} \begin{pmatrix} w & x \\ y & z \end{pmatrix} = \begin{pmatrix} aw+by & ax+bz \\ cw+dy & cx+dz \end{pmatrix}
```
（这是 $2\times2$ 矩阵乘法的一般规则。）同理可得
```math
M(SR) = \begin{pmatrix} n+n' & n' \\ m+m' & m' \end{pmatrix} = M(S) \begin{pmatrix} 1 & 0 \\ 1 & 1 \end{pmatrix}
```

因此如果我们把 $L$ 和 $R$ 定义为 $2\times2$ 矩阵
```math
L = \begin{pmatrix} 1 & 1 \\ 0 & 1 \end{pmatrix},\quad R = \begin{pmatrix} 1 & 0 \\ 1 & 1 \end{pmatrix}. \qquad (4.33)
```

那么通过对字符串 $S$ 的长度做归纳，就能得到简洁的公式 $M(S) = S$。是不是很巧妙？（字母 $L$ 和 $R$ 承担着双重角色：既是矩阵，也是字符串表示中的字符。）例如：
```math
M(LRRL) = LRRL = 
\begin{pmatrix} 1 & 1 \\ 0 & 1 \end{pmatrix} \begin{pmatrix} 1 & 0 \\ 1 & 1 \end{pmatrix} \begin{pmatrix} 1 & 0 \\ 1 & 1 \end{pmatrix} \begin{pmatrix} 1 & 1 \\ 0 & 1 \end{pmatrix} = 
\begin{pmatrix} 2 & 1 \\ 1 & 1 \end{pmatrix} \begin{pmatrix} 1 & 1 \\ 1 & 2 \end{pmatrix}= 
\begin{pmatrix} 3 & 4 \\ 2 & 3 \end{pmatrix};
```

包围 $LRRL$ 对应分数 $\frac{5}{7}$ 的祖先分数是 $\frac{2}{3}$ 和 $\frac{3}{4}$。这一构造也给出了问题 (2) 的答案：
```math
f(S) = f\begin{pmatrix}\begin{pmatrix} n & n' \\ m & m' \end{pmatrix}\end{pmatrix} = \frac{m+m'}{n+n'}. \qquad (4.34)
```

那问题 (1) 该如何解决呢？现在既然理解了树节点与 $2\times2$ 矩阵之间的核心关联，这个问题就变得简单了。给定一对互质的正整数 $m$ 和 $n$，我们可以通过如下“二分查找”的方式，找到 $\frac{m}{n}$ 在斯特恩‑布罗科特树中的位置：
$S := I;$

$\text{while } m/n \neq f(S) \text{ do}$

$\quad \text{if } \frac{m}{n} < f(S) \text{ then } (\text{output}(L); S := SL) \\ \text{ else } (\text{output}(R); S := SR).$

这会输出所需的由 $L$ 和 $R$ 组成的字符串。

也有另一种方法可以完成同样的工作，即通过修改 $m$ 和 $n$ 而非维护状态 $S$。若 $S$ 为任意 $2\times2$ 矩阵，则有
```math
f(RS) = f(S) + 1
```

这是因为 $RS$ 类似于 $S$，只是将 $S$ 的第一行加到了第二行上。（我们来慢慢推导一下：
```math
S = \begin{pmatrix} m & m' \\ n & n' \end{pmatrix};\quad RS = \begin{pmatrix} n & n' \\ m+n & m'+n' \end{pmatrix};
```

因此 $f(S) = (m+m')/(n+n')$ 且 $f(RS) = ((m+n)+(m'+n'))/(n+n')$。）若我们对分数 $m/n$（其中 $m > n$）执行二分查找算法，第一个输出结果将是 $R$；因此该算法后续的执行过程中，$f(S)$ 的值会恰好比我们以 $(m-n)/n$ 而非 $m/n$ 为初始值时大 $1$。类似的性质对 $L$ 也成立，于是我们有

```math
\frac{m}{n} = f(RS) \iff \frac{m-n}{n} = f(S),\quad \text{当 } m > n \text{ 时};
```
```math
\frac{m}{n} = f(LS) \iff \frac{m}{n-m} = f(S),\quad \text{当 } m < n \text{ 时}.
```

这意味着我们可以将二分查找算法转化为如下无矩阵的过程：
```math
while m\ne n do \\
if m<n\ then (output(L); n:=n-m) \\
       else (output(R); m:=m-n).
```

例如，给定 $m/n = 5/7$，我们会依次得到：
```math
m = 5\ 5\ 3\ 1\ 1 \\
n = 7\ 2\ 2\ 2\ 1 \\
output\ L\ R\ R\ L
```
在这个简化后的算法中。

无理数不会出现在斯特恩‑布罗科特树中，但所有“接近”它们的有理数都会出现。例如，若我们对数字 $e = 2.71828\ldots$（而非分数 $m/n$）执行二分查找算法，将会得到一个由 $L$ 和 $R$ 组成的无限字符串，其开头部分为：
```math
RRLRRLRLLLLRLRRRRRRLRLLLLLLLLRLR\cdots
```

我们可以把这个无限字符串看作是 $e$ 在斯特恩‑布罗科特数系中的表示，就如同我们可以把 $e$ 表示为无限小数 $2.718281828459\ldots$ 或无限二进制分数 $(10.101101111110\ldots)_2$ 一样。顺便说一下，结果表明 $e$ 在斯特恩‑布罗科特数系中的表示具有某种规律模式：
```math
e = R L^0 R L R^2 L R L^4 R L R^6 L R L^8 R L R^{10} L R L^{12} R L\ldots;
```
这等价于欧拉在24岁时发现的一个结论的特例。

从这个表示中我们可以推导出这些分数
```math
RRLRRLRLLLRLLRRRR, \\
s\frac{1}{1},\frac{2}{1},\frac{3}{1},\frac{5}{2},\frac{8}{3},\frac{11}{4},\frac{19}{7},\frac{30}{11},\frac{49}{18},\frac{68}{25},\frac{87}{32},\frac{106}{39},\frac{125}{46},\frac{144}{53},\frac{163}{60},\frac{182}{67},\frac{201}{74},\frac{220}{81},\ldots
```

这些是 $e$ 最简单的有理数上、下逼近。因为如果 $m/n$ 不在此列表中，那么列表中就存在某个分子 $\le m$、分母 $\le n$ 的分数介于 $m/n$ 和 $e$ 之间。例如，$\frac{25}{9}$ 就不如列表里的 $\frac{19}{7}=2.714\ldots$ 那样简洁且更接近 $e$。这是因为斯特恩‑布罗科特树不仅包含所有有理数，还按顺序排列，并且所有分子分母较小的分数都出现在更复杂的分数上方。于是，$\frac{25}{9}=RRLRRLL$ 小于 $\frac{19}{7}=RRLRRL$，而后者又小于 $e=RRLRRLRR\ldots$。用这种方法可以得到非常优秀的逼近。例如，$\frac{1264}{465}\approx 2.718280$ 与 $e$ 精确到小数点后六位一致；我们从 $e$ 的前19个斯特恩‑布罗科特表示字符得到这个分数，其精度与用19位二进制表示 $e$ 大致相当。

我们可以通过对无矩阵二分查找过程稍作修改，来得到无理数 $\alpha$ 的无限表示：
```math
if\ \alpha < 1\ then\ (output(L); \alpha:=\alpha(1-\alpha));  \\
 else\ (output(R); \alpha:=\alpha - 1).
```

（这些步骤需要无限次重复执行，或直至我们停止操作。）若 $\alpha$ 为有理数，通过这种方式得到的无限表示与之前的（有限）表示一致，只是在其右侧追加了 $RL^\infty$（即无限个L）。例如，当 $\alpha = 1$ 时，我们会得到 $RLLL\ldots$，对应分数序列 $\frac{1}{1},\frac{2}{1},\frac{3}{2},\frac{4}{3},\frac{5}{4},\ldots$，该序列的极限为1。若将 $L$ 视作0、$R$ 视作1，这个情形与普通二进制表示完全类似：正如区间 $[0..1)$ 内的每个实数 $x$ 都有一个不以全1结尾的无限二进制表示 $(.b_1b_2b_3\ldots)_2$，区间 $[0..\infty)$ 内的每个实数 $\alpha$ 都有一个不以全R结尾的无限斯特恩‑布罗科特表示 $B_1B_2B_3\ldots$。因此，若令 $0 \to L$、$1 \to R$，我们就能在区间 $[0..1)$ 和 $[0..\infty)$ 之间建立一个**保序的一一对应关系**。

欧几里得算法与有理数的斯特恩‑布罗科特表示之间存在密切联系。给定 $\alpha = m/n$，我们先得到 $\lfloor m/n \rfloor$ 个 $R$，接着是 $\lfloor n/(m \bmod n) \rfloor$ 个 $L$，然后是 $\lfloor (m \bmod n)/(n \bmod (m \bmod n)) \rfloor$ 个 $R$，依此类推。这些数 $m \bmod n$、$n \bmod (m \bmod n)$、…… 正是欧几里得算法中出现的数值。（最后需要稍作调整，以保证不会出现无限多个 $R$。）我们将在第6章进一步探讨这种关系。


---
## 4.6 MOD: THE CONGRUENCE RELATION 同余关系
模算术是数论提供的核心工具之一。我们在第3章中初次接触到它——当时我们将二元运算 `mod` 用作表达式中的一种运算。在本章中，我们还会将 `mod` 用于整个等式，此时采用一种稍有不同的记号会更方便：
```math
a \equiv b \pmod{m} \quad \iff \quad a \bmod m = b \bmod m. \tag{4.35}
```

例如，$9 \equiv -16 \pmod{5}$，因为 $9 \bmod 5 = 4 = (-16) \bmod 5$。式子 $a \equiv b \pmod{m}$ 可以读作“$a$ 与 $b$ 模 $m$ 同余”。该定义对任意实数 $a,b,m$ 都成立，但我们几乎只在整数范围内使用它。

因为 $x \bmod m$ 与 $x$ 相差 $m$ 的一个倍数，所以我们可以用另一种方式理解同余式：
```math
a \equiv b \pmod{m} \iff \text{a-b is a multiple of m}. \tag{4.36}
```

因为若 $a \bmod m = b \bmod m$，则式 $(3.21)$ 中 `mod` 的定义告诉我们 $a-b = a\bmod m + km - (b\bmod m + lm) = (k-l)m$，其中 $k$ 和 $l$ 为整数。反之若 $a-b = km$，则当 $m=0$ 时 $a=b$；否则
```math
\begin{align*}
a\bmod m = a-\lfloor a/m\rfloor m &= b+km-\lfloor (b+km)/m\rfloor m \\
&= b-\lfloor b/m\rfloor m = b\bmod m.
\end{align*}
```

式 $(4.36)$ 中 $\equiv$ 的刻画通常比 $(4.35)$ 更易用。例如，我们有 $8\equiv23\pmod{5}$，因为 $8-23=-15$ 是 $5$ 的倍数；我们不必同时计算 $8\bmod5$ 和 $23\bmod5$。

同余号 $\equiv$ 看起来与等号 $=$ 很相似，这很方便，因为同余式几乎就像等式一样。例如，同余是一种等价关系；也就是说，它满足自反律 $a\equiv a$，对称律 $a\equiv b\Rightarrow b\equiv a$，以及传递律 $a\equiv b,b\equiv c\Rightarrow a\equiv c$。所有这些性质都很容易证明，因为任何满足 $a\equiv b\iff f(a)=f(b)$（其中 $f$ 是某个函数）的关系 $\equiv$ 都是等价关系。（在我们这里，$f(x)=x\bmod m$。）此外，我们可以对同余的元素进行加、减运算而不破坏同余性：
```math
a\equiv b\ (\text{mod}\ m) \land c\equiv d\ (\text{mod}\ m) \;\Rightarrow\; a+c\equiv b+d\ (\text{mod}\ m);\\ 
```
```math
a\equiv b\ (\text{mod}\ m) \land c\equiv d\ (\text{mod}\ m) \;\Rightarrow\; a-c\equiv b-d\ (\text{mod}\ m).
```

因为若 $a-b$ 和 $c-d$ 均为 $m$ 的倍数，则 $(a+c)-(b+d)=(a-b)+(c-d)$ 和 $(a-c)-(b-d)=(a-b)-(c-d)$ 也均为 $m$ 的倍数。顺便提一下，并非每出现一次 $\equiv$ 就需要书写一次 $\pmod{m}$；若模数保持不变，我们只需在开头声明一次即可确定上下文。这是同余记号带来的一大便利。

乘法同样适用，只要我们处理的是整数：
```math
a\equiv b\ \text{and}\ c\equiv d\ \Rightarrow\ ac\equiv bd\pmod{m}. \text{integer b,c}.
```

证明：$ac-bd=(a-b)c+b(c-d)$。反复应用这一乘法性质，我们现在还可以取幂：
```math
a\equiv b\ \Rightarrow\ a^n\equiv b^n\pmod{m},\text{ integers }a,b; n\ge 0
```

例如，因为 $2\equiv-1\pmod{3}$，所以有 $2^n\equiv(-1)^n\pmod{3}$；这意味着 $2^n-1$ 是 $3$ 的倍数当且仅当 $n$ 为偶数。

因此，我们通常对等式进行的大多数代数运算，也同样可以用于同余式。是大多数，但并非全部。除法运算显然是个例外。若 $ad\equiv bd\pmod{m}$，我们不能总推出 $a\equiv b$。例如，$3\cdot2\equiv5\cdot2\pmod{4}$，但 $3\not\equiv5$。

不过，当 $d$ 与 $m$ 互质时，我们可以挽救同余式的消去律：
```math
ad\equiv bd\iff a\equiv b\pmod{m}, \\ \text{integer a,b,d,m and }d\perp m. \tag{4.37}
```

例如，由 $15\equiv35\pmod{m}$ 推出 $3\equiv7\pmod{m}$ 是合法的，除非模数 $m$ 是 $5$ 的倍数。

为证明这一性质，我们再次使用扩展欧几里得算法 $(4.5)$，找到整数 $d'$ 和 $m'$ 使得 $d'd+m'm=1$。那么若 $ad\equiv bd$，我们可以在同余式两边同乘 $d'$，得到 $ad'd\equiv bd'd$。由于 $d'd\equiv1$，于是有 $ad'd\equiv a$ 且 $bd'd\equiv b$，因此 $a\equiv b$。这一证明表明，在模 $m$ 同余的意义下，数 $d'$ 的作用几乎等同于 $1/d$；因此我们称其为“$d$ 在模 $m$ 下的逆元”。
```math
ad\equiv bd\pmod{md}\Rightarrow a\equiv b\pmod{m},\quad d\neq 0.\tag{4.38}
```

该定律对所有实数 $a,b,d,m$ 都成立，因为它仅依赖于分配律 $(a\bmod m)d=ad\bmod md$：我们有 $a\bmod m=b\bmod m\iff (a\bmod m)d=(b\bmod m)d\iff ad\bmod md=bd\bmod md$。因此，例如由 $3\cdot2\equiv5\cdot2\pmod{4}$ 我们可推出 $3\equiv5\pmod{2}$。
```math
ad\equiv bd\pmod{m} \\
\iff a\equiv b\pmod{\frac{m}{\gcd(d,m)}},\quad \text{integer }a,b,d,m.\tag{4.39}
```

因为我们可以用满足 $d'd+m'm=\gcd(d,m)$ 的 $d'$ 去乘 $ad\equiv bd$，这就得到同余式 $a\cdot\gcd(d,m)\equiv b\cdot\gcd(d,m)\pmod{m}$，该式两边可以除以 $\gcd(d,m)$。

我们再深入探讨一下改变模数的思想。如果已知 $a\equiv b\pmod{100}$，那么必然有 $a\equiv b\pmod{10}$，或者对 $100$ 的任意因数取模都成立。说 $a-b$ 是 $100$ 的倍数，比说它是 $10$ 的倍数更强。一般而言：
```math
a\equiv b\pmod{md}\Rightarrow a\equiv b\pmod{m},\quad \text{integer }d.\tag{4.40}
```
因为任何 $md$ 的倍数都是 $m$ 的倍数。

反之，如果已知 $a\equiv b$ 对两个较小的模数成立，我们能否推出对更大的模数也成立？答案是肯定的，其规则为：
```math
a\equiv b\pmod{m}\ \text{and}\ a\equiv b\pmod{n} \\
\iff a\equiv b\pmod{m}\ \text{且}\ a\equiv b\pmod{n}\iff a\equiv b\pmod{mn},\quad \text{if } m\perp n\tag{4.42}
```

例如，如果我们已知 $a\equiv b\pmod{12}$ 且 $a\equiv b\pmod{18}$，就可以稳妥地推出 $a\equiv b\pmod{36}$。原因是如果 $a-b$ 是 $m$ 和 $n$ 的公倍数，那么它一定是 $\operatorname{lcm}(m,n)$ 的倍数，这可由唯一分解定理推出。

该定律中 $m\perp n$ 的特殊情形极为重要，因为当 $m$ 与 $n$ 互质时 $\operatorname{lcm}(m,n)=mn$，因此我们将其明确表述出来：
```math
a\equiv b\pmod{mn} \\
a\equiv b\pmod{m} and\ a\equiv b\pmod{n}\iff a\equiv b\pmod{mn}，if\ m\perp n\tag{4.42}
```

例如，$a\equiv b\pmod{100}$ 当且仅当 $a\equiv b\pmod{25}$ 且 $a\equiv b\pmod{4}$。换一种说法，如果我们知道 $x\bmod 25$ 和 $x\bmod 4$，就有足够的信息确定 $x\bmod 100$。这是中国剩余定理的一个特例（见习题30），该定理之所以如此命名，是因为它大约在公元350年由中国的孙子发现。


式 $(4.42)$ 中的模数 $m$ 和 $n$ 可以进一步分解为互质的因子，直到每个不同的素数都被分离出来，因此
```math
a\equiv b\pmod{m}\iff a\equiv b\pmod{p^{m_p}} \text{for all p},
```

若 $m$ 的素因数分解式 $(4.11)$ 为 $m=\prod_p p^{m_p}$，则模素数幂的同余式是所有整数模同余式的构造基础。


---
## 4.7 INDEPENDENT RESIDUES 独立残差
同余的重要应用之一是剩余数系统，其中整数 $x$ 表示为关于两两互质模数的余数序列：
```math
\operatorname{Res}(x)=(x\bmod m_1,\dots,x\bmod m_r),\ if\ m_j\perp m_k,\ for\ 1\le j <k \le r.
```

知道 $x\bmod m_1,\dots,x\bmod m_r$ 并不能完全确定 $x$，但它可以让我们确定 $x\bmod m$，其中 $m$ 是乘积 $m_1\cdots m_r$。

在实际应用中我们常常知道 $x$ 落在某个范围内；那么只要知道 $x\bmod m$ 并且 $m$ 足够大，我们就能完全确定 $x$。

例如，我们来看一个只有两个模数 $3$ 和 $5$ 的剩余数系统的小例子：
$x \mod 15$ | $x \mod 3$ | $x \mod 5$
| :---: | :---: | :---: |
0 | 0 | 0
1 | 1 | 1
2 | 2 | 2
3 | 0 | 3
4 | 1 | 4
5 | 2 | 0
6 | 0 | 1
7 | 1 | 2
8 | 2 | 3
9 | 0 | 4
10 | 1 | 0
11 | 2 | 1
12 | 0 | 2
13 | 1 | 3
14 | 2 | 4

每个有序对 $(x\bmod 3,x\bmod 5)$ 都是不同的，因为 $x\bmod 3=y\bmod 3$ 且 $x\bmod 5=y\bmod 5$ 当且仅当 $x\bmod 15=y\bmod 15$。

利用同余的性质，我们可以对两个分量独立地进行加、减、乘法运算。例如，如果我们想计算 $7=(1,2)$ 与 $13=(1,3)$ 在模 $15$ 下的乘积，我们计算 $1\cdot1\bmod3=1$ 与 $2\cdot3\bmod5=1$。结果为 $(1,1)=1$；因此 $7\cdot13\bmod15$ 必定等于 $1$。显然确实如此。

这种独立性原理在计算机应用中非常有用，因为不同的分量可以被分别处理（例如由不同的计算机）。如果每个模数 $m_k$ 是互不相同的素数 $p_k$，选取其略小于 $2^{31}$，那么一台基本算术运算能处理范围 $[-2^{31},2^{31})$ 内整数的计算机，可以轻松计算模 $p_k$ 的和、差与积。一组 $r$ 个这样的素数使得对至多接近 $31r$ 位的“高精度数”进行加、减、乘运算成为可能，并且剩余数系统能让这些运算比用其他方式处理如此大的整数更快。

在适当的情况下我们甚至可以做除法。例如，假设我们想计算一个大整数行列式的精确值。结果会是一个整数 $D$，并且可以根据其元素的大小给出 $|D|$ 的界。但目前已知计算行列式的快速方法都需要除法，这会产生分数（如果使用二进制近似则会损失精度）。解决方法是对多个大素数 $p_k$ 计算 $D\bmod p_k=D_k$。我们可以在模 $p_k$ 下安全地做除法，除非除数恰好是 $p_k$ 的倍数。这种情况极不可能发生，但如果真的发生我们可以选择另一个素数。最后，知道足够多素数对应的 $D_k$，我们就有足够的信息确定 $D$。

但我们还没有说明如何从给定的余数序列 $(x\bmod m_1,\dots,x\bmod m_r)$ 还原出 $x\bmod m$。我们已经证明这种转换在理论上是可行的，但计算过程可能非常复杂，以至于在实际中无法使用。幸运的是，有一种相当简便的方法可以完成这项工作，我们可以用小表中的 $(x\bmod3,x\bmod5)$ 情况来演示。核心思想是分别求解 $(1,0)$ 和 $(0,1)$ 这两种情形；因为如果 $(1,0)=a$ 且 $(0,1)=b$，那么 $(x,y)=(ax+by)\bmod15$，这是由于同余式可以进行乘法和加法运算。

在我们的例子中查表可得 $a=10$，$b=6$；但当模数非常大时，我们该如何求出 $a$ 和 $b$ 呢？换句话说，若 $m\perp n$，有什么好方法可以求出满足以下方程的整数 $a$ 和 $b$：
```math
a\bmod m=1,\ a\bmod n=0,\quad b\bmod m=0,\ b\bmod n=1
```

全部成立？再次由式 $(4.5)$ 给出解法：利用欧几里得算法，我们可以求出 $m'$ 和 $n'$ 使得
```math
m'm + n'n = 1.
```

因此我们可以取 $a=n'n$ 与 $b=m'm$，如果需要的话可将它们都对 $mn$ 取模。

当模数很大时，还需要一些额外的技巧来尽可能减少计算量；相关细节超出了本书的讨论范围，但可以在文献[208, 第274页]中找到。从余数还原出对应的原数是可行的，但这个过程足够慢，因此只有当一系列运算都能在剩余数系统中完成、之后再进行还原时，我们才能节省总体耗时。

让我们通过解决一个小问题来巩固这些同余的概念：同余式
```math
x^2 \equiv 1 \pmod m,\tag{4.43}
```

如果我们将满足 $x\equiv x'$ 的两个解 $x$ 与 $x'$ 视为相同的解？

根据前面介绍的一般原理，我们首先考虑 $m$ 是素数幂 $p^k$ 的情形，其中 $k>0$。此时同余式 $x^2\equiv 1$ 可以写成
```math
(x-1)(x+1)\equiv 0\pmod{p^k}
```

所以 $p$ 必须整除 $x-1$ 或 $x+1$，或同时整除两者。但除非 $p=2$，否则 $p$ 不能同时整除 $x-1$ 和 $x+1$；我们将这种情况留到后面讨论。如果 $p>2$，那么 $p\mid(x-1)(x+1)$ 等价于 $p\mid(x-1)$ 或 $p\mid(x+1)$；因此恰好有两个解，即 $x\equiv 1$ 和 $x\equiv -1$。

$p=2$ 的情形略有不同。若 $2^k\mid(x-1)(x+1)$，则 $x-1$ 或 $x+1$ 可被 $2$ 整除但不能被 $4$ 整除，因此另一个必被 $2^{k-1}$ 整除。这意味着当 $k\ge 3$ 时有四个解，即 $x\equiv\pm 1$ 与 $x\equiv 2^{k-1}\pm 1$。（例如，当 $p=8$ 时四个解为 $x\equiv 1,3,5,7\pmod 8$；知道任意奇数的平方都形如 $8n+1$ 通常很有用。）

$x^2\equiv 1\pmod m$ 成立当且仅当对于 $m$ 的完全素因数分解中所有满足 $m_p>0$ 的素数 $p$，都有 $x^2\equiv 1\pmod{p^{m_p}}$。每个素数彼此独立，且除 $p=2$ 外，$x\bmod p^{m_p}$ 恰好有两种可能。因此若 $m$ 恰有 $r$ 个不同的素因子，则 $x^2\equiv 1$ 的解总数为 $2^r$，$m$ 为偶数时需修正。一般情况下的准确解数为
```math
2^{r+\left[8\mid m\right]+\left[4\mid m\right]-\left[2\mid m\right]}\quad \tag{4.44}
```

例如，模 $12$ 有四个“单位平方根”，即 $1,5,7,11$。当 $m=15$ 时，四个解是模 $3$ 与模 $5$ 均为 $\pm1$ 的数，即在剩余数系中为 $(1,1),(1,4),(2,1),(2,4)$，这些解在普通十进制数系中为 $1,4,11,14$。





