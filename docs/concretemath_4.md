# 4. Number Theory

整数在本书重点讲解的离散数学中处于核心地位。因此，我们要深入探讨数论—— 这是数学的一个重要分支，专门研究整数的各种性质。

在上一章里，我们已经浅尝了数论，引入了叫作 $mod$ 和 $gcd$ 的二元运算。现在让我们深入其中，真正沉浸在这一领域里。


## 4.1 DIVISIBILITY 可除性
我们说 $m$ 整除 $n$（或称 $n$ 可被 $m$ 整除），当且仅当 $m>0$ 且比值 $n/m$ 是整数。这一性质是整个数论的基础，因此很适合为它专门引入一种记号。我们于是记作：
```math
m\backslash n \iff m > 0\ and\ n = mk\ for\ some\ integer\ k. \tag{4.1}
```

（记号 $m|n$ 在当今数学文献中实际上比 $m\backslash n$ 更为常见。但是竖线 $|$ 已经被过度使用 —— 用于表示绝对值、集合分隔符、条件概率等等 ——而反斜杠 $\backslash$ 却很少被使用。此外，$m\backslash n$ 能让人直观地感觉到 $m$ 是某个隐含比值中的分母。因此，我们将大胆地让这个整除符号向左倾斜。）


如果 $m$ 不整除 $n$，我们记作 $m\nmid n$。


还有一个类似的关系，叫作“$n$ 是 $m$ 的倍数”，它的含义几乎与整除相同，只是$m$ 不必是正数。在这种情况下，我们的意思就是存在某个整数 $k$，使得 $n=mk$。举例来说，$0$ 只有一个倍数（就是 $0$ 本身），但没有数可以被 $0$ 整除。每个整数都是 $-1$ 的倍数，但严格来说，没有整数能被 $-1$ 整除。这些定义在 $m$ 和 $n$ 是任意实数时都成立；例如，$2\pi$ 可以被 $\pi$ 整除。但我们几乎只在 $m$ 和 $n$ 都是整数时使用它们。毕竟，这是数论。

两个整数 $m$ 和 $n$ 的最大公约数，是能够同时整除它们两者的最大整数：
```math
\gcd(m, n) = \max\{k| k\backslash m\ and\ k\backslash n\}. \tag{4.2}
```

例如，$\gcd(12,18)=6$。这是一个我们很熟悉的概念，因为四年级学生学习化简分数 $\frac{m}{n}$ 时，用到的就是这个公因子：$\frac{12}{18} = \frac{12/6}{18/6} = \frac{2}{3}$。注意，如果 $n>0$，我们有 $\gcd(0,n)=n$，因为任何正数都能整除 $0$，而且 $n$ 是它自身最大的因子。$\gcd(0,0)$ 是没有定义的。

另一个我们熟悉的概念是最小公倍数，
```math
\operatorname{lcm}(m, n) = \min\{k| k>0, m\backslash k\ and\ n\backslash k\}. \tag{4.3}
```

若 $m \le 0$ 或 $n \le 0$，则它没有定义。学习算术的学生会把它认作最小公分母，用于对分母为 $m$ 和 $n$ 的分数做加法。例如，$\operatorname{lcm}(12,18)=36$。并且四年级的学生都知道$\frac{7}{12} + \frac{1}{18}= \frac{21}{36} + \frac{2}{36}= \frac{23}{36}$。 $\operatorname{lcm}$ 与 $\gcd$ 在某种程度上是类似的，但我们不会对它同等重视，因为 $\gcd$ 拥有更良好的性质。

$\gcd$ 最优秀的性质之一是它很容易计算，使用一种有 2300 年历史的方法，称为欧几里得算法。对于给定的 $0 \le m < n$，为计算 $\gcd(m,n)$，欧几里得算法使用如下递推式：
```math
\begin{aligned}
\gcd(0, n) &= n; \\
\gcd(m, n) &= \gcd(n\mod m, m), for\ m>0. \tag{4.4}
\end{aligned}
```
因此，例如 $\gcd(12,18) = \gcd(6,12) = \gcd(0,6) = 6$。上述递推式是成立的，因为任何能同时整除 $m$ 和 $n$ 的公约数，也必定能同时整除 $m$ 和 $n \bmod m$（即 $n - \lfloor n/m \rfloor m$）。而对于 $\operatorname{lcm}(m,n)$，似乎不存在任何能与这个递推式相提并论的简单递推关系（见习题 2）。

欧几里得算法还能给我们更多信息：我们可以对其进行扩展，使其能计算出满足如下等式的整数 $m'$ 和 $n'$：
```math
m'm + n'n = gcd(m, n). \tag{4.5}
```

具体方法如下：若 $m=0$，我们只需取 $m'=0$ 且 $n'=1$。否则，令 $r = n \bmod m$，并将该方法递归地应用于 $r$ 和 $m$（替代原来的 $m$ 和 $n$），计算出满足如下等式的 $\bar{r}$ 和 $\bar{m}$：
```math
\bar{r}r + \bar{m}m = gcd(r, n).
```

因为 $r=n-\lfloor n/m \rfloor m$ 且 $\gcd(r,m)=\gcd(m,n)$，所以这个式子告诉我们:
```math
\bar{r}(n-\lfloor n/m \rfloor m) + \bar{m}m = gcd(m, n).
```

我们可以把左边重新整理，以显式表示它对 $m$ 和 $n$ 的依赖关系：
```math
(\bar{m}-\lfloor n/m \rfloor\bar{r}) + \bar{r}m = gcd(m, n);
```

因此 $m' = \bar{m} - \lfloor n/m \rfloor \bar{r}$ 且 $n' = \bar{r}$ 就是我们在式 (4.5) 中所需的整数。以我们最熟悉的例子来说，当 $m=12$，$n=18$ 时，该方法给出：$6 = 0 \cdot 0 + 1 \cdot 6 = 1 \cdot 6 + 0 \cdot 12 = (-1) \cdot 12 + 1 \cdot 18$。

但为何式 (4.5) 是如此精妙的结论呢？最主要的原因是，在某种意义上，数 $m'$ 和 $n'$ 实际上能证明欧几里得算法在任意具体情况下都给出了正确答案。假设我们的计算机经过冗长的计算后告诉我们 $\gcd(m,n)=d$，且 $m'm + n'n = d$；但我们对此存疑，认为存在一个更大的公约数，只是被机器以某种方式忽略了。然而这是不可能的，因为任何能整除 $m$ 和 $n$ 的公约数都必定能整除 $m'm + n'n$；因此它也必定能整除 $d$；所以它必定不大于 $d$。此外，我们可以轻松验证 $d$ 确实能同时整除 $m$ 和 $n$。（能输出自身正确性证明的算法被称为自验证算法。）

在本章的后续内容中，我们会频繁用到式 (4.5)。它的一个重要推论是下面这个小定理：
```math
k\backslash m\ \text{and}\ k\backslash n\ \iff \ k\backslash\gcd(m,n). \tag{4.6}
```

（证明：若 $k$ 同时整除 $m$ 和 $n$，则它整除 $m'm+n'n$，因此它整除 $\gcd(m,n)$。反之，若 $k$ 整除 $\gcd(m,n)$，则它整除 $m$ 的一个因子和 $n$ 的一个因子，因此它同时整除 $m$ 和 $n$。）我们一直都知道 $m$ 和 $n$ 的任何公约数必定不大于它们的最大公约数；这是最大公约数的定义。但现在我们知道，任何公约数实际上都是它们最大公约数的一个因子。

有些时候我们需要对 $n$ 的所有因子求和。这种情况下，使用下面这条简便的法则通常很有用：
```math
\sum_{m\backslash n} a_m = \sum_{m\backslash k} a_{n/m},\ integer\ n>0,  \tag{4.7}
```

该式成立的原因是，当 $m$ 取遍 $n$ 的所有因子时，$n/m$ 也恰好取遍 $n$ 的所有因子。例如，当 $n=12$ 时，该法则表明$a_1+a_2+a_3+a_4+a_6+a_{12}=a_{12}+a_6+a_4+a_3+a_2+a_1$。

还有一个稍微更一般的恒等式，
```math
\sum_{m\backslash n} a_m = \sum_k\sum_{m>0} a_m[n=mk],  \tag{4.8}
```

这是定义 (4.1) 的一个直接推论。若 $n$ 为正数，(4.8) 式右边即为 $\sum_{k\mid n} a_{n/k}$，因此 (4.8) 蕴含 (4.7)。并且当 $n$ 为负数时，方程 (4.8) 依然成立。（此时，右边的非零项出现在 $k$ 是 $n$ 的某个因子的相反数时。）

此外，对因子的二重求和可以按照下面的法则交换次序：
```math
\sum_{m\backslash n}\sum_{k\backslash m} a_{k,m} = \sum_{k\backslash n}\sum_{l\backslash (n/k)} a_{k,kl}.  \tag{4.9}
```

例如，当 $n=12$ 时，这条法则具有如下形式：
```math
\begin{aligned}
a_{1,1}+ &(a_{1,2}+a_{2,2})+(a_{1,3}+a_{3,3}) \\
&\qquad+(a_{1,4}+a_{2,4}+a_{4,4})+(a_{1,6}+a_{2,6}+a_{3,6}+a_{6,6}) \\
&\qquad+(a_{1,12}+a_{2,12}+a_{3,12}+a_{4,12}+a_{6,12}+a_{12,12})\\
&=(a_{1,1}+a_{1,2}+a_{1,3}+a_{1,4}+a_{1,6}+a_{1,12}) \\
&\qquad+(a_{2,2}+a_{2,4}+a_{2,6}+a_{2,12})+(a_{3,3}+a_{3,6}+a_{3,12}) \\
&\qquad+(a_{4,4}+a_{4,12})+(a_{6,6}+a_{6,12})+a_{12,12}.
\end{aligned}
```

我们可以用艾弗森约定的运算来证明式 (4.9)。左边是
```math
\sum_{j,l}\sum_{k,m>0} a_{k,m}[m=jm][m=kl] = \sum_j\sum_{k,l>0} a_{k,kl}[n=jkl];
```

右边是
```math
\sum_{j,m}\sum_{k,l>0} a_{k,kl}[n=jk][n/k=ml] = \sum_m\sum_{k,l>0} a_{k,kl}[n=mlk],
```

仅需对下标重命名，二者便是相同的。这个例子表明，我们在第 2 章学到的技巧在研究数论时将会很有用。


## 4.2 PRIMES 质数
若一个正整数 $p$ 恰好有两个因子，即 $1$ 和 $p$，则称其为素数。在本章余下的内容中，字母 $p$ 始终表示素数，即使我们没有明确说明。按照约定，$1$ 不是素数，因此素数序列开头是这样的：
```math
2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\cdots
```

有些数看似素数实则不是，例如 $91$ ($=7\cdot13$) 和 $161$ ($=7\cdot23$)。这些数以及其他拥有三个或更多因子的数被称为合数。每个大于 $1$ 的整数要么是素数，要么是合数，二者必居其一。

素数非常重要，因为它们是所有正整数的基本构成单元。任何正整数 $n$ 都可以写成素数的乘积，
```math
n = p_1\cdots p_m = \prod_{k=1}^m p_k,\quad p_1\le\cdots\le p_m. \tag{4.10}
```

例如，$12=2\cdot2\cdot3$；$11011=7\cdot11\cdot11\cdot13$；$11111=41\cdot271$。（用 $\prod$ 表示乘积与用 $\sum$ 表示和类似，如习题 2.25 中所说明的。如果 $m=0$，我们将其视为空乘积，根据定义其值为 $1$；这就是 $n=1$ 在式 $(4.10)$ 中的表示方式。）这样的分解总是可行的，因为如果 $n>1$ 不是素数，它就有一个因子 $n_1$ 满足 $1<n_1<n$；于是我们可以写成 $n=n_1\cdot n_2$，并且（由归纳法）我们知道 $n_1$ 和 $n_2$ 都可以表示为素数的乘积。

而且，式 $(4.10)$ 中的展开式是唯一的：将 $n$ 写成不降序素数乘积的方式只有一种。这个结论被称为**算术基本定理**，它看起来如此显然，以至于我们可能会疑惑为什么还需要证明。怎么可能存在两组不同的素数，它们的乘积却相同呢？事实上不可能，但原因并非简单地“由素数的定义可得”。例如，如果我们考虑所有形如 $m+n\sqrt{10}$（其中 $m,n$ 为整数）的实数集合，任意两个这样的数相乘仍然是该形式，并且我们可以把不能非平凡分解的数称为“素数”。数 $6$ 就有两种表示：$2\cdot3=(4+\sqrt{10})(4-\sqrt{10})$；而习题 36 表明，$2,3,4+\sqrt{10}$ 和 $4-\sqrt{10}$ 在这个系统中都是“素数”。

因此我们需要严格证明式 $(4.10)$ 的唯一性。当 $n=1$ 时显然只有一种可能，因为此时乘积必须是空乘积；于是假设 $n>1$，且所有更小的数都具有唯一分解。假设我们有两种分解式
```math
n = p_1\cdots p_m = q_1\cdots p_k,\quad p_1\le\cdots\le p_m\ and\ q_1\le\cdots\le q_k,
```

其中 $p_i$ 和 $q_j$ 都是素数。我们来证明 $p_1=q_1$。如果不相等，不妨设 $p_1<q_1$，使得 $p_1$ 小于所有的 $q_j$。因为 $p_1$ 和 $q_1$ 都是素数，它们的最大公约数必为 $1$；于是由欧几里得自验证算法可知，存在整数 $a$ 和 $b$ 使得 $a p_1 + b q_1 = 1$。因此
```math
ap_1q_2\cdots q_k + bq_1q_2\cdots q_k = q_2\cdots q_k.
```

现在 $p_1$ 整除左边两项，因为 $q_1 q_2 \dots q_k = n$；于是 $p_1$ 整除右边 $q_2 \dots q_k$。因此 $q_2 \dots q_k / p_1$ 是整数，且 $q_2 \dots q_k$ 有一个含 $p_1$ 的素因子分解。但 $q_2 \dots q_k < n$，由归纳假设它有唯一分解。这个矛盾表明 $p_1$ 必定等于 $q_1$。于是我们可以把 $n$ 的两个分解式都除以 $p_1$，得到 $p_2 \dots p_m = q_2 \dots q_k < n$。其余因子同样（由归纳假设）必须相等，于是唯一性的证明就完成了。

算术基本定理往往用另一种形式表述更有用：每个正整数都能被唯一地表示成
```math
n = \prod_p p^{n_p},\ n_p \ge 0. \tag{4.11}
```

右边是对无穷多个素数的乘积；但对任意给定的 $n$，除少数几个指数外其余都是 $0$，因此对应的因子都是 $1$。所以它实际上是有限乘积，就像许多“无穷”和实际上是有限的一样，因为它们的项大部分都是 $0$。

公式 $(4.11)$ 唯一表示了 $n$，因此我们可以把序列 $\langle n_2,n_3,n_5,\dots\rangle$ 看成正整数的一种数系。例如，$12$ 的素因子指数表示是 $\langle 2,1,0,0,\dots\rangle$，$18$ 的素因子指数表示是 $\langle 1,2,0,0,\dots\rangle$。两个数相乘，只需把它们的指数表示相加。换句话说，
```math
k = mn \iff k_p = m_p + n_p,\ \forall p. \tag{4.12}
```

这就意味着
```math
m\backslash n \iff m_p \le n_p,\ \forall p. \tag{4.13}
```

由此立即推出
```math
k = \gcd(m,n) \iff k_p = \min(m_p, n_p),\ \forall p \tag{4.14} 
```
```math
k = \operatorname{lcm}(m,n) \iff k_p = \max(m_p, n_p),\ \forall p \tag{4.15}
```

例如，因为 $12=2^2\cdot3^1$ 且 $18=2^1\cdot3^2$，我们可以通过取公共指数的最小值和最大值来得到它们的 $\gcd$ 和 $\operatorname{lcm}$：
```math
\gcd(12,18) = 2^{\min(2,1)} \cdot 3^{\min(1,2)} = 2^1 \cdot 3^1 = 6 \\
\operatorname{lcm}(12,18) = 2^{\max(2,1)} \cdot 3^{\max(1,2)} = 2^2 \cdot 3^2 = 36
```

如果素数 $p$ 整除乘积 $mn$，那么它一定整除 $m$ 或 $n$（可能两者都整除），这是唯一分解定理的推论。但合数没有这个性质。例如，非素数 $4$ 整除 $60=6\cdot10$，但它既不整除 $6$ 也不整除 $10$。原因很简单：在分解 $60=6\cdot10=(2\cdot3)(2\cdot5)$ 中，$4=2\cdot2$ 的两个素因子被分到了两部分里，因此 $4$ 不整除其中任何一部分。而素数是不可再分的，所以它必须整除原来的其中一个因子。

## 4.3 PRIME EXAMPLES
素数有多少个？有很多。事实上，有无穷多个。欧几里得早在他的《几何原本》命题9:20中就证明了这一点，证明如下。假设素数只有有限个，设为 $k$ 个——$2,3,5,\dots,P_k$。那么，欧几里得说，我们可以考虑这样一个数：
```math
M=2\cdot 3\cdot 5\cdot \dots P_k+1
```

这 $k$ 个素数都不能整除 $M$，因为它们都能整除 $M-1$。因此一定存在某个其他素数整除 $M$；或许 $M$ 本身就是素数。这与我们假设 $2,3,\dots,P_k$ 是全部素数矛盾，所以素数一定有无穷多个。

欧几里得的证明启发我们通过递推式定义欧几里得数
```math
e_n = e_1 e_2 \dots e_{n-1} + 1,\ when\ n\ge 1. \tag{4.16}
```

该数列的前几项为
```math
\begin{aligned}
e_1 &= 1 + 1 = 2; \\
e_2 &= 2 + 1 = 3; \\
e_3 &= 2\cdot3 + 1 = 7; \\
e_4 &= 2\cdot3\cdot7 + 1 = 43;
\end{aligned}
```

这些数都是素数。但下一项 $e_5 = 1807 = 13\cdot139$ 是合数。结果表明 $e_6 = 3263443$ 是素数，而
```math
\begin{aligned}
e_7 &= 547\cdot607\cdot1033\cdot31051; \\
e_8 &= 29881\cdot67003\cdot9119521\cdot6212157481
\end{aligned}
```

已知 $e_9,\dots,e_{17}$ 都是合数，剩下的 $e_n$ 也很可能都是合数。不过欧几里得数两两互质，即
```math
\gcd(e_m,e_n)=1,\ when\ m \neq n
```

欧几里得算法（还能有别的吗？）用三步就能简单证明这一点，因为当 $n > m$ 时，$e_n \bmod e_m = 1$：
```math
\gcd(e_m,e_n) = \gcd(1,e_m) = \gcd(0,1) = 1
```

因此，如果令 $q_j$ 为 $e_j$ 的最小素因子，对所有 $j \ge 1$，那么素数 $q_1,q_2,q_3,\dots$ 互不相同。这就构成了一个无穷素数序列。

我们暂且从第1章的角度来考虑欧几里得数。能否把 $e_n$ 写成闭形式？递推式 $(4.16)$ 可以去掉省略号进行简化：若 $n > 1$，则有
```math
e_n = e_1\cdots e_{n-2}e_{n-1}+1 = (e_{n-1}-1)e_{n-1}+1 = e_{n-1}^2 - e_{n-1} + 1
```

因此 $e_n$ 的十进制位数大约是 $e_{n-1}$ 的两倍。习题37证明存在常数 $E \approx 1.264$ 使得
```math
e_n = \lfloor E^{2^n} + \frac{1}{2} \rfloor. \tag{4.17}
```

并且习题60给出了一个类似的、只生成素数的公式：
```math
p_n = \lfloor P^{3^n} \rfloor. \tag{4.18}
```

对于某个常数 $P$。但像 $(4.17)$ 和 $(4.18)$ 这样的式子并不能真正被看作闭形式，因为常数 $E$ 和 $P$ 是以一种不太直观的方式从 $e_n$ 和 $p_n$ 算出来的。目前并不存在（也不太可能存在）能把它们与其他有数学意义的常数联系起来的独立关系式。

事实上，没人知道任何既能生成任意大素数、又只生成素数的实用公式。不过在 1984 年，雪佛龙地球科学公司的计算机科学家们有了重大数学发现。他们使用由戴维·斯洛温斯基开发的程序，找到了当时已知的最大素数
```math
2^{216091}-1,
```

当时他们正在测试一台全新的 Cray X‑MP 超级计算机。如今在个人电脑上只需几毫秒就能算出这个数，因为现代计算机采用二进制，而这个数就是 $(11\dots1)_2$，它的全部 $216091$ 个比特都是 $1$。但要证明它是素数则困难得多。事实上，几乎任何涉及它的计算都非常耗时，因为它实在太大。例如，即便使用高效算法，在个人电脑上把 $2^{216091}-1$ 转换成十进制也要好几分钟。如果打印出来，它的 $65050$ 位十进制数字按美国一类邮件寄送需要 $75$ 美分邮资。

顺便一提，$2^{216091}-1$ 正是有 $216091$ 个圆盘时，求解汉诺塔问题所需的最少步数。形如
```math
2^p-1,
```

$2^p-1$（其中 $p$ 为素数，本章均如此）的数被称为**梅森数**，以17世纪研究过它们性质的马林·梅森神父命名$[269]$。迄今为止已知的梅森素数对应的 $p$ 为：$2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279,2203,2281,3217,4253,4423,9689,9941,11213,19937,21701,23209,44497,86243,110503,132049,216091$ 以及 $756839$。

若 $n$ 是合数，则 $2^n-1$ 不可能为素数，因为 $2^{km}-1$ 以 $2^m-1$ 为因子：
```math
2^{km}-1 = (2^m-1)(2^{m(k-1)} + 2^{m(k-2)} + \dots + 1).
```

但当 $p$ 为素数时，$2^p-1$ 并不总是素数；最小的反例是 $2^{11}-1=2047=23\cdot89$。（梅森本人就知道这一点。）

大数的因式分解与素性测试是如今的热门课题。截至1981年的已知成果汇总于文献[208]的4.5.4节，且新的研究成果仍在不断涌现。该书的391-394页介绍了一种测试梅森数素性的专用方法。

在过去两百年的大部分时间里，已知的最大素数均为梅森素数——尽管目前仅发现了31个梅森素数。许多人都在尝试寻找更大的梅森素数，但这件事的难度正不断增加。因此，那些真正渴望成名（哪怕不求财富）、希望登上《吉尼斯世界纪录大全》的人，或许可以转而研究形如 $2^n k + 1$ 的数（取 $k=3$ 或 $5$ 这类小值）。这类数的素性测试速度几乎与梅森数一样快；文献[208]中4.5.4节的习题27给出了具体方法。

我们尚未完全回答最初那个“素数有多少个”的问题。素数有无穷多个，但某些无穷集比另一些“更稠密”。例如，正整数中有无穷多个偶数，也有无穷多个完全平方数；然而从若干重要意义上讲，偶数比完全平方数更多。一种衡量方式是看第 $n$ 项的大小：第 $n$ 个偶数是 $2n$，第 $n$ 个完全平方数是 $n^2$；当 $n$ 很大时，$2n$ 远小于 $n^2$，第 $n$ 个偶数出现得远早于第 $n$ 个完全平方数，因此可以说偶数比完全平方数多得多。类似地，也可以看不超过 $x$ 的数的个数：不超过 $x$ 的偶数有 $\lfloor x/2 \rfloor$ 个，完全平方数有 $\lfloor \sqrt{x} \rfloor$ 个；当 $x$ 很大时，$x/2$ 远大于 $\sqrt{x}$，同样可以说偶数多得多。

从这两种意义上，我们能对素数说些什么呢？结论是：第 $n$ 个素数 $p_n$ 大约等于 $n$ 乘以 $n$ 的自然对数：
```math
p_n \sim n\ln n
```
（符号 $\sim$ 可读作“渐近等于”，它表示当 $n\to\infty$ 时，比值 $p_n/(n\ln n)$ 的极限为 $1$。）类似地，对于不超过 $x$ 的素数个数 $\pi(x)$，我们有所谓的**素数定理**：
```math
\pi(x)\sim\frac{x}{\ln x}.
```

证明这两个结论超出了本书的范围，尽管我们可以轻松证明它们彼此等价。在第9章中，我们将讨论函数趋于无穷的速度，并会看到用来近似 $p_n$ 的函数 $n\ln n$，在渐近意义下介于 $2n$ 和 $n^2$ 之间。因此，素数比偶数少，但比完全平方数多。

这些公式只在 $n$ 或 $x\to\infty$ 的极限情况下成立，我们可以用更精确的估计式来代替它们。例如，Rosser 和 Schoenfeld [312] 给出了好用的上下界：
```math
\ln x - \frac{3}{2} < \frac{x}{\pi(x)} < \ln x - \frac{1}{2},\quad \text{for } x\ge 67; \tag{4.19}
```
```math
n\!\left(\ln n+\ln\ln n-\dfrac32\right) < p_n < n\!\left(\ln n+\ln\ln n-\dfrac12\right),\quad \text{for } n\ge 20. \tag{4.20}
```

如果观察一个“随机”整数 $n$，它是素数的概率大约是 $\dfrac{1}{\ln n}$。例如，在 $10^{16}$ 附近的数中，我们大约需要检查 $\ln 10^{16}\approx 36.8$ 个数才能找到一个素数。（事实上，在 $10^{16}-370$ 到 $10^{16}-1$ 之间恰好有 $10$ 个素数。）然而素数的分布存在许多不规则性。比如，$p_1p_2\cdots p_n+2$ 到 $p_1p_2\cdots p_n+p_{n+1}-1$ 之间的所有整数都是合数。目前已知很多“孪生素数”对 $p$ 和 $p+2$（如 $5$ 和 $7$，$11$ 和 $13$，$17$ 和 $19$，$29$ 和 $31$，……，$9999999999999641$ 和 $9999999999999643$，……），但没人知道是否存在无穷多组孪生素数。（参见 Hardy 和 Wright [181, §1.4 和 §2.8]。）

计算所有不超过 $x$ 的素数（共 $\pi(x)$ 个）的一个简单方法是构造所谓的**埃拉托斯特尼筛法**：先写下从 $2$ 到 $x$ 的所有整数。接着圈出 $2$，标记为素数，并划掉 $2$ 的其余所有倍数。然后不断圈出最小的、既未圈出也未划掉的数，并划掉它的其余倍数。当所有数都被圈出或划掉后，圈出的数就是素数。例如当 $x=10$ 时，我们写下 $2$ 到 $10$，圈出 $2$，然后划掉它的倍数 $4,6,8,10$。接下来 $3$ 是最小的未圈未划数，于是圈出 $3$ 并划掉 $6,9$。现在 $5$ 最小，圈出 $5$ 并划掉 $10$。最后圈出 $7$。圈出的数是 $2,3,5,7$；因此不超过 $10$ 的素数共有 $\pi(10)=4$ 个。

## 4.4 FACTORIAL FACTORS 阶乘因子

现在我们来看一些有趣的**高合数**——阶乘的素因数分解：
```math
n! = 1\cdot 2\cdot\,\dots\,\cdot n = \prod\limits_{k=1}^{n} k,\quad \text{整数 } n\ge 0. \tag{4.21}
```

根据空乘积的约定，我们定义 $0! = 1$。于是对每个正整数 $n$，都有 $n! = (n-1)!\,n$。它是 $n$ 个不同对象的**排列数**，也就是把 $n$ 个物体排成一行的方法总数：第一个位置有 $n$ 种选择；对第一个的每种选择，第二个位置有 $n-1$ 种选择；对这 $n(n-1)$ 种选择中的每一种，第三个位置又有 $n-2$ 种选择；依此类推，总共有 $n(n-1)(n-2)\cdots 1$ 种排列。下面是阶乘函数的前几项值。

n | 1 | 2| 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10
| --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: |
n! |1 | 2 | 6 | 24 | 120 | 720 | 5040 | 40320 | 362880 | 3628800

记住一些阶乘的结论很有用，比如前六个左右的值，以及 $10!$ 大约是三百多万；另一个有趣的结论是：当 $n\ge25$ 时，$n!$ 的位数会超过 $n$。

我们可以用第 1 章里类似高斯的技巧来证明 $n!$ 是相当大的：
```math
n! = (1\cdot 2\cdots n)(n\cdots 2\cdot 1) = \prod\limits_{k=1}^{n} k(n+1-k).
```

我们有 $n \le k(n+1-k) \le \dfrac14(n+1)^2$，因为二次多项式 $k(n+1-k) = \dfrac14(n+1)^2 - \bigl(k-\dfrac12(n+1)\bigr)^2$ 在 $k=1$ 处取最小值，在 $k=\dfrac12(n+1)$ 处取最大值。因此
```math
\prod_{k=1}^{n} n \le n!^2 \le \prod_{k=1}^{n} \dfrac{(n+1)^2}{4};
```

也就是说，
```math
n^{n/2} \le n! \le \dfrac{(n+1)^n}{2^n} \tag{4.22}
```
这个式子告诉我们，阶乘函数是**指数增长**的！！

为了在 $n$ 很大时更精确地近似 $n!$，我们可以使用**斯特林公式**，这将在第 9 章推导：
```math
n! \sim \sqrt{2\pi n}\left(\dfrac{n}{e}\right)^n \tag{4.23}
```

而更精确的近似式可以给出渐近相对误差：斯特林公式对 $n!$ 的低估程度大约是 $1/(12n)$ 倍。即使对较小的 $n$，这个更精确的估计也相当不错。例如，当 $n=10$ 时，斯特林近似式 (4.23) 给出的值接近 $3598696$，比真实值小约 $0.83\% \approx 1/120$。渐近分析，真香。

但我们回到素数上来。我们希望对任意给定的素数 $p$，求出整除 $n!$ 的 $p$ 的最高次幂，也就是 $n!$ 唯一素因数分解中 $p$ 的指数。我们把这个数记为 $e_p(n!)$，并从 $p=2$、$n=10$ 的小例子开始研究。因为 $10!$ 是十个数的乘积，$e_2(10!)$ 可以通过把这十个数各自含有的 $2$ 的幂次相加得到；这个计算对应于把下面数组的列相加：
| | 1 | 2| 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | powers of 2
| --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: |
divisible by 2 |  | x |  | x |  | x |  | x |  | x | $5 = \lfloor 10/2\rfloor$
divisible by 4 |  |  |  | x |  |  |  | x |  |  | $2 = \lfloor 10/4\rfloor$
divisible by 8 |  |  |  |  |  |  |  | x |  |  | $1 = \lfloor 10/8\rfloor$
powers of 2 | 0 | 1 | 0 | 2 | 0 | 1 | 0 | 3 | 0 | 1 | 8

（这些列的和构成了有时被称为**尺规函数** $\rho(k)$ 的序列，因为它们和英寸刻度的长短线条很像。）这十列的和加起来是 $8$，因此 $2^8$ 整除 $10!$，但 $2^9$ 不整除。

还有另一种方法：我们可以按行求和。第一行标记贡献一个 2 的幂的数（即可被 2 整除），共有 $\lfloor 10/2 \rfloor=5$ 个。第二行标记再贡献一个 2 的幂的数，共有 $\lfloor 10/4 \rfloor=2$ 个。第三行标记再贡献一个的数，共有 $\lfloor 10/8 \rfloor=1$ 个。这些就覆盖了所有贡献，所以 $e_2(10!)=5+2+1=8$。

对于一般的 $n$，这个方法给出
```math
\epsilon_2(n!) = \left\lfloor\frac{n}{2}\right\rfloor + \left\lfloor\frac{n}{4}\right\rfloor + \left\lfloor\frac{n}{8}\right\rfloor + \cdots = \sum_{k\ge 1}\left\lfloor\frac{n}{2^k}\right\rfloor
```

这个和实际上是有限的，因为当 $2^k > n$ 时项为 0。所以它只有 $\lfloor\lg n\rfloor$ 个非零项，计算起来非常方便。例如当 $n=100$ 时，我们有
```math
\epsilon_2(100!)=50+25+12+6+3+1=97.
```

每一项都是前一项向下取半。这对所有 $n$ 都成立，因为作为式 $(3.11)$ 的特例，我们有 $\left\lfloor n/2^{k+1} \right\rfloor = \left\lfloor \left\lfloor n/2^k \right\rfloor / 2 \right\rfloor$。把数写成二进制时尤其容易看清这一点：
```math
\begin{align*}
100 &= (1100100)_2 &= 100 \\
\left\lfloor 100/2 \right\rfloor &= (110010)_2 &= 50 \\
\left\lfloor 100/4 \right\rfloor &= (11001)_2 &= 25 \\
\left\lfloor 100/8 \right\rfloor &= (1100)_2 &= 12 \\
\left\lfloor 100/16 \right\rfloor &= (110)_2 &= 6 \\
\left\lfloor 100/32 \right\rfloor &= (11)_2&= 3 \\
\left\lfloor 100/64 \right\rfloor &= (1)_2 &= 1 \\
\end{align*}
```
我们只需要把前一项的最低有效位去掉，就能得到下一项。

二进制表示还能帮我们推出另一个公式：
```math
\epsilon_2(m!) = m - v_2(m), \tag{4.24}
```
其中 $v_2(n)$ 是 $n$ 的二进制表示中 $1$ 的个数。这个简化式成立，是因为每个对 $n$ 的值贡献 $2^m$ 的 $1$，都会对 $\epsilon_2(n!)$ 的值贡献 $2^{m-1}+2^{m-2}+\dots+2^0=2^m-1$。

将结论推广到任意素数 $p$，我们有
```math
\epsilon_p(n!) = \left\lfloor\frac{n}{p}\right\rfloor + \left\lfloor\frac{n}{p^2}\right\rfloor + \left\lfloor\frac{n}{p^3}\right\rfloor + \cdots = \sum_{k\ge 1}\left\lfloor\frac{n}{p^k}\right\rfloor\tag{4.25}
```
由同样的推理可得。

$\epsilon_p(n!)$ 大约有多大？我们只需去掉求和项中的下取整符号，然后对无穷等比数列求和，就能得到一个简单（但很好）的上界：
```math
\begin{align*}
\epsilon_p(n!) &< \frac{n}{p} + \frac{n}{p^2} + \frac{n}{p^3} + \cdots \\
&= \frac{n}{p}\left(1 + \frac{1}{p} + \frac{1}{p^2} + \cdots\right) \\
&= \frac{n}{p} \left(\frac{p}{p-1}\right) \\
&= \frac{n}{p-1}
\end{align*}
```

当 $p=2$ 且 $n=100$ 时，这个不等式给出 $97 < 100$。可见上界 $100$ 不仅正确，而且与真实值 $97$ 非常接近。事实上，真实值 $n-v_2(n)$ 一般近似于 $n$，因为 $v_2(n)\le\lfloor\lg n\rfloor$ 相对于 $n$ 来说渐近地小得多。

当 $p=2$ 和 $p=3$ 时，我们的公式给出 $\epsilon_2(n!)\sim n$ 与 $\epsilon_3(n!)\sim n/2$，因此偶尔出现 $\epsilon_3(n!)$ 恰好等于 $\epsilon_2(n!)$ 的一半，看起来是合理的。例如，当 $n=6$ 和 $n=7$ 时就会发生这种情况，因为 $6!=2^4\cdot3^2\cdot5=7!/7$。但至今还没有人证明这样的巧合会无限次出现。

对 $\epsilon_p(n!)$ 的界反过来又给出了 $p^{\epsilon_p(n!)}$ 的界，这是 $p$ 在 $n!$ 中的贡献：
```math
p^{\epsilon_p(n!)} < p^{n/(p-1)}
```

我们可以对这个公式做进一步简化（哪怕会让上界变得更松），注意到 $p\le 2^{p-1}$；因此 $p^{n/(p-1)}\le (2^{p-1})^{n/(p-1)}=2^n$。换句话说，任意素数对 $n!$ 的贡献都小于 $2^n$。

我们可以用这个结论给出**素数有无穷多个**的另一种证明。因为如果只有 $k$ 个素数 $2,3,\dots,P_k$，那么对所有 $n>1$ 都会有 $n!<(2^n)^k=2^{kn}$，因为每个素数最多贡献 $2^n$ 的因子。但只要取足够大的 $n$，比如 $n=2^{2k}$，就能轻松推翻 $n!<2^{kn}$ 这个不等式。
```math
n! < 2^{nk} = 2^{2^{2k}k} = n^{n/2},
```

这就与我们在 $(4.22)$ 中得到的不等式 $n!\ge n^{n/2}$ 相矛盾。于是素数依然有无穷多个。

我们还可以把这个论证加强，得到关于 $\pi(n)$（不超过 $n$ 的素数个数）的一个粗略上界。每个这样的素数对 $n!$ 贡献的因子都小于 $2^n$，因此和之前一样，
```math
n! < 2^{n\pi(n)}
```

如果把这里的 $n!$ 换成斯特林近似式 $(4.23)$ 给出的下界，再取对数，就得到
```math
n\pi(n) > n\lg(n/e) + \frac12\lg(2\pi n)
```

因此
```math
\pi(n) > \lg(n/e)
```

与真实值 $\pi(n)\sim n/\ln n$ 相比，这个下界相当弱，因为当 $n$ 很大时，$\lg n$ 远小于 $n/\lg n$。但我们没费多大力气就得到了它，而且一个界终究是个界。


## 4.5 RELATIVE PRIMALITY 相对素性




