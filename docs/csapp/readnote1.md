[toc]

# 信息的表示和处理

## 整数的表示

### 无符号数的编码

### 补码的编码 two's-complement

- 有符号数的其他表示方法：
  - 反码 One's Complement
  - 原码 Sign-Magnitude

> 虽然过去生产过基于反码表示的机器，但是几乎所有现代机器都使用补码


### 有符号数和无符号数之间的转换
- 对大多数 C 语言而言，处理同样字长的有符号数和无符号数之间的相互转换的一般规则是，数值可能会改变，但是位模式不变。
- 当执行一个运算时，如果一个数是有符号的，而另一个数是无符号的，那么 C 语言会隐式的将有符号参数强制转换为无符号数，并假设这两个数都是非负的，来执行这个运算。
- C 头文件 limits.h 对 TMIN TMAX 的写法：
```c
# define INT_MAX 2147483647
# define INT_MIN (-2147483647-1)
```
补码表示的不对称性和 C 语言转换规则之间这种奇怪的交互，迫使我们用这样的不寻常的方式来写 TMIN。


### 扩展即一个数字的位表示

一种常见的运算是不同字长的整数之间的转换，同时又保持数值不变。

- 零扩展 zero extension，需要简单的在表示的开头添加 0 
- 符号扩展，sign extension，规则是在表示中添加最高有效位的一个副本


### 截断数字

假设不用额外的位来扩展一个数值，而是减少一个数字的位数。

对于一个无符号数字 x，截断它的 k 位的结果就相当于计算 $x\mod 2^k$，即丢弃掉高 w-k 位。($2^{k+} \mod 2^k = 0 $)
对于一个有符号数 x，截断它的 k 位的结果相当于先进行无符号数字的截断，在将无符号数转换为有符号数。位模式不变，数值改变。

```c
int x = 53191;
short sx = (short) x; /* -12345 */
int y = sx;           /* -12345 */
```

### 关于有符号数与无符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且很难被发现。


## 整数运算

### 无符号加法

现在定义参数 x 和 y 的运算 $+_w^u$，这里 $0\leq x, y\leq 2^w$，如下：
```math
x +_w^u y = 
\begin{cases}
x+y,      x + y \leq 2^w \\\\
x+y-2^w,  2^w\leq x+y\leq 2^{w+1}
\end{cases}
```

一个算术运算溢出，是指完整的整数结果不能放到数据类型的字长限制中去。所以当两个运算数的和为 $2^w$ 或者更大时，就发生了溢出。

当执行 C 程序时，不会将溢出作为错误而发出信号。不过有时候，可能希望判定是否发生了溢出。


### 补码加法

两个数的 w 位补码之和与无符号之和有完全相同的位级表示。实际上，大多数计算机使用同样的机器指令来执行无符号或者有符号加法。

范围在 $-2{w-1} \leq x, y \leq 2^{w-1}-1$ 之内的 x 和 y 实施运算 $+_w^t$ 时，有下面这样的表达式：
```math
x +_w^t y = 
\begin{cases}
x+y-2^w,      2^{w-1} \leq x + y 正溢出  \\\\
x+y,          -2{w-1} \leq x + y \leq 2^{w-1}-1 正常 \\\\
x + y + 2^w,  x + y \leq - 2^{w-1} 负溢出
\end{cases}
```
当 x 和 y 都是负数，但是 x $+_w^t$ y > 0 时，就会得到负溢出
当 x 和 y 都是正数，但是 x $+_w^t$ y < 0 时，就会得到正溢出


### 补码的非

定义在 $-2{w-1} \leq x, y < 2^{w-1}$ 之内的 x，补码的非运算（negation operation）$-_w^t$ 如下：
```math
-_w^t x = 
\begin{cases}
-2^{w-1},     x = -2^{w-1} \\\\
-x,           x > -2^{w-1}
\end{cases}
```
-x = $2{w-1}$ 不能表示成一个 w 位的数。因此声明，这个特殊数本身就是它在 $-_w^t$ 下的加法逆元。

求位级补码非
- 第一种方法是对每一位求补，再对结果加 1。在 C 语言中，可以确定对于任意整数值 x，计算表达式 -x 和 $\sim x + 1$ 得到的结果完全一样。
- 第二种方法是建立在将位向量分为两部分的基础之上的，假设 k 是最右边的 1 位置，因而 x 的位级表示形如 $[x_{w-1},x_{w-2},\cdots,x_{k+1},1,0,\cdots,0]$。这个值的非写成二进制格式就是 $[\sim x_{w-1},\sim x_{w-2},\cdots,\sim x_{k+1},1,0,\cdots,0]$。也就是对位置 k 左边的所有位取反。


### 无符号数乘法

C 语言中的无符号乘法被定义为产生 w 位的值，就是 2w 位的整数乘积的低 w 位表示的值。可以看作等价于计算乘积模 $2^w$

```math
x *_w^u y = (x\cdot y) \mod 2^w
```

### 补码乘法

对于无符号和补码乘法来说，乘法运算的位级表示都是一样的。设 $x=B2T_w(\overrightarrow x)$ 和 $y=B2T_w(\overrightarrow y)$是这些位模式表示的补码值，而 $x'=B2U_w(\overrightarrow x)$ 和 $y'=B2U_w(\overrightarrow y)$ 是这些位模式表示的无符号值。根据等式 2-5 有 $x'=x+x_{w-1}2^w$ 和 $y'=y+y_{w-1}2^w$ 。计算这些值的乘积模 $2^w$ 得到以下结果：
```math
(x'\cdot y') = [(x+x_{w-1}2^w)\cdot (y+y_{w-1}2^w)] \mod 2^w \\\\
= [x\cdot y + (x_{w-1}y+y_{w-1}x)2^w + x_{w-1}y_{w-1}2^{2w}] \mod 2^w \\\\
= (x\cdot y) \mod 2^w
```

### 乘以常数

大多数机器上，整数乘法指令相当慢，需要 10 个或更多的时钟周期，然而其他的整数运算（例如加法、减法、位即运算和移位）只需要一个时钟周期。

因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。


### 除以2的幂

大多数机器上，整数除法要比整数乘法更慢，需要 30 个或更多的时钟周期。除以 2 的幂也可以用移位操作来实现。只不过使用右移。

对一个无符号数的逻辑右移和除以 $2^k$ 有一样的效果。证明(后续补充)


### 关于整数运算的思考

计算机执行的“整数”运算时间上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。

补码表示提供了一种即能表示负数也能表示整数的灵活方法，同时使用了与执行无符号算术相同的位级实现。

C 语言中的某些规定可能会产生令人意想不到的结果，而这些可能是难以察觉和理解的缺陷的源头。


## 浮点数

浮点表示对形如 $V=x \times 2^y$ 的有理数进行编码。它对执行涉及非常大的数字(|V|>>0)、非常接近与 0(|V|<<1)的数字，以及更普遍的作为实数运算的近似值的计算。

IEEE Standard 754，是浮点数及其运算的标准。这个提高了科学应用程序在不同计算机上的可移植性。


### 二进制小数

一个形如 $b_mb_{m-1}\cdots b_1b_0.b_{-1}b_{-2}\cdots b_{-n+1}b_{-n}$ 的表示法，其中每个二进制数字，或者称为位，$b_i$ 的取值范围是 0 和 1，这种表示方法表示的数 b 定义如下：
```math
b = \sum_{i=-n}^{m} 2^i \times b_i
```
考虑有限长度的编码，那么十进制表示法不能准确的表达像 $\frac{1}{3}$ 和 $\frac{5}{7}$ 这样的数。类似的，小数的二进制表示法只能表示那些能够被写成 $ \times 2^y$  的数。其他的值只能够被近似的表示。


### IEEE 浮点表示

IEEE 浮点标准用 $V=(-1)^s \times M \times 2^E $ 的形式表示一个数：
- 符号 sign s 决定这个数是负数还是正数
- 尾数 significand M 是一个二进制小数，它的范围是 $1 ~ 2 - \epsilon$ 或者 $0 ~ 1 - \epsilon$
- 阶码 exponent E 的作用是对浮点数加权，这个权重是 2 的 E 次幂

将浮点数的位划分为三个字段，分别对这些值进行编码：
- 一个单独的符号位 s 直接编码符号 s
- k 位的阶码字段 $exp=e_{k-1}\cdots e_1e_0$ 编码阶码 E
- n 位小数字段 $frac=f_{n-1}\cdots f_1f_0$ 编码尾数 M，但是编码出来的值也依赖与阶码的字段的值是否等于 0。

单精度数中 s，exp，frac 分别位 1, 8， 23 位
双精度数中 s，exp，frac 分别位 1, 11， 52 位

根据 exp的值，被编码的值可以分为三种不同情况

- 规格化值
- 非规格化值
- 特殊值


有 k 位阶码和 n 位小数的浮点数表示的一般属性：
- 值 +0.0 总有一个全为 0 的位表示。
- 最小的正非规格化值的位表示，是由最低有效位为 1 而其他所有位为 0 构成的。它具有小数（和尾数）值 $M=f=2^{-n}$ 和阶码值 $E=-2^{k-1}+2$。因此它的数字值是 $V=2^{-n-2^{k-1}+2}$。


### 舍入

对于浮点数 x，用一种系统的方法，能够找到“最接近的” 匹配值 x‘，它可以用期望的浮点形式表示出来。这就是舍入(rounding)运算的任务。

IEEE 浮点数定义了四种不同的舍入方式。默认的方式是找到最接近的匹配，而其它三种可用于计算上界和下界。

四种不同的舍入方式：向偶数舍入、向零舍入、向下舍入、向上舍入



### 浮点运算


### C 语言中的浮点数

所有的 C 语言版本提供了两种不同的浮点数数据类型：float 和 double。对应于单精度和双精度。因为 C 语言标准不要求机器使用 IEEE 浮点，所有没有标准的方法来改变舍入方式或者得到诸如 -0、$+\infty$、$-\infty$ 或者 NaN 之类的特殊值。



# 程序的机器级表示

对于严谨的程序员，能够阅读和理解汇编代码人是一项很重要的技能：
- 能够理解编译器的优化能力，并分析代码中隐含的低效率

- 当用线程包写并发程序时，知道存储器保存不同的程序变量的区域是很重要的。这些信息在汇编代码级是可见的。

- 程序遭受攻击的许多方式中，都涉及程序存储运行时控制信息的细节。

程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时只要求程序员能直接用汇编语言编写程序， 现在则是要求他们能够阅读和理解编译器产生的代码。



## 历史观点


## 程序编码

gcc 调用了一系列程序，将源代码转换为可执行代码：
- 首先，__C 预处理器__ 扩展源代码，插入所有用 `#include` 命令指定的文件，并扩展所有用 `#define` 声明指定的宏。

- 然后 __编译器__ 产生源代码的汇编代码。后缀名 `.s`。

- 接下来， __汇编器__ 将汇编代码转换成二进制目标代码文件，缀名 `.o`。
  目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入地址的全局值。

- 最后，__链接器__ 将目标代码文件与实现库函数的代码合并，并产生最终可执行代码文件。


### 机器级代码

计算机系统使用了多种不同形式的抽象。利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，两种抽象尤为重要：
- 机器级程序的格式和行为，定义为指令集体系结构 (Instruction set architecture, ISA)，它定义了处理器状态、指令的格式以及每条指令对状态的影响

- 机器级程序使用的存储地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组。存储器的实际实现是将多个硬件存储器和操作系统软件组合起来



### 代码示例
> code/sum.c


### 关于格式的注解

所有以 ‘.’ 开头的行都是指导汇编器和链接器的命令，通常可以忽略这些行。

ATT 和 intel 使用不同的汇编格式，默认情况下，使用 ATT 的汇编格式


## 数据格式

由于从 16 位体系结构扩展成 32 位，intel 用术语 ”字“ (word) 表示 16 位数据类型。因此 32 位数为 “双字” (double word)，称 64 位数为 “四字” (quad words)。

大多数 GCC 生成的汇编代码指令都有一个字符后缀，表明操作数的大小。例如数据传送指令有三个变种：movb 传送字节、movw 传送字、movl 传送双字

汇编代码使用后缀 'l' 来表示 4 字节整数和 8 字节双精度浮点数。


## 访问信息

一个 IA32 中央处理单元 CPU 包含一组 8 个存储 32 位值的寄存器。这些存储器用来存储整数数据和指针。它们的名字都以 %e 开头，不过它们都另有特殊的名字。在平坦寻址中，对特殊寄存器的需求已经极大的降低。

在大多数情况下，前 6 个寄存器都可以看成通用寄存器，对它们的使用没有限制。说“大多数情况”，是因为有些指令以固定的寄存器作为源寄存器 和/或 目的寄存器。另外在处理过程中，对前 3 个寄存器 (%eax, %ecx, %edx) 的保存和恢复惯例不同于接下来的 3 个寄存器 (%ebx, %edi, %esi)。最后两个寄存器 (%ebp, %esp) 保存着指向程序栈中最重要位置的指针。只有根据栈管理的标准惯例才能修改这两个寄存器中的值。

字节操作指令可以独立的读或写前 4 个寄存器的 2 低位字节。例如 %eax 读取全部 32 位(31~0)，则 %ax读取后 16 位(15~0)，%ah 读取 15~0 位 %al 读取最后 8 位(7~0)


### 操作数指示符

大多数指令有一个或多个操作数 (operand)，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。

各种不同的操作数的可能性被分为三种类型：
- 立即数 immediate，也就是常数值。立即数的书写方式是 '$' 后面跟一个用标准 C 表示法表示的整数
- 寄存器 register，它表示某个寄存器的内容
- 存储器 memory 引用，它会根据计算出来的地址访问某个存储器位置。


图3-3(略) 操作数的多种格式，包括立即数寻址、寄存器寻址、绝对寻址、间接寻址、变址寻址、比例变址寻址


### 数据传送指令

将数据从一个位置复制到另一个位置的指令是最频繁使用的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条指令才能完成的功能。

- MOV类由三条指令组成，分别传送1，2 和 4 字节的数据上进行操作
  - IA32 加了一条限制，传送指令的两个操作数不能都指向存储器位置。

- MOVS 和 MOVZ 类指令都是将一个较小的源数据复制到一个较大的数据位置，高位用符号位扩展或者零扩展进行填充。

- 最后两个数据传输操作可以将数据压入程序栈中，以及从程序栈中弹出数据。


### 数据传送示例


```c
int exchange(int *xp, int y) {
  int x = *xp
  *xp = y
  return x;
}
```

```asm
// xp at % ebp+8, y at %ebp+12
movl 8(%ebp), %edx    // get xp

movl (%edx), %eax     // Get x at xp
movl 12(%ebp), %eca   // Get y
movl %ecx, (%edx)     // Store y at xp
```


## 算术和逻辑操作

大多数操作都分成了指令类，这些指令类有各种带不同操作数的变种。给出的每个指令类都有对字节、字和双字数据进行操作的指令。

这些操作被分为四组：加载有效地址、一元操作、二元操作及移位

### 加载有效地址




