[toc]

# 信息的表示和处理

## 信息的存储

### 寻址和字节顺序

排列表示一个对象的字节有两个通用的规则。最低有效位在最前面的方式，称为小端法 (little-endian)。大多数 intel 兼容机都采用这种规则。最高有效位在最前面的方式，称为大端法 (big-endian)。许多比较新的微处理器使用双端法 (bi-endian)，也就是说可以把它们配置成作为大端或小端的机器运行。


## 整数的表示

### 无符号数的编码

### 补码的编码 two's-complement

- 有符号数的其他表示方法：
  - 反码 One's Complement
  - 原码 Sign-Magnitude

> 虽然过去生产过基于反码表示的机器，但是几乎所有现代机器都使用补码


### 有符号数和无符号数之间的转换
- 对大多数 C 语言而言，处理同样字长的有符号数和无符号数之间的相互转换的一般规则是，数值可能会改变，但是位模式不变。
- 当执行一个运算时，如果一个数是有符号的，而另一个数是无符号的，那么 C 语言会隐式的将有符号参数强制转换为无符号数，并假设这两个数都是非负的，来执行这个运算。
- C 头文件 limits.h 对 TMIN TMAX 的写法：
```c
# define INT_MAX 2147483647
# define INT_MIN (-2147483647-1)
```
补码表示的不对称性和 C 语言转换规则之间这种奇怪的交互，迫使我们用这样的不寻常的方式来写 TMIN。


### 扩展即一个数字的位表示

一种常见的运算是不同字长的整数之间的转换，同时又保持数值不变。

- 零扩展 zero extension，需要简单的在表示的开头添加 0 
- 符号扩展，sign extension，规则是在表示中添加最高有效位的一个副本


### 截断数字

假设不用额外的位来扩展一个数值，而是减少一个数字的位数。

对于一个无符号数字 x，截断它的 k 位的结果就相当于计算 $x\mod 2^k$，即丢弃掉高 w-k 位。($2^{k+} \mod 2^k = 0 $)
对于一个有符号数 x，截断它的 k 位的结果相当于先进行无符号数字的截断，在将无符号数转换为有符号数。位模式不变，数值改变。

```c
int x = 53191;
short sx = (short) x; /* -12345 */
int y = sx;           /* -12345 */
```

### 关于有符号数与无符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且很难被发现。


## 整数运算

### 无符号加法

现在定义参数 x 和 y 的运算 $+_w^u$，这里 $0\leq x, y\leq 2^w$，如下：
```math
x +_w^u y = 
\begin{cases}
x+y,      x + y \leq 2^w \\\\
x+y-2^w,  2^w\leq x+y\leq 2^{w+1}
\end{cases}
```

一个算术运算溢出，是指完整的整数结果不能放到数据类型的字长限制中去。所以当两个运算数的和为 $2^w$ 或者更大时，就发生了溢出。

当执行 C 程序时，不会将溢出作为错误而发出信号。不过有时候，可能希望判定是否发生了溢出。

模数加法形成了一种数学结构，称为 __阿贝尔群__ (Abelian group)，也就是说，它是可交换和可结合的。它有一个单位元 0，并且每个元素都有一个加法逆元。

考虑 w 位的无符号数的集合，执行加法运算 $+_w^u$，对于每个值 x，必然有某个值 $-_w^ux$ 满足 $-_w^ux+_w^ux=0$。因此它就是 x 在 $+_w^u$ 下的逆元

```math
-_w^u x = 
\begin{cases}
x,      x = 0 \\\\
2^w-x,  x > 0
\end{cases}
```

### 补码加法

两个数的 w 位补码之和与无符号之和有完全相同的位级表示。实际上，大多数计算机使用同样的机器指令来执行无符号或者有符号加法。

范围在 $-2{w-1} \leq x, y \leq 2^{w-1}-1$ 之内的 x 和 y 实施运算 $+_w^t$ 时，有下面这样的表达式：
```math
x +_w^t y = 
\begin{cases}
x+y-2^w,      2^{w-1} \leq x + y 正溢出  \\\\
x+y,          -2{w-1} \leq x + y \leq 2^{w-1}-1 正常 \\\\
x + y + 2^w,  x + y \leq - 2^{w-1} 负溢出
\end{cases}
```
当 x 和 y 都是负数，但是 x $+_w^t$ y > 0 时，就会得到负溢出
当 x 和 y 都是正数，但是 x $+_w^t$ y < 0 时，就会得到正溢出


### 补码的非

定义在 $-2{w-1} \leq x, y < 2^{w-1}$ 之内的 x，补码的非运算（negation operation）$-_w^t$ 如下：
```math
-_w^t x = 
\begin{cases}
-2^{w-1},     x = -2^{w-1} \\\\
-x,           x > -2^{w-1}
\end{cases}
```
-x = $2{w-1}$ 不能表示成一个 w 位的数。因此声明，这个特殊数本身就是它在 $-_w^t$ 下的加法逆元。

求位级补码非
- 第一种方法是对每一位求补，再对结果加 1。在 C 语言中，可以确定对于任意整数值 x，计算表达式 -x 和 $\sim x + 1$ 得到的结果完全一样。
- 第二种方法是建立在将位向量分为两部分的基础之上的，假设 k 是最右边的 1 位置，因而 x 的位级表示形如 $[x_{w-1},x_{w-2},\cdots,x_{k+1},1,0,\cdots,0]$。这个值的非写成二进制格式就是 $[\sim x_{w-1},\sim x_{w-2},\cdots,\sim x_{k+1},1,0,\cdots,0]$。也就是对位置 k 左边的所有位取反。


### 无符号数乘法

C 语言中的无符号乘法被定义为产生 w 位的值，就是 2w 位的整数乘积的低 w 位表示的值。可以看作等价于计算乘积模 $2^w$

```math
x *_w^u y = (x\cdot y) \mod 2^w
```

### 补码乘法

对于无符号和补码乘法来说，乘法运算的位级表示都是一样的。设 $x=B2T_w(\overrightarrow x)$ 和 $y=B2T_w(\overrightarrow y)$是这些位模式表示的补码值，而 $x'=B2U_w(\overrightarrow x)$ 和 $y'=B2U_w(\overrightarrow y)$ 是这些位模式表示的无符号值。根据等式 2-5 有 $x'=x+x_{w-1}2^w$ 和 $y'=y+y_{w-1}2^w$ 。计算这些值的乘积模 $2^w$ 得到以下结果：
```math
(x'\cdot y') = [(x+x_{w-1}2^w)\cdot (y+y_{w-1}2^w)] \mod 2^w \\\\
= [x\cdot y + (x_{w-1}y+y_{w-1}x)2^w + x_{w-1}y_{w-1}2^{2w}] \mod 2^w \\\\
= (x\cdot y) \mod 2^w
```

### 乘以常数

大多数机器上，整数乘法指令相当慢，需要 10 个或更多的时钟周期，然而其他的整数运算（例如加法、减法、位即运算和移位）只需要一个时钟周期。

因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。


### 除以2的幂

大多数机器上，整数除法要比整数乘法更慢，需要 30 个或更多的时钟周期。除以 2 的幂也可以用移位操作来实现。只不过使用右移。

对一个无符号数的逻辑右移和除以 $2^k$ 有一样的效果。证明(后续补充)


### 关于整数运算的思考

计算机执行的“整数”运算时间上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。

补码表示提供了一种即能表示负数也能表示整数的灵活方法，同时使用了与执行无符号算术相同的位级实现。

C 语言中的某些规定可能会产生令人意想不到的结果，而这些可能是难以察觉和理解的缺陷的源头。


## 浮点数

浮点表示对形如 $V=x \times 2^y$ 的有理数进行编码。它对执行涉及非常大的数字(|V|>>0)、非常接近与 0(|V|<<1)的数字，以及更普遍的作为实数运算的近似值的计算。

IEEE Standard 754，是浮点数及其运算的标准。这个提高了科学应用程序在不同计算机上的可移植性。


### 二进制小数

一个形如 $b_mb_{m-1}\cdots b_1b_0.b_{-1}b_{-2}\cdots b_{-n+1}b_{-n}$ 的表示法，其中每个二进制数字，或者称为位，$b_i$ 的取值范围是 0 和 1，这种表示方法表示的数 b 定义如下：
```math
b = \sum_{i=-n}^{m} 2^i \times b_i
```
考虑有限长度的编码，那么十进制表示法不能准确的表达像 $\frac{1}{3}$ 和 $\frac{5}{7}$ 这样的数。类似的，小数的二进制表示法只能表示那些能够被写成 $ \times 2^y$  的数。其他的值只能够被近似的表示。


### IEEE 浮点表示

IEEE 浮点标准用 $V=(-1)^s \times M \times 2^E $ 的形式表示一个数：
- 符号 sign s 决定这个数是负数还是正数
- 尾数 significand M 是一个二进制小数，它的范围是 $1 ~ 2 - \epsilon$ 或者 $0 ~ 1 - \epsilon$
- 阶码 exponent E 的作用是对浮点数加权，这个权重是 2 的 E 次幂

将浮点数的位划分为三个字段，分别对这些值进行编码：
- 一个单独的符号位 s 直接编码符号 s
- k 位的阶码字段 $exp=e_{k-1}\cdots e_1e_0$ 编码阶码 E
- n 位小数字段 $frac=f_{n-1}\cdots f_1f_0$ 编码尾数 M，但是编码出来的值也依赖与阶码的字段的值是否等于 0。

单精度数中 s，exp，frac 分别位 1, 8， 23 位
双精度数中 s，exp，frac 分别位 1, 11， 52 位

根据 exp的值，被编码的值可以分为三种不同情况

- 规格化值
- 非规格化值
- 特殊值


有 k 位阶码和 n 位小数的浮点数表示的一般属性：
- 值 +0.0 总有一个全为 0 的位表示。
- 最小的正非规格化值的位表示，是由最低有效位为 1 而其他所有位为 0 构成的。它具有小数（和尾数）值 $M=f=2^{-n}$ 和阶码值 $E=-2^{k-1}+2$。因此它的数字值是 $V=2^{-n-2^{k-1}+2}$。


### 舍入

对于浮点数 x，用一种系统的方法，能够找到“最接近的” 匹配值 x‘，它可以用期望的浮点形式表示出来。这就是舍入(rounding)运算的任务。

IEEE 浮点数定义了四种不同的舍入方式。默认的方式是找到最接近的匹配，而其它三种可用于计算上界和下界。

四种不同的舍入方式：向偶数舍入、向零舍入、向下舍入、向上舍入



### 浮点运算


### C 语言中的浮点数

所有的 C 语言版本提供了两种不同的浮点数数据类型：float 和 double。对应于单精度和双精度。因为 C 语言标准不要求机器使用 IEEE 浮点，所有没有标准的方法来改变舍入方式或者得到诸如 -0、$+\infty$、$-\infty$ 或者 NaN 之类的特殊值。



# 程序的机器级表示

对于严谨的程序员，能够阅读和理解汇编代码人是一项很重要的技能：
- 能够理解编译器的优化能力，并分析代码中隐含的低效率

- 当用线程包写并发程序时，知道存储器保存不同的程序变量的区域是很重要的。这些信息在汇编代码级是可见的。

- 程序遭受攻击的许多方式中，都涉及程序存储运行时控制信息的细节。

程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时只要求程序员能直接用汇编语言编写程序， 现在则是要求他们能够阅读和理解编译器产生的代码。



## 历史观点


## 程序编码

gcc 调用了一系列程序，将源代码转换为可执行代码：
- 首先，__C 预处理器__ 扩展源代码，插入所有用 `#include` 命令指定的文件，并扩展所有用 `#define` 声明指定的宏。

- 然后 __编译器__ 产生源代码的汇编代码。后缀名 `.s`。

- 接下来， __汇编器__ 将汇编代码转换成二进制目标代码文件，缀名 `.o`。
  目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入地址的全局值。

- 最后，__链接器__ 将目标代码文件与实现库函数的代码合并，并产生最终可执行代码文件。


### 机器级代码

计算机系统使用了多种不同形式的抽象。利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，两种抽象尤为重要：
- 机器级程序的格式和行为，定义为指令集体系结构 (Instruction set architecture, ISA)，它定义了处理器状态、指令的格式以及每条指令对状态的影响

- 机器级程序使用的存储地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组。存储器的实际实现是将多个硬件存储器和操作系统软件组合起来



### 代码示例
> code/sum.c


### 关于格式的注解

所有以 ‘.’ 开头的行都是指导汇编器和链接器的命令，通常可以忽略这些行。

ATT 和 intel 使用不同的汇编格式，默认情况下，使用 ATT 的汇编格式


## 数据格式

由于从 16 位体系结构扩展成 32 位，intel 用术语 ”字“ (word) 表示 16 位数据类型。因此 32 位数为 “双字” (double word)，称 64 位数为 “四字” (quad words)。

大多数 GCC 生成的汇编代码指令都有一个字符后缀，表明操作数的大小。例如数据传送指令有三个变种：movb 传送字节、movw 传送字、movl 传送双字

汇编代码使用后缀 'l' 来表示 4 字节整数和 8 字节双精度浮点数。


## 访问信息

一个 IA32 中央处理单元 CPU 包含一组 8 个存储 32 位值的寄存器。这些存储器用来存储整数数据和指针。它们的名字都以 %e 开头，不过它们都另有特殊的名字。在平坦寻址中，对特殊寄存器的需求已经极大的降低。

在大多数情况下，前 6 个寄存器都可以看成通用寄存器，对它们的使用没有限制。说“大多数情况”，是因为有些指令以固定的寄存器作为源寄存器 和/或 目的寄存器。另外在处理过程中，对前 3 个寄存器 (%eax, %ecx, %edx) 的保存和恢复惯例不同于接下来的 3 个寄存器 (%ebx, %edi, %esi)。最后两个寄存器 (%ebp, %esp) 保存着指向程序栈中最重要位置的指针。只有根据栈管理的标准惯例才能修改这两个寄存器中的值。

字节操作指令可以独立的读或写前 4 个寄存器的 2 低位字节。例如 %eax 读取全部 32 位(31~0)，则 %ax读取后 16 位(15~0)，%ah 读取 15~0 位 %al 读取最后 8 位(7~0)


### 操作数指示符

大多数指令有一个或多个操作数 (operand)，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。

各种不同的操作数的可能性被分为三种类型：
- 立即数 immediate，也就是常数值。立即数的书写方式是 '$' 后面跟一个用标准 C 表示法表示的整数
- 寄存器 register，它表示某个寄存器的内容
- 存储器 memory 引用，它会根据计算出来的地址访问某个存储器位置。


图3-3(略) 操作数的多种格式，包括立即数寻址、寄存器寻址、绝对寻址、间接寻址、变址寻址、比例变址寻址


### 数据传送指令

将数据从一个位置复制到另一个位置的指令是最频繁使用的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条指令才能完成的功能。

- MOV类由三条指令组成，分别传送1，2 和 4 字节的数据上进行操作
  - IA32 加了一条限制，传送指令的两个操作数不能都指向存储器位置。

- MOVS 和 MOVZ 类指令都是将一个较小的源数据复制到一个较大的数据位置，高位用符号位扩展或者零扩展进行填充。

- 最后两个数据传输操作可以将数据压入程序栈中，以及从程序栈中弹出数据。

在 IA32 中程序栈存放在存储器中某个区域，栈向下增长，这样栈顶元素的地址是所有栈中元素地址中 __最低__ 的。根据惯例，栈是倒过来画的，栈"顶"在图的底部。栈指针保存这栈顶元素的地址。
- 所以压栈 push 指令是减小栈指针 (寄存器 %esp) 的值，并将数据存放在存储器中，
- 而出栈 pop 指令是从存储器中读，并增加栈指针的值。


### 数据传送示例

```c
int exchange(int *xp, int y) {
  int x = *xp
  *xp = y
  return x;
}
```

```asm
// xp at % ebp+8, y at %ebp+12
movl 8(%ebp), %edx    // get xp

movl (%edx), %eax     // Get x at xp
movl 12(%ebp), %eca   // Get y
movl %ecx, (%edx)     // Store y at xp
```


## 算术和逻辑操作

大多数操作都分成了指令类，这些指令类有各种带不同操作数的变种。给出的每个指令类都有对字节、字和双字数据进行操作的指令。

这些操作被分为四组：加载有效地址、一元操作、二元操作及移位


指令| 效果 | 描述 
|---|---|---|
leal S,D | $D \leftarrow \&S$ | 加载有效地址
||
INC D | $D \leftarrow D + 1$ | 加 1
DEC D | $D \leftarrow D - 1$ | 减 1
INC D | $D \leftarrow - D$ | 取负
INC D | $D \leftarrow \~D$ | 取补
||
ADD S, D | $D \leftarrow D + S$ | 加
SUB S, D | $D \leftarrow D - S$ | 减
IMUL S, D | $D \leftarrow D * S$ | 乘
XOR S, D | $D \leftarrow D ^ S$ | 异或
OR S, D | $D \leftarrow D \| S$ | 或
AND S, D | $D \leftarrow D \& S$ | 与
||
SAL k，D | $D \leftarrow D << k$ | 左移
SHL k，D | $D \leftarrow D << k$ | 左移 等同于 SAL
SAR k，D | $D \leftarrow D >>_A k$ | 算术右移
SHR k，D | $D \leftarrow D >>_L k$ | 逻辑右移

注 imull 指令为双操作数乘法指令，它从两个 32 位操作数产生一个 32 位乘积。

### 加载有效地址

__加载有效地址__ (load effective address) 指令实际上是 movl 指令的变形。它的形式是从存储器读数据到寄存器，但实际上它根本没有引用存储器。目的操作数必须是一个寄存器

加载有效地址 (leal) 指令通常用来执行简单的算术操作。


### 一元操作和二元操作

一元操作，它只有一个操作数，即是源又是目的。这个操作数可以是一个寄存器，也可以是一个存储器位置。

二元操作，其中第二个操作数即是源又是目的。第一个操作数可以是立即数、寄存器或是存储器位置。第二个操作数可以是寄存器或是存储器位置。同 movl 指令一样，两个操作数不能同时是存储器位置。


### 移位操作

先给出移位量，然后第二项给出的要移位的数值。可以进行算术或逻辑右移。移位量用单个字节编码，因为只允许进行 0 到 31 位的移位。移位量可以是立即数，或者放在单字节寄存器元素 %cl 中。移位操作的目的操作数可以是一个寄存器或是一个存储器位置。


### 特殊的算术操作

相比较于上节所述的 imull 双操作数实现 32 位乘法指令，IA32 还提供了两个不同的单操作数指令，以计算两个 32 位值的全 64 位乘积。指令都要求一个参数必须在寄存器 %eax 中，而另一个作为指令的源操作数给出，然后乘积存放在寄存器 %edx (高32位) 和 %eax (低32位) 中。

指令| 效果 | 描述 
|---|---|---|
imull S | R[%edx]:R[%eax] $\leftarrow$ S $\times$ R[%eax] | 有符号全 64 位乘法
mull S | R[%edx]:R[%eax] $\leftarrow$ S $\times$ R[%eax] | 无符号全 64 位乘法
||
cltd | R[%edx]:R[%eax] $\leftarrow$ SignExtend(R[%eax]) | 转为四字
||
idivl S | R[%edx] $\leftarrow$ R[%edx]:R[%eax] mod R[%eax] <br> R[%eax] $\leftarrow$ R[%edx]:R[%eax] $\div$ R[%eax]  | 有符号除法
||
divl S | R[%edx] $\leftarrow$ R[%edx]:R[%eax] mod R[%eax] <br> R[%eax] $\leftarrow$ R[%edx]:R[%eax] $\div$ R[%eax]  | 无符号除法

注：一对寄存器 %edx 和 %eax 组成一个 64 位的四字


## 控制

机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。


### 条件码

除了整数寄存器，CPU 还维护一组单个位的条件码 (Condition Code) 寄存器 最常用的条件码有：
- CF：进位标志。 最近的操作使最高为产生了进位。
- ZF：进位标志。 最近的操作得出的结果为 0
- SF：零标志。最近的操作得到的结果为负数
- OF：溢出标志。最近的操作导致一个补码溢出

leal 不改变任何条件码，因为它是用来进行地址计算的。除此之外，算术和逻辑操作指令都会设置条件码。

除了上述指令外，有两类指令它们只设置条件码，不改变任何其他寄存器。

指令| 基于 | 描述 
|---|---|---|
CMP $S_1,S_2$ | $S_1 - S_2$ | 比较
TEST $S_1,S_2$ | $S_1 \& S_2$ | 测试


### 访问条件码

条件码通常不会直接读取，常用的使用方法有三种：
- 可以根据条件码的某个组合，将一个字节设置为 0 或 1
- 可以条件跳转到程序的某个其他的部分
- 可以有条件的传送数据

这一整类指令称为 SET 指令，它们的区别就在于考虑的条件码的组合是什么。

一条 SET 指令的目的操作数是 8 个单字节寄存器元素之一，或者是存储一个字节的存储器位置，将这个字节设置成 0 或 1。


### 跳转指令及其编码

正常执行的情况下，指令按照它们出现的顺序一条一条执行。__跳转__ (jump) 指令会导致执行切换到程序中一个全新的位置。这些跳转的目的地址通常用一个标号 (label) 指明。

jmp 指令是无条件跳转，它可以直接跳转，即跳到目标作为指令的一部分编码；也可以是间接跳转，即跳转目标是从寄存器或存储位置中读出的。

除 jmp 外，其他跳转指令都是有条件的，它们根据条件码的组合，或者跳转，或者继续执行代码序列中的下一条指令。

跳转指令有几种不同的编码，但是最常用的都是程序计数器相关的。
- 它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。
- 第二种编码方法是给出“绝对”地址，用 4 个字节直接指定目标。


### 翻译条件分支

将条件表达式和语句从 C 语言翻译成机器代码，最常用的方法是结合有条件和无条件跳转

C 语言中的 $if-else$ 语句的通用形式模板是这样的：
```
if (test-expr)
  then-statement
else
  else-statement
```

对于这种通用形式，汇编实现通常会使用下面这种形式，
```
  t = test-expr
  if (!it)
    goto false;
  then-statement
  go done;
false
  else-statement
done:
```
也就是，汇编器为 then-statement 和 else-statement 产生各自的代码块。


### 循环

C 语言提供了多种循环结构，即 do-while、while 和 for。汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。


#### do-while 循环

do-while 语句的通用形式如下：


#### while 循环


#### for 循环


### 条件传送指令


