[toc]

# 信息的表示和处理

## 整数的表示

### 无符号数的编码

### 补码的编码 two's-complement

- 有符号数的其他表示方法：
  - 反码 One's Complement
  - 原码 Sign-Magnitude

> 虽然过去生产过基于反码表示的机器，但是几乎所有现代机器都使用补码


### 有符号数和无符号数之间的转换
- 对大多数 C 语言而言，处理同样字长的有符号数和无符号数之间的相互转换的一般规则是，数值可能会改变，但是位模式不变。
- 当执行一个运算时，如果一个数是有符号的，而另一个数是无符号的，那么 C 语言会隐式的将有符号参数强制转换为无符号数，并假设这两个数都是非负的，来执行这个运算。
- C 头文件 limits.h 对 TMIN TMAX 的写法：
```c
# define INT_MAX 2147483647
# define INT_MIN (-2147483647-1)
```
补码表示的不对称性和 C 语言转换规则之间这种奇怪的交互，迫使我们用这样的不寻常的方式来写 TMIN。


### 扩展即一个数字的位表示

一种常见的运算是不同字长的整数之间的转换，同时又保持数值不变。

- 零扩展 zero extension，需要简单的在表示的开头添加 0 
- 符号扩展，sign extension，规则是在表示中添加最高有效位的一个副本


### 截断数字

假设不用额外的位来扩展一个数值，而是减少一个数字的位数。

对于一个无符号数字 x，截断它的 k 位的结果就相当于计算 $x\mod 2^k$，即丢弃掉高 w-k 位。($2^{k+} \mod 2^k = 0 $)
对于一个有符号数 x，截断它的 k 位的结果相当于先进行无符号数字的截断，在将无符号数转换为有符号数。位模式不变，数值改变。

```c
int x = 53191;
short sx = (short) x; /* -12345 */
int y = sx;           /* -12345 */
```

### 关于有符号数与无符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且很难被发现。


## 整数运算

### 无符号加法

现在定义参数 x 和 y 的运算 $+_w^u$，这里 $0\leq x, y\leq 2^w$，如下：
```math
x +_w^u y = 
\begin{cases}
x+y,      x + y \leq 2^w \\\\
x+y-2^w,  2^w\leq x+y\leq 2^{w+1}
\end{cases}
```

一个算术运算溢出，是指完整的整数结果不能放到数据类型的字长限制中去。所以当两个运算数的和为 $2^w$ 或者更大时，就发生了溢出。

当执行 C 程序时，不会将溢出作为错误而发出信号。不过有时候，可能希望判定是否发生了溢出。


### 补码加法

两个数的 w 位补码之和与无符号之和有完全相同的位级表示。实际上，大多数计算机使用同样的机器指令来执行无符号或者有符号加法。

范围在 $-2{w-1} \leq x, y \leq 2^{w-1}-1$ 之内的 x 和 y 实施运算 $+_w^t$ 时，有下面这样的表达式：
```math
x +_w^t y = 
\begin{cases}
x+y-2^w,      2^{w-1} \leq x + y 正溢出  \\\\
x+y,          -2{w-1} \leq x + y \leq 2^{w-1}-1 正常 \\\\
x + y + 2^w,  x + y \leq - 2^{w-1} 负溢出
\end{cases}
```
当 x 和 y 都是负数，但是 x $+_w^t$ y > 0 时，就会得到负溢出
当 x 和 y 都是正数，但是 x $+_w^t$ y < 0 时，就会得到正溢出


### 补码的非

定义在 $-2{w-1} \leq x, y < 2^{w-1}$ 之内的 x，补码的非运算（negation operation）$-_w^t$ 如下：
```math
-_w^t x = 
\begin{cases}
-2^{w-1},     x = -2^{w-1} \\\\
-x,           x > -2^{w-1}
\end{cases}
```
-x = $2{w-1}$ 不能表示成一个 w 位的数。因此声明，这个特殊数本身就是它在 $-_w^t$ 下的加法逆元。

求位级补码非
- 第一种方法是对每一位求补，再对结果加 1。在 C 语言中，可以确定对于任意整数值 x，计算表达式 -x 和 $\sim x + 1$ 得到的结果完全一样。
- 第二种方法是建立在将位向量分为两部分的基础之上的，假设 k 是最右边的 1 位置，因而 x 的位级表示形如 $[x_{w-1},x_{w-2},\cdots,x_{k+1},1,0,\cdots,0]$。这个值的非写成二进制格式就是 $[\sim x_{w-1},\sim x_{w-2},\cdots,\sim x_{k+1},1,0,\cdots,0]$。也就是对位置 k 左边的所有位取反。


### 无符号数乘法

C 语言中的无符号乘法被定义为产生 w 位的值，就是 2w 位的整数乘积的低 w 位表示的值。可以看作等价于计算乘积模 $2^w$

```math
x *_w^u y = (x\cdot y) \mod 2^w
```

### 补码乘法

对于无符号和补码乘法来说，乘法运算的位级表示都是一样的。设 $x=B2T_w(\overrightarrow x)$ 和 $y=B2T_w(\overrightarrow y)$是这些位模式表示的补码值，而 $x'=B2U_w(\overrightarrow x)$ 和 $y'=B2U_w(\overrightarrow y)$ 是这些位模式表示的无符号值。根据等式 2-5 有 $x'=x+x_{w-1}2^w$ 和 $y'=y+y_{w-1}2^w$ 。计算这些值的乘积模 $2^w$ 得到以下结果：
```math
(x'\cdot y') = [(x+x_{w-1}2^w)\cdot (y+y_{w-1}2^w)] \mod 2^w \\\\
= [x\cdot y + (x_{w-1}y+y_{w-1}x)2^w + x_{w-1}y_{w-1}2^{2w}] \mod 2^w \\\\
= (x\cdot y) \mod 2^w
```

### 乘以常数

大多数机器上，整数乘法指令相当慢，需要 10 个或更多的时钟周期，然而其他的整数运算（例如加法、减法、位即运算和移位）只需要一个时钟周期。

因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。


### 除以2的幂

大多数机器上，整数除法要比整数乘法更慢，需要 30 个或更多的时钟周期。除以 2 的幂也可以用移位操作来实现。只不过使用右移。

对一个无符号数的逻辑右移和除以 $2^k$ 有一样的效果。证明(后续补充)


### 关于整数运算的思考

计算机执行的“整数”运算时间上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。

补码表示提供了一种即能表示负数也能表示整数的灵活方法，同时使用了与执行无符号算术相同的位级实现。

C 语言中的某些规定可能会产生令人意想不到的结果，而这些可能是难以察觉和理解的缺陷的源头。


## 浮点数

浮点表示对形如 $V=x \times 2^y$ 的有理数进行编码。它对执行涉及非常大的数字(|V|>>0)、非常接近与 0(|V|<<1)的数字，以及更普遍的作为实数运算的近似值的计算。

IEEE Standard 754，是浮点数及其运算的标准。这个提高了科学应用程序在不同计算机上的可移植性。


### 二进制小数

一个形如 $b_mb_{m-1}\cdots b_1b_0.b_{-1}b_{-2}\cdots b_{-n+1}b_{-n}$ 的表示法，其中每个二进制数字，或者称为位，$b_i$ 的取值范围是 0 和 1，这种表示方法表示的数 b 定义如下：
```math
b = \sum_{i=-n}^{m} 2^i \times b_i
```
考虑有限长度的编码，那么十进制表示法不能准确的表达像 $\frac{1}{3}$ 和 $\frac{5}{7}$ 这样的数。类似的，小数的二进制表示法只能表示那些能够被写成 $ \times 2^y$  的数。其他的值只能够被近似的表示。


### IEEE 浮点表示

IEEE 浮点标准用 $V=(-1)^s \times M \times 2^E $ 的形式表示一个数：
- 符号 sign s 决定这个数是负数还是正数
- 尾数 significand M 是一个二进制小数，它的范围是 $1 ~ 2 - \epsilon$ 或者 $0 ~ 1 - \epsilon$
- 阶码 exponent E 的作用是对浮点数加权，这个权重是 2 的 E 次幂

将浮点数的位划分为三个字段，分别对这些值进行编码：
- 一个单独的符号位 s 直接编码符号 s
- k 位的阶码字段 $exp=e_{k-1}\cdots e_1e_0$ 编码阶码 E
- n 位小数字段 $frac=f_{n-1}\cdots f_1f_0$ 编码尾数 M，但是编码出来的值也依赖与阶码的字段的值是否等于 0。

单精度数中 s，exp，frac 分别位 1, 8， 23 位
双精度数中 s，exp，frac 分别位 1, 11， 52 位

根据 exp的值，被编码的值可以分为三种不同情况

- 规格化值
- 非规格化值
- 特殊值


有 k 位阶码和 n 位小数的浮点数表示的一般属性：
- 值 +0.0 总有一个全为 0 的位表示。
- 最小的正非规格化值的位表示，是由最低有效位为 1 而其他所有位为 0 构成的。它具有小数（和尾数）值 $M=f=2^{-n}$ 和阶码值 $E=-2^{k-1}+2$。因此它的数字值是 $V=2^{-n-2^{k-1}+2}$。


### 舍入

对于浮点数 x，用一种系统的方法，能够找到“最接近的” 匹配值 x‘，它可以用期望的浮点形式表示出来。这就是舍入(rounding)运算的任务。

IEEE 浮点数定义了四种不同的舍入方式。默认的方式是找到最接近的匹配，而其它三种可用于计算上界和下界。

四种不同的舍入方式：向偶数舍入、向零舍入、向下舍入、向上舍入



### 浮点运算


### C 语言中的浮点数

所有的 C 语言版本提供了两种不同的浮点数数据类型：float 和 double。对应于单精度和双精度。因为 C 语言标准不要求机器使用 IEEE 浮点，所有没有标准的方法来改变舍入方式或者得到诸如 -0、$+\infty$、$-\infty$ 或者 NaN 之类的特殊值。



# 程序的机器级表示

对于严谨的程序员，能够阅读和理解汇编代码人是一项很重要的技能：
- 能够理解编译器的优化能力，并分析代码中隐含的低效率

- 当用线程包写并发程序时，知道存储器保存不同的程序变量的区域是很重要的。这些信息在汇编代码级是可见的。

- 程序遭受攻击的许多方式中，都涉及程序存储运行时控制信息的细节。

程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时只要求程序员能直接用汇编语言编写程序， 现在则是要求他们能够阅读和理解编译器产生的代码。



## 历史观点


## 程序编码

gcc 调用了一系列程序，将源代码转换为可执行代码：
- 首先，__C 预处理器__ 扩展源代码，插入所有用 `#include` 命令指定的文件，并扩展所有用 `#define` 声明指定的宏。

- 然后 __编译器__ 产生源代码的汇编代码。后缀名 `.s`。

- 接下来， __汇编器__ 将汇编代码转换成二进制目标代码文件，缀名 `.o`。
  目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入地址的全局值。

- 最后，__链接器__ 将目标代码文件与实现库函数的代码合并，并产生最终可执行代码文件。


### 机器级代码

计算机系统使用了多种不同形式的抽象。利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，两种抽象尤为重要：
- 机器级程序的格式和行为，定义为指令集体系结构 (Instruction set architecture, ISA)，它定义了处理器状态、指令的格式以及每条指令对状态的影响

- 机器级程序使用的存储地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组。存储器的实际实现是将多个硬件存储器和操作系统软件组合起来



### 代码示例
> code/sum.c


