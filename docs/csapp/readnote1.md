[toc]

# 信息的表示和处理

## 信息的存储

### 寻址和字节顺序

排列表示一个对象的字节有两个通用的规则。最低有效位在最前面的方式，称为小端法 (little-endian)。大多数 intel 兼容机都采用这种规则。最高有效位在最前面的方式，称为大端法 (big-endian)。许多比较新的微处理器使用双端法 (bi-endian)，也就是说可以把它们配置成作为大端或小端的机器运行。


## 整数的表示

### 无符号数的编码

### 补码的编码 two's-complement

- 有符号数的其他表示方法：
  - 反码 One's Complement
  - 原码 Sign-Magnitude

> 虽然过去生产过基于反码表示的机器，但是几乎所有现代机器都使用补码


### 有符号数和无符号数之间的转换
- 对大多数 C 语言而言，处理同样字长的有符号数和无符号数之间的相互转换的一般规则是，数值可能会改变，但是位模式不变。
- 当执行一个运算时，如果一个数是有符号的，而另一个数是无符号的，那么 C 语言会隐式的将有符号参数强制转换为无符号数，并假设这两个数都是非负的，来执行这个运算。
- C 头文件 limits.h 对 TMIN TMAX 的写法：
```c
# define INT_MAX 2147483647
# define INT_MIN (-2147483647-1)
```
补码表示的不对称性和 C 语言转换规则之间这种奇怪的交互，迫使我们用这样的不寻常的方式来写 TMIN。


### 扩展即一个数字的位表示

一种常见的运算是不同字长的整数之间的转换，同时又保持数值不变。

- 零扩展 zero extension，需要简单的在表示的开头添加 0 
- 符号扩展，sign extension，规则是在表示中添加最高有效位的一个副本


### 截断数字

假设不用额外的位来扩展一个数值，而是减少一个数字的位数。

对于一个无符号数字 x，截断它的 k 位的结果就相当于计算 $x\mod 2^k$，即丢弃掉高 w-k 位。($2^{k+} \mod 2^k = 0 $)
对于一个有符号数 x，截断它的 k 位的结果相当于先进行无符号数字的截断，在将无符号数转换为有符号数。位模式不变，数值改变。

```c
int x = 53191;
short sx = (short) x; /* -12345 */
int y = sx;           /* -12345 */
```

### 关于有符号数与无符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且很难被发现。


## 整数运算

### 无符号加法

现在定义参数 x 和 y 的运算 $+_w^u$，这里 $0\leq x, y\leq 2^w$，如下：
```math
x +_w^u y = 
\begin{cases}
x+y,      x + y \leq 2^w \\\\
x+y-2^w,  2^w\leq x+y\leq 2^{w+1}
\end{cases}
```

一个算术运算溢出，是指完整的整数结果不能放到数据类型的字长限制中去。所以当两个运算数的和为 $2^w$ 或者更大时，就发生了溢出。

当执行 C 程序时，不会将溢出作为错误而发出信号。不过有时候，可能希望判定是否发生了溢出。

模数加法形成了一种数学结构，称为 __阿贝尔群__ (Abelian group)，也就是说，它是可交换和可结合的。它有一个单位元 0，并且每个元素都有一个加法逆元。

考虑 w 位的无符号数的集合，执行加法运算 $+_w^u$，对于每个值 x，必然有某个值 $-_w^ux$ 满足 $-_w^ux+_w^ux=0$。因此它就是 x 在 $+_w^u$ 下的逆元

```math
-_w^u x = 
\begin{cases}
x,      x = 0 \\\\
2^w-x,  x > 0
\end{cases}
```

### 补码加法

两个数的 w 位补码之和与无符号之和有完全相同的位级表示。实际上，大多数计算机使用同样的机器指令来执行无符号或者有符号加法。

范围在 $-2{w-1} \leq x, y \leq 2^{w-1}-1$ 之内的 x 和 y 实施运算 $+_w^t$ 时，有下面这样的表达式：
```math
x +_w^t y = 
\begin{cases}
x+y-2^w,      2^{w-1} \leq x + y 正溢出  \\\\
x+y,          -2{w-1} \leq x + y \leq 2^{w-1}-1 正常 \\\\
x + y + 2^w,  x + y \leq - 2^{w-1} 负溢出
\end{cases}
```
当 x 和 y 都是负数，但是 x $+_w^t$ y > 0 时，就会得到负溢出
当 x 和 y 都是正数，但是 x $+_w^t$ y < 0 时，就会得到正溢出


### 补码的非

定义在 $-2{w-1} \leq x, y < 2^{w-1}$ 之内的 x，补码的非运算（negation operation）$-_w^t$ 如下：
```math
-_w^t x = 
\begin{cases}
-2^{w-1},     x = -2^{w-1} \\\\
-x,           x > -2^{w-1}
\end{cases}
```
-x = $2{w-1}$ 不能表示成一个 w 位的数。因此声明，这个特殊数本身就是它在 $-_w^t$ 下的加法逆元。

求位级补码非
- 第一种方法是对每一位求补，再对结果加 1。在 C 语言中，可以确定对于任意整数值 x，计算表达式 -x 和 $\sim x + 1$ 得到的结果完全一样。
- 第二种方法是建立在将位向量分为两部分的基础之上的，假设 k 是最右边的 1 位置，因而 x 的位级表示形如 $[x_{w-1},x_{w-2},\cdots,x_{k+1},1,0,\cdots,0]$。这个值的非写成二进制格式就是 $[\sim x_{w-1},\sim x_{w-2},\cdots,\sim x_{k+1},1,0,\cdots,0]$。也就是对位置 k 左边的所有位取反。


### 无符号数乘法

C 语言中的无符号乘法被定义为产生 w 位的值，就是 2w 位的整数乘积的低 w 位表示的值。可以看作等价于计算乘积模 $2^w$

```math
x *_w^u y = (x\cdot y) \mod 2^w
```

### 补码乘法

对于无符号和补码乘法来说，乘法运算的位级表示都是一样的。设 $x=B2T_w(\overrightarrow x)$ 和 $y=B2T_w(\overrightarrow y)$是这些位模式表示的补码值，而 $x'=B2U_w(\overrightarrow x)$ 和 $y'=B2U_w(\overrightarrow y)$ 是这些位模式表示的无符号值。根据等式 2-5 有 $x'=x+x_{w-1}2^w$ 和 $y'=y+y_{w-1}2^w$ 。计算这些值的乘积模 $2^w$ 得到以下结果：
```math
(x'\cdot y') = [(x+x_{w-1}2^w)\cdot (y+y_{w-1}2^w)] \mod 2^w \\\\
= [x\cdot y + (x_{w-1}y+y_{w-1}x)2^w + x_{w-1}y_{w-1}2^{2w}] \mod 2^w \\\\
= (x\cdot y) \mod 2^w
```

### 乘以常数

大多数机器上，整数乘法指令相当慢，需要 10 个或更多的时钟周期，然而其他的整数运算（例如加法、减法、位即运算和移位）只需要一个时钟周期。

因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。


### 除以2的幂

大多数机器上，整数除法要比整数乘法更慢，需要 30 个或更多的时钟周期。除以 2 的幂也可以用移位操作来实现。只不过使用右移。

对一个无符号数的逻辑右移和除以 $2^k$ 有一样的效果。证明(后续补充)


### 关于整数运算的思考

计算机执行的“整数”运算时间上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。

补码表示提供了一种即能表示负数也能表示整数的灵活方法，同时使用了与执行无符号算术相同的位级实现。

C 语言中的某些规定可能会产生令人意想不到的结果，而这些可能是难以察觉和理解的缺陷的源头。


## 浮点数

浮点表示对形如 $V=x \times 2^y$ 的有理数进行编码。它对执行涉及非常大的数字(|V|>>0)、非常接近与 0(|V|<<1)的数字，以及更普遍的作为实数运算的近似值的计算。

IEEE Standard 754，是浮点数及其运算的标准。这个提高了科学应用程序在不同计算机上的可移植性。


### 二进制小数

一个形如 $b_mb_{m-1}\cdots b_1b_0.b_{-1}b_{-2}\cdots b_{-n+1}b_{-n}$ 的表示法，其中每个二进制数字，或者称为位，$b_i$ 的取值范围是 0 和 1，这种表示方法表示的数 b 定义如下：
```math
b = \sum_{i=-n}^{m} 2^i \times b_i
```
考虑有限长度的编码，那么十进制表示法不能准确的表达像 $\frac{1}{3}$ 和 $\frac{5}{7}$ 这样的数。类似的，小数的二进制表示法只能表示那些能够被写成 $ \times 2^y$  的数。其他的值只能够被近似的表示。


### IEEE 浮点表示

IEEE 浮点标准用 $V=(-1)^s \times M \times 2^E $ 的形式表示一个数：
- 符号 sign s 决定这个数是负数还是正数
- 尾数 significand M 是一个二进制小数，它的范围是 $1 ~ 2 - \epsilon$ 或者 $0 ~ 1 - \epsilon$
- 阶码 exponent E 的作用是对浮点数加权，这个权重是 2 的 E 次幂

将浮点数的位划分为三个字段，分别对这些值进行编码：
- 一个单独的符号位 s 直接编码符号 s
- k 位的阶码字段 $exp=e_{k-1}\cdots e_1e_0$ 编码阶码 E
- n 位小数字段 $frac=f_{n-1}\cdots f_1f_0$ 编码尾数 M，但是编码出来的值也依赖与阶码的字段的值是否等于 0。

单精度数中 s，exp，frac 分别位 1, 8， 23 位
双精度数中 s，exp，frac 分别位 1, 11， 52 位

根据 exp的值，被编码的值可以分为三种不同情况

- 规格化值
- 非规格化值
- 特殊值


有 k 位阶码和 n 位小数的浮点数表示的一般属性：
- 值 +0.0 总有一个全为 0 的位表示。
- 最小的正非规格化值的位表示，是由最低有效位为 1 而其他所有位为 0 构成的。它具有小数（和尾数）值 $M=f=2^{-n}$ 和阶码值 $E=-2^{k-1}+2$。因此它的数字值是 $V=2^{-n-2^{k-1}+2}$。


### 舍入

对于浮点数 x，用一种系统的方法，能够找到“最接近的” 匹配值 x‘，它可以用期望的浮点形式表示出来。这就是舍入(rounding)运算的任务。

IEEE 浮点数定义了四种不同的舍入方式。默认的方式是找到最接近的匹配，而其它三种可用于计算上界和下界。

四种不同的舍入方式：向偶数舍入、向零舍入、向下舍入、向上舍入



### 浮点运算


### C 语言中的浮点数

所有的 C 语言版本提供了两种不同的浮点数数据类型：float 和 double。对应于单精度和双精度。因为 C 语言标准不要求机器使用 IEEE 浮点，所有没有标准的方法来改变舍入方式或者得到诸如 -0、$+\infty$、$-\infty$ 或者 NaN 之类的特殊值。



# 程序的机器级表示

对于严谨的程序员，能够阅读和理解汇编代码人是一项很重要的技能：
- 能够理解编译器的优化能力，并分析代码中隐含的低效率

- 当用线程包写并发程序时，知道存储器保存不同的程序变量的区域是很重要的。这些信息在汇编代码级是可见的。

- 程序遭受攻击的许多方式中，都涉及程序存储运行时控制信息的细节。

程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时只要求程序员能直接用汇编语言编写程序， 现在则是要求他们能够阅读和理解编译器产生的代码。



## 历史观点


## 程序编码

gcc 调用了一系列程序，将源代码转换为可执行代码：
- 首先，__C 预处理器__ 扩展源代码，插入所有用 `#include` 命令指定的文件，并扩展所有用 `#define` 声明指定的宏。

- 然后 __编译器__ 产生源代码的汇编代码。后缀名 `.s`。

- 接下来， __汇编器__ 将汇编代码转换成二进制目标代码文件，缀名 `.o`。
  目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入地址的全局值。

- 最后，__链接器__ 将目标代码文件与实现库函数的代码合并，并产生最终可执行代码文件。


### 机器级代码

计算机系统使用了多种不同形式的抽象。利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，两种抽象尤为重要：
- 机器级程序的格式和行为，定义为指令集体系结构 (Instruction set architecture, ISA)，它定义了处理器状态、指令的格式以及每条指令对状态的影响

- 机器级程序使用的存储地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组。存储器的实际实现是将多个硬件存储器和操作系统软件组合起来



### 代码示例
> code/sum.c


### 关于格式的注解

所有以 ‘.’ 开头的行都是指导汇编器和链接器的命令，通常可以忽略这些行。

ATT 和 intel 使用不同的汇编格式，默认情况下，使用 ATT 的汇编格式


## 数据格式

由于从 16 位体系结构扩展成 32 位，intel 用术语 ”字“ (word) 表示 16 位数据类型。因此 32 位数为 “双字” (double word)，称 64 位数为 “四字” (quad words)。

大多数 GCC 生成的汇编代码指令都有一个字符后缀，表明操作数的大小。例如数据传送指令有三个变种：movb 传送字节、movw 传送字、movl 传送双字

汇编代码使用后缀 'l' 来表示 4 字节整数和 8 字节双精度浮点数。


## 访问信息

一个 IA32 中央处理单元 CPU 包含一组 8 个存储 32 位值的寄存器。这些存储器用来存储整数数据和指针。它们的名字都以 %e 开头，不过它们都另有特殊的名字。在平坦寻址中，对特殊寄存器的需求已经极大的降低。

在大多数情况下，前 6 个寄存器都可以看成通用寄存器，对它们的使用没有限制。说“大多数情况”，是因为有些指令以固定的寄存器作为源寄存器 和/或 目的寄存器。另外在处理过程中，对前 3 个寄存器 (%eax, %ecx, %edx) 的保存和恢复惯例不同于接下来的 3 个寄存器 (%ebx, %edi, %esi)。最后两个寄存器 (%ebp, %esp) 保存着指向程序栈中最重要位置的指针。只有根据栈管理的标准惯例才能修改这两个寄存器中的值。

字节操作指令可以独立的读或写前 4 个寄存器的 2 低位字节。例如 %eax 读取全部 32 位(31~0)，则 %ax读取后 16 位(15~0)，%ah 读取 15~0 位 %al 读取最后 8 位(7~0)


### 操作数指示符

大多数指令有一个或多个操作数 (operand)，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。

各种不同的操作数的可能性被分为三种类型：
- 立即数 immediate，也就是常数值。立即数的书写方式是 '$' 后面跟一个用标准 C 表示法表示的整数
- 寄存器 register，它表示某个寄存器的内容
- 存储器 memory 引用，它会根据计算出来的地址访问某个存储器位置。


图3-3(略) 操作数的多种格式，包括立即数寻址、寄存器寻址、绝对寻址、间接寻址、变址寻址、比例变址寻址


### 数据传送指令

将数据从一个位置复制到另一个位置的指令是最频繁使用的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条指令才能完成的功能。

- MOV类由三条指令组成，分别传送1，2 和 4 字节的数据上进行操作
  - IA32 加了一条限制，传送指令的两个操作数不能都指向存储器位置。

- MOVS 和 MOVZ 类指令都是将一个较小的源数据复制到一个较大的数据位置，高位用符号位扩展或者零扩展进行填充。

- 最后两个数据传输操作可以将数据压入程序栈中，以及从程序栈中弹出数据。

在 IA32 中程序栈存放在存储器中某个区域，栈向下增长，这样栈顶元素的地址是所有栈中元素地址中 __最低__ 的。根据惯例，栈是倒过来画的，栈"顶"在图的底部。栈指针保存这栈顶元素的地址。
- 所以压栈 push 指令是减小栈指针 (寄存器 %esp) 的值，并将数据存放在存储器中，
- 而出栈 pop 指令是从存储器中读，并增加栈指针的值。


### 数据传送示例

```c
int exchange(int *xp, int y) {
  int x = *xp
  *xp = y
  return x;
}
```

```asm
// xp at % ebp+8, y at %ebp+12
movl 8(%ebp), %edx    // get xp

movl (%edx), %eax     // Get x at xp
movl 12(%ebp), %eca   // Get y
movl %ecx, (%edx)     // Store y at xp
```


## 算术和逻辑操作

大多数操作都分成了指令类，这些指令类有各种带不同操作数的变种。给出的每个指令类都有对字节、字和双字数据进行操作的指令。

这些操作被分为四组：加载有效地址、一元操作、二元操作及移位


指令| 效果 | 描述 
|---|---|---|
leal S,D | $D \leftarrow \&S$ | 加载有效地址
||
INC D | $D \leftarrow D + 1$ | 加 1
DEC D | $D \leftarrow D - 1$ | 减 1
INC D | $D \leftarrow - D$ | 取负
INC D | $D \leftarrow \~D$ | 取补
||
ADD S, D | $D \leftarrow D + S$ | 加
SUB S, D | $D \leftarrow D - S$ | 减
IMUL S, D | $D \leftarrow D * S$ | 乘
XOR S, D | $D \leftarrow D ^ S$ | 异或
OR S, D | $D \leftarrow D \| S$ | 或
AND S, D | $D \leftarrow D \& S$ | 与
||
SAL k，D | $D \leftarrow D << k$ | 左移
SHL k，D | $D \leftarrow D << k$ | 左移 等同于 SAL
SAR k，D | $D \leftarrow D >>_A k$ | 算术右移
SHR k，D | $D \leftarrow D >>_L k$ | 逻辑右移

注 imull 指令为双操作数乘法指令，它从两个 32 位操作数产生一个 32 位乘积。

### 加载有效地址

__加载有效地址__ (load effective address) 指令实际上是 movl 指令的变形。它的形式是从存储器读数据到寄存器，但实际上它根本没有引用存储器。目的操作数必须是一个寄存器

加载有效地址 (leal) 指令通常用来执行简单的算术操作。


### 一元操作和二元操作

一元操作，它只有一个操作数，即是源又是目的。这个操作数可以是一个寄存器，也可以是一个存储器位置。

二元操作，其中第二个操作数即是源又是目的。第一个操作数可以是立即数、寄存器或是存储器位置。第二个操作数可以是寄存器或是存储器位置。同 movl 指令一样，两个操作数不能同时是存储器位置。


### 移位操作

先给出移位量，然后第二项给出的要移位的数值。可以进行算术或逻辑右移。移位量用单个字节编码，因为只允许进行 0 到 31 位的移位。移位量可以是立即数，或者放在单字节寄存器元素 %cl 中。移位操作的目的操作数可以是一个寄存器或是一个存储器位置。


### 特殊的算术操作

相比较于上节所述的 imull 双操作数实现 32 位乘法指令，IA32 还提供了两个不同的单操作数指令，以计算两个 32 位值的全 64 位乘积。指令都要求一个参数必须在寄存器 %eax 中，而另一个作为指令的源操作数给出，然后乘积存放在寄存器 %edx (高32位) 和 %eax (低32位) 中。

指令| 效果 | 描述 
|---|---|---|
imull S | R[%edx]:R[%eax] $\leftarrow$ S $\times$ R[%eax] | 有符号全 64 位乘法
mull S | R[%edx]:R[%eax] $\leftarrow$ S $\times$ R[%eax] | 无符号全 64 位乘法
||
cltd | R[%edx]:R[%eax] $\leftarrow$ SignExtend(R[%eax]) | 转为四字
||
idivl S | R[%edx] $\leftarrow$ R[%edx]:R[%eax] mod R[%eax] <br> R[%eax] $\leftarrow$ R[%edx]:R[%eax] $\div$ R[%eax]  | 有符号除法
||
divl S | R[%edx] $\leftarrow$ R[%edx]:R[%eax] mod R[%eax] <br> R[%eax] $\leftarrow$ R[%edx]:R[%eax] $\div$ R[%eax]  | 无符号除法

注：一对寄存器 %edx 和 %eax 组成一个 64 位的四字


## 控制

机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。


### 条件码

除了整数寄存器，CPU 还维护一组单个位的条件码 (Condition Code) 寄存器 最常用的条件码有：
- CF：进位标志。 最近的操作使最高为产生了进位。
- ZF：进位标志。 最近的操作得出的结果为 0
- SF：零标志。最近的操作得到的结果为负数
- OF：溢出标志。最近的操作导致一个补码溢出

leal 不改变任何条件码，因为它是用来进行地址计算的。除此之外，算术和逻辑操作指令都会设置条件码。

除了上述指令外，有两类指令它们只设置条件码，不改变任何其他寄存器。

指令| 基于 | 描述 
|---|---|---|
CMP $S_1,S_2$ | $S_1 - S_2$ | 比较
||
cmpb | Compare byte |
cmpw | Compare word |
cmpl | Compare double word |
||
TEST $S_1,S_2$ | $S_1 \& S_2$ | 测试


### 访问条件码

条件码通常不会直接读取，常用的使用方法有三种：
- 可以根据条件码的某个组合，将一个字节设置为 0 或 1
- 可以条件跳转到程序的某个其他的部分
- 可以有条件的传送数据

这一整类指令称为 SET 指令，它们的区别就在于考虑的条件码的组合是什么。

一条 SET 指令的目的操作数是 8 个单字节寄存器元素之一，或者是存储一个字节的存储器位置，将这个字节设置成 0 或 1。


### 跳转指令及其编码

正常执行的情况下，指令按照它们出现的顺序一条一条执行。__跳转__ (jump) 指令会导致执行切换到程序中一个全新的位置。这些跳转的目的地址通常用一个标号 (label) 指明。

jmp 指令是无条件跳转，它可以直接跳转，即跳到目标作为指令的一部分编码；也可以是间接跳转，即跳转目标是从寄存器或存储位置中读出的。

除 jmp 外，其他跳转指令都是有条件的，它们根据条件码的组合，或者跳转，或者继续执行代码序列中的下一条指令。

跳转指令有几种不同的编码，但是最常用的都是程序计数器相关的。
- 它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。
- 第二种编码方法是给出“绝对”地址，用 4 个字节直接指定目标。


### 翻译条件分支

将条件表达式和语句从 C 语言翻译成机器代码，最常用的方法是结合有条件和无条件跳转

C 语言中的 $if-else$ 语句的通用形式模板是这样的：
```
if (test-expr)
  then-statement
else
  else-statement
```

对于这种通用形式，汇编实现通常会使用下面这种形式，
```
  t = test-expr
  if (!it)
    goto false;
  then-statement
  go done;
false
  else-statement
done:
```
也就是，汇编器为 then-statement 和 else-statement 产生各自的代码块。


### 循环

C 语言提供了多种循环结构，即 do-while、while 和 for。汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。


#### do-while 循环

do-while 语句的通用形式如下：


#### while 循环


#### for 循环


### 条件传送指令

实现条件控制的传统方法是利用控制的条件转移。当条件满足时，程序沿着一条执行路径进行，而当条件不满足时，就走另一条路径。但是在现代处理器上，_它可能非常低效_

数据的条件转移时一种替代的策略。关键在于 cmovl 指令，在指定条件满足时才执行数据传送之外，它的语法与 MOV 指令相同。基于条件创送的代码比基于条件控制转移的代码性能好。处理器通过使用流水线来获得高性能。

__条件传送指令__

指令| 同义者 | 传送条件 | 描述 
|---|---|---|---|
cmove S, R | cmovz | ZF | 相等/零
cmovne S, R | cmovnz | ~ZF | 不相等/非零
|||
cmovs S, R | | SF | 负数
cmovns S, R | | ~SF | 负数
|||
cmovg S, R | cmovnle | ~(SF ^ OF) & ~ZF | 大于(有符号>)
cmovge S, R | cmovnl | ~(SF ^ OF) | 大于或等于(有符号>=)
cmovl S, R | cmovnge | (SF ^ OF) | 小于(有符号 <)
cmovle S, R | cmovng | (SF ^ OF)|ZF | 小于等于(有符号<=)
|||
cmova S, R | cmovnbe | ~CF & ~ZF | 超过(无符号>)
cmovae S, R | cmovnb | ~CF | 超过或等于(无符号>=)
cmovb S, R | cmovnae | CF | 低于(无符号 <)
cmovbe S, R | cmovna | CF|ZF | 低于等于(无符号<=)



### switch 语句

switch 开关语句可以根据一个整数索引值进行多重分支 (multiway branching)。不仅提高了代码的可读性，而且使用 __跳转表__ (jump table) 这种数据结构时的实现更加高效。跳转表是一个数组，表项 i 是一个代码段的地址，这个代码段实现当开关索引值等于 i 时程序应该采取的动作。

GCC 的作者们创造了一个新的运算符 &&，这个运算符创建一个指向代码位置的指针。


## 过程

一个过程调用包括将数据和控制从代码的一部分传递到另一个部分。另外它还在进入时为过程局部变量分配空间，并在退出时释放这些空间。

大多数机器，只提供转移控制到过程或从过程中转移出控制这种简单的指令。数据传递、局部变量的分配和释放通过操纵程序栈来实现。

### 栈帧结构

机器用栈来传递参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。为单个过程分配的那部分栈称为 __栈帧__ (stack frame)。最顶端的栈帧以两个指针界定，寄存器 %ebp 为帧指针，而寄存器 %esp 为栈指针。

调用者过程 P 调用过程 Q，则 Q 的参数放在 P 的栈帧中。另外，当 P 调用 Q 时，P 中的返回地址被压入栈中，形成 P 的栈帧的末尾。返回地址就是当程序从 Q 返回时应该继续执行的地方。Q 的栈帧从保存的寄存器 %ebp 的副本开始。


### 转移控制

支持过程调用和返回的指令

指令| 描述 
|---|---|
call Label | 过程调用
call *Operand | 过程调用
leave | 为返回准备栈
ret | 从过程调用中返回

返回地址是当前程序计数器 %eip 中下一条指令的地址，执行 call 命令时，将 %eip 指定当前 call 指令地址的下一条指令地址压入栈中。

leave 指令可以使栈做好返回准备。它等价于下面代码
```
movl %ebp, %esp
pop %ebp
```

另外i也可以通过直接使用传送和弹出操作来完成这种准备工作。如果函数要返回整数或指针的话，寄存器 %eax 可以用来返回值。


### 寄存器使用惯例

程序寄存器组是唯一能被所有过程共享的资源。虽然在给定时刻只能有一个过程是活动的，但是必须保证当调用者过程 P 调用被调用的过程 Q 时，被调用者不会覆盖调用者稍后会使用到的寄存器的值。为此，采用了一组寄存器使用惯例，所用的过程都必须遵守，包括程序库中的过程。
- 寄存器 %eax、%edx 和 %ecx 被划分为调用者保存寄存器。当 P 调用 Q 时，Q 可以覆盖这些寄存器，而不会破坏任何 P 所需要的数据。
- 寄存器 %ebx、%esi 和 %edi 被划分为被调用者保存寄存器。这意味着 Q 在覆盖这些寄存器之前，先把它们保存到栈中，并在返回前恢复它们。
- 此外，必须保持寄存器 %esp 和 %ebp。


### 过程示例


### 递归过程

阶乘函数的递归举例，当计算到 n-1，将这个值存储在栈上，然后函数调用自身，在代码的完成部分，可以假设：
- 寄存器 %eax 保存着 (n-1)! 阶乘的值；
- 被调用函数保存寄存器 %ebx 保存着的参数 n。

因此将这两个值相乘得到该函数的返回值

可以看到递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己的私有的状态信息存储。


## 数组分配和访问

C 语言中的数组是一种将标量数据聚集成更大数据类型的方式。

### 基本原则

对于数据类型 T 和整型常数 N，声明如下: $T A[N]$，它有两个效果：
- 首先，它在存储器中分配一个 $L\cdot N$ 字节的连续区域，这里 L 是数据类型的 T 的大小，用 $X_A$ 来表示起始位置
- 其次，它引入了标识符 A；可以 A 作为指向数组开头的指针，这个指针的值就是 $X_A$
- 可以用 0 到 N-1 之间的整数索引来访问数据元素，元素 i 会被存放在地址为 $X_A + L\cdot i$ 的地方。


### 指针运算

数组的引用 A[i] 等同于表达式 *(A+i)，它计算第 i 个数组元素的地址，然后访问这个存储器位置。

表达式| 类型 | 值 | 汇编代码
|---|---|---|---|
E | int* | $X_E$  | movl %edx, %eax
E[0] | int | $M[X_E]$ | movl (%edx), %eax
E[i] | int | $M[X_E + 4i]$ | movl (%edx, %ecx, 4), %eax
&E[2] | int* | $X_E + 8$ | leal 8(%edx), %eax

_注：假设整型数组E 的起始位置和整数索引i分别存放在寄存器 %edx 和%ecx中，结果存放在寄存器 %eax中_


### 嵌套的数组


### 定长数组

C 语言编译器能够优化定长多维数组上的操作代码。例如可以将数据类型 fix_matrix 声明为 16 * 16 的整型数组：
```C
# define N 16
typedef int fix_matrix[N][N]

int fix_prod_ele(fix_matrix A, fix_matrix B, int i, int k) {
  int result = 0;
  for (int j = 0; j < N; j++)
      result += A[i][j] + B[j][k];
}
```

`fix_prod_ele` 方法被编译器优化为：
```C
int fix_prod_ele(fix_matrix A, fix_matrix B, int i, int k) {
  int* Arow = &A[i][0];
  int* Bptr = &B[0][k];
  int result = 0;

  for (int j=0; j < N; j++) {
    result += Arow[j] * *Bptr;
    Bptr == N;
  }
}
```

对于 fix_matrix 类型数据的访问，会包含很多聪明的优化：
- 如果循环只访问 i 行元素，则 Arow 被初始化为 `&A[i][0]`，所以可以通过 `Arow[j]` 访问 `A[i][j]`
- 循环会按照 `B[0][k], B[1][k], ...., B[15][k]` 的顺序访问矩阵 B。从 `B[0][k]` 开始，之间间隔 64字节。
- 在 C语言中，表明这个指针被增加 N(16)，实际地址增加 4 * 16 = 64


### 变长数组

ISO C99 引入了一种能力，允许数组的维度是表达式，在数组分配的时候才计算出来。



## 异质的数据结构

C 语言提供两种结合不同类型的对象来创建数据类型的机制：
- 结构，将多个对象结合到一个单位中，用关键字 `struct` 声明
- 联合，允许用几种不同的类型来引用一个对象，用关键字 `union` 声明

### 结构

```C
struct rect {
  int llx;
  int lly;
  int color;
  int width;
  int height;
};

int area(struct rect *rp) {
  return (*rp).width * (*rp).height;
}

```

表达式 `(*rp).width` 间接引用了这个指针，并且选取所得结果的 width 字段。这里必须要用括号，因为编译器会将表达式 `*rp.width` 解释为 `*(rp.width)`，而这是非法的。这种间接引用非常常见，以至于 C 语言提供了一种表示法 `->` 作为替代。

最后一个例子，下面的代码实现的语句：
```C
r->p = & r->a[r->i + r->j];
```

开始时 r 在寄存器 %edx 中：
```asm
movl 4(%edx), %eax             // Get r->j
addl (%edx), %eax              // Add r->i
leal 8(%edx, %eax, 4), %eax    // Compute &r->a[r->i + r->j]
movl %eax, 20(%edx)            // Store in r->p
```

结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。


### 联合

联合提供一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象。联合的声明和结构的语法一样，但是语义相差比较大。它们是不同字段来引用相同的存储器块。一个联合的总的大小等于它最大字段的大小。


### 数据对齐

许多计算机系统对数据类型合法地址作出限制，要求某种类型对象的地址必须是某个值 K (通常是2, 4, 8) 的倍数。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计。


```C
struct S1 {
  int i;
  char c;
  int j;
};
```

假设编译器用最小的 9 字节分配，它不可能满足 i 和 j 的偏移的 4 字节对齐要求。编译器在 c 和 j 之间插入 3 字节间隙。结果 j 的偏移量为 8，而整个结构的大小为 12 字节。


## 综合：理解指针

- 每个指针都对应一个类型
  - 如果对象类型为 `T`，那么指针类型为 `*T`。
  - 特殊的 `void*` 类型代表通用指针。malloc 函数返回一个通用指针，然后通过强制类型转换或者赋值操作，将它转换成一个有类型的指针。

- 每个指针都有一个值，这个值是特定类型对象的地址
- 指针用 & 运算符创建
- 运算符 * 用于指针的间接引用
- 数组与指针紧密联系
- 将指针从一种类型强制转换成另一种类型，只改变它的类型，不改变它的值
- 指针也可以指向函数。函数指针的值是该函数机器代码表示的第一条指令的地址。


## 应用：使用 GDB 调试器



## 存储器的越界引用和缓冲区溢出

对抗缓冲区溢出攻击
- 栈随机化
  一个程序的栈空间是确定的，这种现象称为安全单一化 security monoculture。在 Linux 系统中，栈随机化是更大类技术，称为地址空间布局随机化 Address-Space Layout Randomization，或者简称 ASLR 中的一种。

- 栈破坏检测
  计算机的第二道防线是能够检测到何时栈已经被破坏。
  最近的 GCC 版本在代码中加入一种栈保护者机制，用来检测缓冲区越界。其思想在栈帧中任何局部变量和栈状态之间存储一个特殊的金丝雀 canary 值，这个值也成为哨兵值 guard value，是在程序每次运行时随机产生的。

- 限制可执行代码区域
  消除攻击者向系统中插入可执行代码的能力。



## x86-64：将 IA32 扩展到 64 位

### x86-64 简介

x86-64 与 IA32 机器生成代码有极大的不同。主要特征如下：
- 指针和长整数 64 位。整数运算支持 8, 16, 32, 64 位数据类型。
- 通用寄存器数量从 8 个扩展到 16 个
- 许多程序状态保存在寄存器中，而不是栈上
- 如果可能，条件操作用条件传送指令实现，会比传统代码分支更好的性能
- 浮点操作面向寄存器的指令集来实现


### x86-64 访问信息

所有的寄存器都是 64 位长，IA32 寄存器的 64 位扩展分别命名位 %rax, %rcx, %rdx, %rbx, %rsi, %rdi, %rsp, %rbp, 新增的寄存器命名为 %r8～ %r15

可以直接访问寄存器的低 32 位，即 IA32 熟悉的寄存器 %eax, ..., %ebp, 以及新增的 %r8d～ %r15d

同时可以直接访问寄存器的低 16, 8 位。

寄存器 %rsp 有特殊的状态，它会保存指向栈顶元素的指针。与 IA32 不同的是，没有帧指针寄存器； 可以用寄存器 %rbp 作为通用寄存器。通过寄存器传递过程参数以及调用过程中如何保存和恢复寄存器都有特殊规定。此外，有一些算术指令对寄存器 %rax 和 %rdx 有特殊的用法。

x64 中程序计数器命名为 %rip。


__数据传送指令__

指令| 效果 | 描述 
|---|---|---|
movabsq I, R | R $\leftarrow$ S I | 传送绝对四字
||
MOV S, D | D $\leftarrow$ S | 传送
movq | 传送四字 |
||
MOVS S, D | D $\leftarrow$ SignExtend(S) | 符号扩展传送
movsbq  | 符号扩展字节传送四字 |
movswq  | 符号扩展字传送四字 |
movslq  | 符号扩展双字传送四字 |
||

_注 末尾 q 为 quarter，代表四个字_

这些指令是对 IA32 的传送指令的补充。


__特殊的算术指令__

指令| 效果 | 描述 
|---|---|---|
imulq  S | R[%rdx]:R[%rax] $\leftarrow$ S $\times$  R[%rax] | 有符号全乘法
mulq  S | R[%rdx]:R[%rax] $\leftarrow$ S $\times$  R[%rax] | 无符号全乘法
cltq  | R[%rax] $\leftarrow$ SignExtend(R[%eax]) | 将 %eax 转换为四字
clto  | R[%rdx]:R[%rax] $\leftarrow$ SignExtend(R[%rax]) | 转换为八字


这些运算支持有符号和无符号数的全 64 位乘法和除法。将寄存器对 %rdx 和 %rax 看作一个 128 位的八字。


### 控制

x86-64 中实现控制转移的控制指令和方法与 IA32 一样。增加的两条新指令 cmpq 和 testq，用来比较和测试四字，是对字节、字、双字大小指令的扩充。

__过程__

x86-64 实现过程不再需要依赖于栈来存储和获取过程信息，实现的重点：
- 参数（最多前6个）通过寄存器传递到过程，而不是在栈上。这消除了在栈上存储和检索值的开销

- callq 指令将一个 64 位返回地址存储在栈上

- 许多函数不需要栈帧，只有那些不能将所有的局部变量都存放在寄存器的函数才需要在栈上分配空间。

- 函数最多可以访问超过当前栈指针 128 个字节的栈上存储空间（地址低于当前栈指针的值）。这允许一些函数将信息存储在栈上而无需修改栈指针

- 没有帧指针。作为替代堆栈位置的引用相对于栈指针。大多数函数在调用开始时分配所与需要好的整个栈春出，并保持栈指针指向固定位置。

__参数传递__

最多可以有 6 个整型参数可以通过寄存器进行传递。寄存器按照指定的顺序来使用，使用的寄存器名对应与所传递的数据的大小。


操作数大小<br>(位)| 参数1 | 参数2 | 参数3 | 参数4 | 参数5 | 参数6
|:-:|---|---|---|---|---|---|
64 | %rdi | %rsi | %rdx | %rcx | %r8 | %r9
32 | %edi | %esi | %edx | %ecx | %r8d | %r9d
16 | %di | %si | %dx | %cx | %r8w | %r9w
8 | %dil | %sil | %dl | %cl | %r8b | %r9b


__栈帧__

函数可能需要栈帧的原因有：
- 局部变量太多，不能都放在寄存器中

- 有些局部变量是数组或结构

- 函数用取地址操作符 (&) 来计算一个局部变量的地址

- 函数必须将栈上的某些参数传递到另一个函数

- 在修改一个被调用者保存寄存器之前，函数需要保存他的状态。

与 IA32 栈指针会随着值的压入和弹出会不断的前后移动，但是 x86-64 过程的栈帧通常有固定的大小，在过程开始通过减少栈指针 (寄存器 %rsp) 来设置。在调用过程中栈指针保持在固定位置，是的可以用相对于栈指针的偏移量来访问数据，因此就不再需要 I32 代码中的可见的帧指针了。


__寄存器保存惯例__

在 x86-64 中，指定为被调用者保存的寄存器有：%rbx, %rbp 和 %r12～%r15 。

x86-64 的一个不同寻常的特性是能够访问栈指针之外的存储器。它要求将虚拟存储器管理系统为这段区域分配存储器。x86-64 ABI 指明程序可以使用当前栈指针之外 128 字节的范围。ABI 将这个区域称为红色地带 (red zone)。 必须保持当栈指针移动时，红色地带可读可写。



