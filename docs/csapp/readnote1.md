[toc]

# 信息的表示和处理

## 整数的表示

### 无符号数的编码

### 补码的编码 two's-complement

- 有符号数的其他表示方法：
  - 反码 One's Complement
  - 原码 Sign-Magnitude

> 虽然过去生产过基于反码表示的机器，但是几乎所有现代机器都使用补码


### 有符号数和无符号数之间的转换
- 对大多数 C 语言而言，处理同样字长的有符号数和无符号数之间的相互转换的一般规则是，数值可能会改变，但是位模式不变。
- 当执行一个运算时，如果一个数是有符号的，而另一个数是无符号的，那么 C 语言会隐式的将有符号参数强制转换为无符号数，并假设这两个数都是非负的，来执行这个运算。
- C 头文件 limits.h 对 TMIN TMAX 的写法：
```c
# define INT_MAX 2147483647
# define INT_MIN (-2147483647-1)
```
补码表示的不对称性和 C 语言转换规则之间这种奇怪的交互，迫使我们用这样的不寻常的方式来写 TMIN。


### 扩展即一个数字的位表示

一种常见的运算是不同字长的整数之间的转换，同时又保持数值不变。

- 零扩展 zero extension，需要简单的在表示的开头添加 0 
- 符号扩展，sign extension，规则是在表示中添加最高有效位的一个副本


### 截断数字

假设不用额外的位来扩展一个数值，而是减少一个数字的位数。

对于一个无符号数字 x，截断它的 k 位的结果就相当于计算 $x\mod 2^k$，即丢弃掉高 w-k 位。($2^{k+} \mod 2^k = 0 $)
对于一个有符号数 x，截断它的 k 位的结果相当于先进行无符号数字的截断，在将无符号数转换为有符号数。位模式不变，数值改变。

```c
int x = 53191;
short sx = (short) x; /* -12345 */
int y = sx;           /* -12345 */
```

### 关于有符号数与无符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且很难被发现。


## 整数运算

### 无符号加法

现在定义参数 x 和 y 的运算 $+_w^u$，这里 $0\leq x, y\leq 2^w$，如下：
```math
x +_w^u y = 
\begin{cases}
x+y,      x + y \leq 2^w \\\\
x+y-2^w,  2^w\leq x+y\leq 2^{w+1}
\end{cases}
```

一个算术运算溢出，是指完整的整数结果不能放到数据类型的字长限制中去。所以当两个运算数的和为 $2^w$ 或者更大时，就发生了溢出。

当执行 C 程序时，不会将溢出作为错误而发出信号。不过有时候，可能希望判定是否发生了溢出。


### 补码加法

两个数的 w 位补码之和与无符号之和有完全相同的位级表示。实际上，大多数计算机使用同样的机器指令来执行无符号或者有符号加法。

范围在 $-2{w-1} \leq x, y \leq 2^{w-1}-1$ 之内的 x 和 y 实施运算 $+_w^t$ 时，有下面这样的表达式：
```math
x +_w^t y = 
\begin{cases}
x+y-2^w,      2^{w-1} \leq x + y 正溢出  \\\\
x+y,          -2{w-1} \leq x + y \leq 2^{w-1}-1 正常 \\\\
x + y + 2^w,  x + y \leq - 2^{w-1} 负溢出
\end{cases}
```
当 x 和 y 都是负数，但是 x $+_w^t$ y > 0 时，就会得到负溢出
当 x 和 y 都是正数，但是 x $+_w^t$ y < 0 时，就会得到正溢出


### 补码的非

定义在 $-2{w-1} \leq x, y < 2^{w-1}$ 之内的 x，补码的非运算（negation operation）$-_w^t$ 如下：
```math
-_w^t x = 
\begin{cases}
-2^{w-1},     x = -2^{w-1} \\\\
-x,           x > -2^{w-1}
\end{cases}
```
-x = $2{w-1}$ 不能表示成一个 w 位的数。因此声明，这个特殊数本身就是它在 $-_w^t$ 下的加法逆元。

求位级补码非
- 第一种方法是对每一位求补，再对结果加 1。在 C 语言中，可以确定对于任意整数值 x，计算表达式 -x 和 $\sim x + 1$ 得到的结果完全一样。
- 第二种方法是建立在将位向量分为两部分的基础之上的，假设 k 是最右边的 1 位置，因而 x 的位级表示形如 $[x_{w-1},x_{w-2},\cdots,x_{k+1},1,0,\cdots,0]$。这个值的非写成二进制格式就是 $[\sim x_{w-1},\sim x_{w-2},\cdots,\sim x_{k+1},1,0,\cdots,0]$。也就是对位置 k 左边的所有位取反。


### 无符号数乘法



