[toc]

# 处理器体系结构
一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构 (Instruction-Set Architecture, ISA)。 不同的处理器家族都有不同的 ISA。一个程序编译成在一种机器上运行，就不能在另一种机器上运行。

- 从智力方面来说，处理器设计是非常有趣而且很重要的。处理器设计包括许多好的工程实践原理。它需要完成复杂的任务，而结构又要尽可能简单和规则。

- 理解处理器如何工作能帮助理解整个计算机系统如何工作。

- 虽然很少有人设计处理器，但是许多人设计包含处理器的硬件系统。

本章定义一个简单的指令集，作为处理器实现的运行示例，称之为 Y86 指令集。


## Y86 指令集体系结构
定义一个指令集体系结构，包括定义各种状态元素、指令集和它们的编码、一组编码规范和异常事件处理。


### 程序员可见的状态
程序员可见状态包括：程序寄存器、条件码、FC、程序状态 Stat、存储器及 PC


### Y86 指令
Y86 指令基本上是 IA32 指令集的一个子集。它只包括四字节整数操作。指令包括：
字节 | 0 | 1 | 2 | 3 | 4 | 5 
|---|---|---|---|---|---|---|
halt | 0 1 | | | | |
nop  | 1 0 | | | | |
rrmovl rA, rB | 2 0 | rA rB | | | |
irmovl V, rB | 3 0 | F rB | V | V | V | V |
rmmovl rA, D(rB) | 4 0 | rA rB | D | D | D | D |
mrmovl D(rB), rA | 5 0 | rA rB | D | D | D | D |
OP1 rA, rB | 6 fn | rA rB |
jXX Dest | 7 fn | D | D | D | D |
cmovXX rA, rB | 2 fn | rA rB | | | |
call Dest | 8 0 | D | D | D | D |
ret  | 9 0 | | | | |
pushl rA  | A 0 | rA F | | | |
popl rA  | B 0 | rA F | | | |


### 指令编码
每条指令需要 1～6 个字节不等，这取决于需要哪些字段。每条指令的第一个字节表面指令的类型。这个字节分为两个部分：高 4 位是代码 (code) 部分，低 4 位是功能 (function) 部分。


### Y86 异常
对 Y86 来说，程序员可见状态包括状态码 Stat，它描述程序执行的总体状态。

值 | 名字 | 含义
|---|---|---|
1 | AOK | 正常操作
2 | HLT | 处理器执行 halt 指令
3 | ADR | 遇到非法地址
4 | INS | 遇到非法指令


### Y86 程序


### 一些 Y86 指令的详情




## 逻辑设计和硬件控制语言 HCL
实现一个数字系统需要三那个主要的组成部分：
- 计算对位进行操作的函数组合逻辑
- 存储位的存储器元素
- 控制存储器元素更新的时钟信号


### 逻辑门
逻辑门是数字电路的基本计算元素。他们产生的输出，等于他们输入位值的某个布尔函数。逻辑门总是活动的，一旦一个门的输入变化了，在很短时间内，输出就会相应地变化。


### 组合电路和 HCL 布尔表达式
将很多逻辑门组合成一个网，就能构建计算块 (computational block)，称为组合电路 (combinational circuits)。构建这些网有两条限制：

- 两个或多个逻辑门的输出不能连接在一起。

- 这个网必须是无环的


### 字级的组合电路和 HCL 整数表达式
通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。通常设计能对数据字 (word) 进行操作的电路。例如字的大小有 4 位和 32 位，代表整数、地址、指令代码、和寄存器标识符。

处理器中会用到很多种多路复用器。使得能根据某些控制条件，从许多源中选出一个字。在 HCL 中，多路复用函数是用情况表达式 (case expression) 来描述的。其通用格式如下：

```
[
    select_1 : expr_1
    select_2 : expr_2
    ...
    select_k : expr_k
]
```
这个表达式包含一系列情况，每种情况 i 都有一个布尔表达式 $select_i$ 和一个整数表达式 $expr_i$

一个思路复用器，这个电路根据控制信号 S1 和 S0, 从 4 个输入字 A, B, C, D 中选择一个，将控制信号看作一个两位的二进制数用布尔表达式描述控制位模式的不同组合：
```
int Out4 = [
    !s1 && !s0 : A # 00
    !s1        : B # 01
    !s0        : C # 10
    !s1        : D # 11
]
```

组合逻辑电路可以设计成在字级数据上执行许多不同类型的操作。算术逻辑单元 (ALU) 是一种很重要的组合电路。这个电路有三个输入，标号为 A 和 B 的两个数据输入，以及一个控制输入。


### 集合关系
一个信号与许多可能的匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。例如从一个两位信号 code 中选择高位和低位来为思路复用器产生 S1 和 S0
```
bool s1 = code == 2 || code == 3;
bool s0 = code == 1 || code == 3;
```

还有一种更简洁的方式来表示这样的属性
```
bool s1 = code in {2, 3};
bool s0 = code in {1, 3};
```


### 存储器和时钟
组合电路从本质上讲，不存储任何信息。它只是根据输入信号，产生等于输入的某个函数输出。为了产生时序电路 (sequentail circuit)，须引入按位存储信息的设备。考虑两类存储设备：
- 时钟寄存器，存储单个位或字。时钟信号控制寄存器加载输入值
- 随机访问存储器，存储多个字，用地址来选择读/写哪个字。包括处理器的虚拟存储器系统和寄存器文件

> 注：在硬件和机器级编程时，“寄存器”这个词有细微的差别。在硬件中，寄存器直接将他的输入输出连接到电路的其他部分。在机器级编程中，寄存器代表CPU 中为数不多的可寻址的字，这里的地址是寄存器的ID。避免歧义，分别称为“硬件寄存器” 和 "程序寄存器"

寄存器文件有两个读端口和一个写端口，这样一个多端口随机访问存储器允许同时进行多个读和写操作。如果试图同时读写同一个寄存器会发生什么？答案简单明了，读端口用同一个寄存器，会看到一个从旧值到新值的变化。读端口有个延迟，写端口由时钟信号控制，每次时钟上升时，值写入程序寄存器中。

随机访问存储器和寄存器文件一样，在输入端口和输出控制


## Y86 的顺序实现
SEQ 处理器。每个时钟周期上，SEQ 执行一条完整指令所需的所有步骤。不过这需要一个很长的时钟周期，因此时钟周期频率会低到不可接受。


### 将处理组织成阶段
处理一条指令包括很多操作。将它们组织成某个特殊的阶段序列，即使指令的动作差异很大，但所有指令都遵循唯一的序列。

指令的各阶段及各阶段执行操作：
- 取指 (fetch)
  取指阶段存储器读取指令字节，地址为程序计数器 (PC) 的值
- 译码 (decode)
  译码从寄存器文件读入最多两个操作数
- 执行 (execute)
  在执行阶段，ACL 要么执行指令指明的操作，计算存储器引用的有效地址；要么增加或减少栈指针。
- 访存 (memory)
  在访存阶段可以将数据写入存储器，或者从存储器读出数据。
- 写回 (write back)
  写回阶段最多可以写两个结果到寄存器文件
- 更新 PC (PC update)
  将 PC 设置为下一条指令的地址

处理器无限循环，执行这些阶段。在设计硬件时，一个非常简单而一致的结构非常重要。降低复杂度的一种方法是让不同的指令共享尽量多的硬件。


__跟踪 subl 指令的执行__
阶段 | 通用<br>OP1 rA, rB | 具体<br>subl %edx， %ebx
|---|---|---|
取指 | $icode:ifun\leftarrow M_1[PC]$<br>$rA:rB\leftarrow M_1[PC+1]$<br><br>$valP\leftarrow PC+2$ | $icode:ifun\leftarrow M_1[0x00c]=6:1$<br>$rA:rB\leftarrow M_1[0x00d]=2:3$<br><br>$valP\leftarrow 0x00c+2=0x00e$
译码 |$valA\leftarrow R[rA]$<br>$valB\leftarrow R[rB]$|$valA\leftarrow R[\%edx]=9$<br>$valB\leftarrow R[\%ebx]=21$
执行 |$valE\leftarrow valA\quad OP\quad valB$<br>Set CC|$valE\leftarrow 21-9=12$<br>$ZF\leftarrow 0,SF\leftarrow 0,OF\leftarrow 0$
访存 | | 
写回 |$R[rB]\leftarrow valE$ | $R[\%ebx]\leftarrow valE=12$ 
更新 PC | $PC\leftarrow valP$ | $PC\leftarrow valP=0x00e$ 

> %edx 和 %ebx 初始化成 9 和 21。指令位于地址 0x00c，由两个字节组成，值分别为 0x61 和 0x23


__跟踪 rmmovl 指令的执行__
阶段 | 通用<br>rmmovl rA, D(rB) | 具体<br>rmmovl %esp, 100(%ebx)
|---|---|---|
取指 | $icode:ifun\leftarrow M_1[PC]$<br>$rA:rB\leftarrow M_1[PC+1]$<br>$valC\leftarrow M_4[PC+2]$<br>$valP\leftarrow PC+6$ | $icode:ifun\leftarrow M_1[0x014]=4:0$<br>$rA:rB\leftarrow M_1[0x015]=4:3$<br>$valC\leftarrow M_4[0x016]=100$<br>$valP\leftarrow 0x014+6=0x01a$
译码 |$valA\leftarrow R[rA]$<br>$valB\leftarrow R[rB]$|$valA\leftarrow R[\%esp]=128$<br>$valB\leftarrow R[\%ebx]=12$
执行 |$valE\leftarrow valB+valC$<br>|$valE\leftarrow 12+100=112$<br>
访存 |$M_4[valE]\leftarrow valA$| $M_4[112]\leftarrow 128$
写回 | | 
更新 PC | $PC\leftarrow valP$ | $PC\leftarrow valP=0x01a$ 


> %esp 初始化为 128, %ebx 仍然是 subl 指令算出来的结果 12。指令位于地址 0x014，由 6 个字节组成，前两个值分别为 0x40 和 0x43，后四个是数字 0X00000064 (十进制数 100) 按字节反过来得到的数。


### SEQ 硬件结构
硬件单元与各个处理器阶段相关联
- 取指：将程序计数器寄存器作为地址，指令存储器读取指令的字节。PC 增加器 (PC incrementer) 计算 valP，即增加了程序计数器

- 译码：寄存器文件由两个读端口，从这两个端口同时读取寄存器值 valA 和 valB。

- 执行：执行阶段会根据指令的类型将算术/逻辑单元 ALU 用于不同的目的。
  条件码寄存器 CC 有三个条件码位。 ALU 负责计算条件码的新值。当执行一条跳转指令时，会根据条件码和跳转类型来计算分支信号 Cnd

- 访存：数据存储器读出或写入一个存储器字。指令存储器和数据存储器访问的是相同的存储器位置，但是用于不同的目的。

- 写回：寄存器有两个写端口。端口 E 用来写 ALU 计算出来的值，而端口 M 用来写从数据存储器读出的值。


### SEQ 的时序
SEQ 的实现包括组合逻辑和两种存储器设备：时钟存储器 (程序计数器、条件码寄存器)，随机访问存储器 (寄存器文件、指令存储器和数据存储器)。组合逻辑不需要任何时序或控制器，只要输入变化了，值就会通过逻辑门网络传播。读取随机访问存储器和组合逻辑一样的操作，根据地址产生输出字

对于程序计数器、条件码寄存器、数据存储器和寄存器文件需要对它们的时序进行控制。这些单元通过一个时钟信号来控制，它触发将新值加载到寄存器以及将值写到随机访问存储器。

要控制处理器中活动的时序，只需要寄存器和存储器的时钟控制。遵循以下原则组织计算：_处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。_


### SEQ 阶段的实现
设计实现 SEQ 所需要的控制逻辑块的 HCL 描述。

__表 HCL 描述中使用的常数值__

名称 | 值(十六进制) | 含义
|---|---|---|
INOP | 1 | nop 指令的代码
IHALT | 0 | halt 指令的代码
||
FNONE | 0 | 默认的函数代码
||
RESP | 4 | %esp 的寄存器 ID
RNONE | F | 表明没有寄存器文件访问


> 需要补齐


__1. 取指阶段__
以 PC 作为起始地址，从指令存储器中读出六个字节。根据这些字节，产生出各个指令字段。PC 增加模块计算信号 valP

根据 icode 的值，计算三个一位的信号：
- instr_valid: 这个字节对应一个合法的指令吗？
- need_regids: 这个指令包括一个寄存器指示符字节吗？ 
  当被计算出信号为 1 时，字节 1 被分开装入寄存器指示符 rA 和 rB 中，
  否则这两个字段被设置为 0xF，表明这条指令没有指明寄存器
- need_valC: 这个指令包括一个常数字吗？

PC 增加器硬件单元根据当前的 PC 以及两个信号 need_regids 和 need_valC 的值产生信号 valP。 对于 PC 值 p，need_regids 值 r 和 need_valC 的值 i，增加器产生值 p + 1 + r + 4i


__2. 译码和写回阶段__
实现译码和写回阶段的逻辑的详细情况。把这两个阶段联系在一起，是因为他们都要访问寄存器文件。

寄存器文件有四个端口，它支持同时进行两个读和两个写。每个端口都有一个地址连接和数据连接，地址连接是一个寄存器 ID，而数据连接是一组 32 根线路，既可以作为寄存器文件的输出字，也可以作为它的输入字。

__3. 执行阶段__
执行阶段包括算术/逻辑单元，这个单元根据 alufun 信号的设置，对输入 aluA 和 aluB 执行 ADD，SUBTRACT，AND 或 XOR 运算。


__4. 访存阶段__
访存阶段的任务就是读或者写程序数据。两个控制块产生存储器地址和存储器输入数据的值。访存阶段的最后功能是根据取值阶段产生的值以及数据存储器产生的 dmen_error 信号，从指令执行的结果来计算状态码 Stat


__5. 更新 PC 阶段__
最后一个阶段会产生程序计数器的新值。


__6. SEQ 小结__
通过将执行每条不同指令所需的步骤组织成一个统一的流程，可以用很少量的各种硬件单元以及一个时钟来控制计算的顺序，从而实现整个处理器。控制逻辑必须要在这些单元之间路由信号，并根据指令类型和分支条件产生适当的控制信号。


## 流水线的通用原理
流水线化的俄一个重要特性就是增加了系统的吞吐量 (throughput)，也就是单位时间内服务的总数，不过它也会轻微的增加延迟 (latency)。


### 计算流水线
一个简单的非流水线化的硬件系统，由一些执行计算的逻辑以及一个保存计算结果的寄存器组成，时钟信号控制在每个特定的时间间隔加载寄存器。在现代逻辑设计中，电路延迟也微微秒 (picosecond，简写成 ps)，也就是 $10^{-12}$ 秒为单位来计算；以每秒千兆条指令(GIPS)，也就是每秒十亿条指令为单位来描述吞吐量。


### 流水线操作的详细说明


### 流水线的局限性
会出现一些因素，降低流水线的效率


__1. 不一致的划分__
运行时钟的速率是由最慢阶段的延迟限制的。对硬件设计者来说，将系统计算设计划分成一组具有相同延迟的阶段是一个严峻的挑战。处理器中的某些硬件单元，是不能被划分成多个延迟较小的单元的。这就使得创建一组平衡的阶段非常困难。


__2. 流水线过深，收益反而下降__
为了提高时钟频率，现代处理器采用了很深的流水线。处理器架构师将指令的执行划分成很多非常简单的步骤，这样一来每个阶段的延迟就很小。电路设计者小心的设计流水线寄存器，使其延迟尽可能小。芯片设计者必须小心的设计时钟传播网络，保证时钟在整个芯片上同时改变。


### 带反馈的流水线系统
相邻指令之间存在数据相关(data dependency) 和控制相关(control dependency)。这些相关都是由反馈路径来解决的。


## Y86 流水线实现

### SEQ+:重新安排计算阶段
作为实现流水线设计的一个过渡步骤，稍微调整 SEQ 中五个阶段的顺序，使得更新 PC 阶段在一个时钟周期开始时执行。将这些寄存器标号为 pIcode， pCnd 等等，来指明在任一给定的周期，它们保存的前一个周期中产生的控制信号。

SEQ 到 SEQ+ 中对状态元素的改变是一种通用的改进的例子，成为 _电路重定时(circuit retiming)_。重定时改变了一个系统的状态，但是并不改变它的逻辑行为。通常用它来平衡一个系统中各个阶段之间的延迟。


### 插入流水线寄存器
在 SEQ+ 的各个阶段之间插入流水线寄存器，并对信号重新排列，得到 PIPE- 处理器， 这里的 "-" 代表这个处理器和最终的处理器设计相比，性能要差一点。PIPE- 使用的硬件单元与顺序设计几乎一样，只是有流水线寄存器分隔开这些阶段。

流水线寄存器按以下方式编号：
- F 保存程序计数器的预测值
- D 位于取指和译码阶段之间。它保存关于最新取出的指令的信息，即将由译码阶段进行处理。
- E 位于译码和执行阶段之间。它保存关于最新译码的指令和从寄存器文件读出的值的信息，即将由执行阶段进行处理。
- M 位于执行和访存阶段。它保存最新执行的指令的结果，即将由访存阶段进行处理。它还保存关于用于处理条件转移的分支条件和分支目标的信息。
- W 位于访存阶段和反馈路径之间，反馈路径将计算除了的值提供给寄存器文件写，当完成 ret 指令时，它还要向 PC 选择逻辑提供返回地址。


### 对信号进行重新排列和编号
顺序实现在一个时刻只处理一条指令，在流水线化设计中，与各个指令相关联的这些值有多个版本，会随着指令一起流过系统。作为一个通用原则，保存处于流水线阶段中指令的所有信息。最系统的方法就是让与每条指令关联的状态码与指令一起通过流水线。


### 预测下一个 PC
流水线化设计的目的就是每个时钟周期都发射一条新指令，也就是说每个时钟周期都有一条新指令进入执行阶段并完成。要达到这个目的就意味着吞吐量是每个时钟周期一条指令。因此需要在当前指令之后，马上确定下一条指令的位置。不幸的是，如果取出的指令是条件分支指令，要到几个周期后，也就是指令通过执行阶段之后，才指导是否要选择分支。

猜测分支方向并根据猜测开始取指的技术称为分支预测。Y86 的 PIPE- 设计总使用简单的策略，总是预测选择了条件分支，因此预测 PC 的新值为 valC


### 流水线冒险
将流水线引入带反馈的系统，当相邻的指令间存在香港时会导致出现问题。，这些相关有两种形式：
- 数据相关：下一条指令会用到前一条指令的结果
- 控制相关：一条指令要确定下一条指令的位置

这些相关可能会产生导致流水线产生计算错误，成为 _冒险(hazard)_。 同相关一样，可以分为 _数据冒险_ 和 _控制冒险_

__prog1__
```asm
0x000: irmovl $10, %edx
0x006: irmovl $3, %eax
0x00c: nop
0x00d: nop
0x00e: nop
0x00f: add %edx, %eax
0x011: halt
```

prog1 通过流水线并得到正确的结果，因为 3 条 nop 指令在有数据相关的指令之间创造了一些延迟。如果去掉一个或所有的 nop 指令，会发生什么，prog2 以去掉一个 nop 的情况

prog2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10
|---|---|---|---|---|---|---|---|---|---|---|
0x000: irmovl $10, %edx | F | D | E | M | W | | | | | 
0x006: irmovl $3, %eax  | | F | D | E | M | W | | | | 
0x00d: nop | | | F | D | E | M | W | | |
0x00e: nop | | | | F | D | E | M | W | |
0x00f: add %edx, %eax | | | | | F | D | E | M | W |
0x011: halt | | | | | | F | D | E | M | W

关键的第 6 周期， W 阶段 $R[\%eax] \leftarrow 3$，周期内 D 阶段 $valB \leftarrow R[\%edx] = 10$ $valB \leftarrow R[\%eax] = 0$。对寄存器 %eax 的写要到周期 7 开始，时钟上升时，才会发生。结果会读出 %eax 的错误值，因为对该寄存器的写还未发生。很明显必须改进流水线让它能够正确处理这样的冒险(例如prog1 插入 nop 指令)。


### 用暂停来避免数据冒险

暂停 stalling 是避免冒险的一种常用技术，暂停时，处理器会停止流水线中一条或多条指令，直到冒险条件不再满足。让一条指令停顿在译码阶段，直到它的源操作数的指令通过了写回阶段，这样处理器就能避免数据冒险。

暂停技术就是让一组指令阻塞在它所处的阶段，而允许其他指令继续通过流水线。处理方法是每次把一条指令阻塞在译码阶段，就在执行阶段插入一个气泡 bubble。 气泡就像一个自动产生的 nop 指令，它不会改变寄存器、存储器、条件码和程序状态。

prog2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11
|---|---|---|---|---|---|---|---|---|---|---|---|
0x000: irmovl $10, %edx | F | D | E | M | W | | | | | 
0x006: irmovl $3, %eax  | | F | D | E | M | W | | | | 
0x00d: nop | | | F | D | E | M | W | | |
0x00e: nop | | | | F | D | E | M | W | |
bubble | | | | | | | E | M | W | |
0x00f: add %edx, %eax | | | | | F | D | D | E | M | W |
0x011: halt | | | | | | F | F | D | E | M | W

在使用暂停技术来解决数据冒险的过程中，通过动态的产生和 prog1 流一样的流水线，有效的执行了 prog2。虽然这实现一机制相当容易，但是得到的性能并不好。


### 用转发来避免数据冒险
PIPE- 设计是在译码阶段从寄存器文件中读入源操作数，但是对这些源寄存器的写有可能在写回阶段才能进行。与其暂停直到写完成，不如简单的将要写的值传到流水线寄存器 E 作为源操作数。这种将结果值直接从一个流水线阶段传到较早阶段的技术成为 __数据转发 data forwarding__ 或简称 __转发__，有时成为 __旁路 bypassing__

数据转发需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑。


### 加载/使用数据冒险
有一类数据冒险不能单纯用转发来解决，因为存储器读在流水线发生的比较晚。可以将 __暂停__ 和 __转发__ 结合起来，避免加载/使用数据冒险。这样用 __暂停__ 来处理加载/使用数据冒险的方法称之为 __加载互锁(load interlock)__。加载互锁和转发技术结合起来足以处理所有可能类型的数据冒险。因此只有加载互锁降低流水线的吞吐量，几乎可以实现每个时钟周期发射一条新指令的吞吐量目标。


### 异常处理
处理器很多事情都会导致异常控制流，此时，程序的正常流程被破坏掉。异常可以由程序执行从内部产生，也可以由某个外部信号从外部产生。
有三种内部产生的异常，把导致异常的指令称为 __异常指令(excepting instruction)__
- halt 指令
- 有非法指令和功能码组合的指令
- 取指或数据读写试图访问一个非法地址

在使用非法指令地址的情况中，没有实际的异常指令，但是想象在非法地址处有一个“虚拟指令”会有所帮助。

在一个流水线化的系统中，异常处理包括一些细节问题。
- 首先可能同时多条指令会引起异常。因此需要确定处理器向操作系统报告哪个异常。基本原则是：由流水线最深的指令引起的异常，优先级最高。
- 指令异常导致的流水线预测错误
- 流水线化的处理器会在不同的阶段更新系统状态的不同部分。可能出现这样情况，一条指令导致一个异常，它后面指令在异常指令完成之前改变了部分状态。


### PIPE各阶段实现
PIPE 是使用了转发技术的流水线化的 Y86 处理器，增加了一些流水线寄存器、一些重新配置的逻辑块、以及增加的流水线控制逻辑。

__1. PC选择和取指阶段__
这个阶段必须选择程序计数器的当前值，并且预测下一个 PC 值。同 SEQ 不一样，必须将指令状态的计算分为两个部分。在取指阶段，可以测试由于指令地址越界引起的存储器错误，还可以发现非法指令或halt指令。必须推迟到访存阶段才能发现非法数据地址。


__2. 译码和写回阶段__
这个阶段的复杂性主要是跟转发逻辑相关。

4.5.7 节中提到有 5 个不同的转发源，每个都有一个数据字和一个目的寄存器ID：
数据字 | 寄存器ID | 源描述
|---|---|---|
e_valE | e_dstE | ALU输出
m_valM | M_dstM | 存储器输出
M_valE | M_dstE | 访存阶段中对端口 E 未进行的写
W_valM | W_dstM | 写回阶段中对端口 M 未进行的写
W_valE | W_dstE | 写回阶段中对端口 E 未进行的写

流水线化的实现总是给处于最早流水线阶段的转发源以较高的优先级，因为它保持着程序序列中设置该寄存器的最近的指令。因此，上述 HCL 代码中的逻辑首先回检测执行阶段的转发源，然后是访存阶段，最后才是写回阶段。

只有指令 popl %esp 会关心在访存或写回阶段两个源之间的转发优先级，因为只有这条指令能同时写两个寄存器。


__3. 执行阶段__


__4. 访存阶段__


### 流水线控制逻辑
这个逻辑必须处理以下 4 种控制情况，这些情况是其他机制（例如数据转发和分支预测）不能处理的
- 处理 ret：流水线必须暂停直到 ret 指令到达写回阶段
- 加载/使用冒险：在一条从存储器中读出一个指令和一条使用该值的指令之间，流水线必须暂停一个周期。
- 预测错误的分支：在分支逻辑发现不应该选择分支之前，分支目标处的几条指令已经就任流水线了。必须从流水线中去掉这些指令
- 异常：当一条指令导致异常，禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段时，停止执行。

__1. 特殊控制情况所期望的处理__
对于 ret 指令后面的无效指令，由于流水线的取指阶段没有办法插入气泡。每个周期，取指阶段从指令存储器中读出一条指令(ret后面的指令)，但在译码阶段就被替换成气泡 bubble。气泡会经过剩下的流水线阶段。


__2. 发现特殊控制条件__



__3. 流水线控制机制__



__4. 控制条件的组合__



__5. 控制逻辑实现__




### 性能分析
所有需要流水线控制逻辑进行特殊处理的条件，都会导致流水线不能够实现每个时钟周期发射一条新指令的目标。可以通过确定往流水线中插入气泡的频率，来衡量这种效率的损失。可以通过计算 PIPE 执行一条指令所需要的平均时钟周期数的估计值，来量化这些处罚对整体性能的影响，这种衡量方法称为 CPI(Cycles Per Instruction, 每指令周期数)。这种衡量值是流水线平均值的倒数。

假设处理器上运行某个基准程序，并观察执行阶段的运行，如果这个阶段一共处理了 $C_i$ 条指令和 $C_b$ 个气泡，那么处理器总共需要大约 $C_i+C_b$ 个时钟周期来执行 $C_i$ 条指令，于是，可以用如下方法计算这个基准程序的 CPI：
$$
CPI = \frac{C_i+C_b}{C_i} = 1.0 + \frac{C_b}{C_i} = 1.0 + lp + mp + rp
$$

可以将处罚项分为三个部分:
- lp(load penalty, 加载处罚) 是由于加载/使用冒险造成暂停时插入气泡的平均数；加载指令 (mrmovl 和 popl) 占所有执行指令的 25%。其中 20% 会导致加载/使用冒险。
- mp(mispredicted branch penalty, 预测错误分支处罚) 是由于预测错误取消指令时插入气泡的平均数；条件分支指令占所有执行指令的 20%。其中 60% 会选择分支，而 40% 不选择分支。
- rp(return penaly, 返回处罚) 是由于 ret 指令造成暂停时插入气泡的平均数；返回指令占所有执行指令的 2%。


### 未完成的工作
PIPE 还是缺乏一些实际微处理器设计种所必须的关键特性

__1. 多指令周期__ Y86 指令集中所有指令都包括一些简单的操作，对于复杂的指令，例如浮点运算和除法，典型的执行时间从3/4 个时钟周期到 32 个时钟周期。为了实现这些指令，即需要额外的硬件，还需要一种机制来协调这些指令的处理与流水线其他部分之间的关系

__2. 与存储系统的接口__  PIPE 描述中取指单元和数据存储都可以在一个时钟周期内读或写存储器中的任意位置。忽略了由自我修改代码造成的可能冒险，在自我修改代码中，一条指令对一个存储区域进行写，而后又从这个区域读取指令。更糟糕的是，访问磁盘存储器，这会需要上百万个时钟周期才能把数据读入到处理器的存储器中。






