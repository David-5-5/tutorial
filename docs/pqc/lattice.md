# 格密码基础


[toc]

## Lattice 格

### 什么是格

格可以定义为一组向量的所有线性组合，其中的系数都是整数。如果您熟悉向量空间的概念，那么格与之类似。

```python
vector_a = vector(RR, [1,0])
vector_b = vector(RR, [0,1])
```

如果用实数系数对这些向量进行线性组合，就可以得到任何可能的二维点。那么 [17, -1.6] 呢？

```python
17*vector_a + -1.6*vector_b # 不是格点

3*vector_a + 4*vector_b # 格点
```
基本上，向量_a 和向量_b 的跨度就是整个二维平面，这两个向量构成了我们向量空间的基础。如果我们有相同向量的所有线性组合，但要求系数为整数呢？这样我们就有了一个格。[17, -1.6] 是格点吗？不是！它需要非整数系数。但是 [3, 4] 是一个格点，因为它可以写成具有整数系数的基向量线性组合。

需要注意的是，一个基础只包含跨格所需的向量。换句话说，构成格的一组向量不会有任何多余的向量。

```python
va = vector(ZZ, [1,0])
vb = vector(ZZ, [0,1])
vc = vector(ZZ, [1,1])
```

在上例中，用 va，vb 和 vc 构建的格不会构成一个基，因为 vc = va + vb。此外，任何给定的格都可以有多个基。

格有与之相关的难题。GGH 的安全性取决于最近向量问题（CVP）的难度。直观地说，CVP 就是找到离任意点最近的格点。

```python
ol = vector(RR, [1.7, 2]) # a point that is not on the lattice
```

在这个例子中，格点 [2, 2] 将是 CVP 的解，因为它最接近非格点 [1.7, 2]。

在二维示例中，CVP 似乎很简单，但对于高维度格（如 200-400 维），CVP 被认为是很困难的。


### 解决 CVP（在某些情况下）
在 GGH 密钥对中，公钥是 “坏 ”基，私钥是 “好 ”基。好 "基是一种接近正交的短基向量。有一些算法可以逼近 “好 ”基的 CVP。其中一种算法称为 Babai 的最接近向量算法。

Babai 算法将一个点 `w` 和一组基向量 $[v_1,\cdots , v_n]$ 作为输入。然后，该算法求解 $w = t_1*v_1 + \cdots + t_n*v_n$ 其中 $[t_1,\cdots, t_n]$ 为实数系数。然后，Babai 通过对所有系数 $t_1,\cdots, t_n$ 进行四舍五入，逼近 CVP 的解。, tn 取最接近的整数。

对于短格基和近似正交格基，Babai 可以很好地工作，并可能返回与 w 最接近的格点！对于 “坏 ”基，Babai 很可能返回一个不接近 w 的格点。

GGH 利用 CVP 对 “坏 ”格基的假定难度来创建非对称密钥对。GGH 密钥对由同一格的两个格基组成：一个公共格基，一个私有格基。明文信息编码为具有整数系数的矢量，密文则是非格点的矢量。

当 Alice 想要向 Bob 发送信息时，Alice 会将信息编码为一个向量，并计算 
`ic = message_vector * bobs_public_basis`

然后用一个随机生成的小矢量 r 进行扰动 (perturbed), Alice 的密文是 
`ct = ic + r = message_vector*bobs_public_basis + r`

要解密信息，鲍勃使用他的私有基求解 ic，然后将结果乘以他的公钥的倒数，就能得到原始明文。

__为什么要使用扰动向量？如何生成扰动向量？__
message_vec * public_basis 总是返回一个格点。为什么？因为 message_vec * public_basis 只是基向量的线性组合，因此会产生一个格点。扰动向量会将 ic 撞离格。

生成扰动向量与生成随机向量几乎一样简单。我找到的资源建议选取一个参数 d，然后生成一个包含 [-d, d] 元素的 n 维向量。这让人一开始很困惑，因为扰动向量会足够大（因为格基很小），这样密文向量就会更接近原始 ic 点之外的另一个不同的格点。

__如何从私钥生成公钥？为什么使用么模 (unimodular) 矩阵生成公钥？__
使用一个循环来生成随机的小格基，直到某个格基超过某个正交阈值（我通过实验确定了阈值）。一旦生成了 “好的 ”私有基，就会通过将私有基与随机生成的么模矩阵相乘来生成公钥基。当格基与么模矩阵相乘时，结果矩阵所跨的格等于原始格基。


__如何衡量格基的 “正交性”？__
正交性可以用哈达玛 (Hadamard) 比率来衡量。所提供的 sage 代码就是用它来生成 GGH 公私密钥对。


__尼古恩 (Nyguen) 的攻击__
GGH（正如作者最初所描述的那样）基本上已经完蛋了。GGH 发布几年后，Phong Q. Nguyen 展示了一种针对 GGH 的攻击，攻击者可以通过给定的公钥解密加密的密文。Nguyen 的攻击也非常简单易学！

在最初的 GGH 论文中，信息加密过程中使用的错误向量是一个n维向量 e，其条目设置为 sigma 或 -sigma（sigma 通常为 3）。回想一下，在 GGH 中，信息 m 是用公钥 B 按以下公式加密的：
```python
c = m*B + e
```

Nyguen 攻击的原理如下。首先，对密码文本进行 sigma 模运算会导致 e 从等式中消失。为什么呢？因为 e 是一个只由 sigma 和 -sigma 组成的向量（两者都是 0 modulo sigma）。
```python
c = m*B + e
c = m*B (mod sigma)
```
虽然这泄露了一些关于 m 的信息（特别是 m (mod sigma)），但只需一点代数和稍大一点的模数，就能泄露更多信息。这可以通过将模数增加到 2*sigma 并在方程中加入全 sigma 向量 s 来实现。

```python
c = m*B + e
s + e = 0 (mod 2*sigma)
c + s = m*B + e + s (mod 2*sigma)
c + s = m*B + 0 (mod 2*sigma)
c + s = m*B (mod 2*sigma) # nice!
```
在这个等式中，我们知道了 c, s 和 B。如果我们求出 m，就会得到关于 m 的信息。虽然无法保证 m 的解，但 Nyguen 也证明了在大多数情况下可以轻松求解。这对 GGH 来说已经很不利了，但情况肯定会变得更糟。

假设解出了前面的方程，那么用 m2s 表示 m（mod 2*sigma）。再用一些代数魔法，就能得到下面的方程：
```python
c - m2s*B = (m - m2s)*B + e
```

请注意，(m - m2s) 将给出一个形式为 2*sigma*m_p 的向量（我不得不在 sage 中解决这个问题，但一些小例子让它显而易见）。我们还不知道 m_p 是多少，不过没关系。现在，将其纳入前面的方程：
```python
c - m2s*B = (m - m2s)*B + e
c - m2s*B = 2*sigma*m_p*B + e
c - m2s*B = 2*sigma (m_p*B + (e/2 * sigma))
(c - m2s*B) / (2*sigma) = m_p * B + (e/2*sigma)
```

边的所有东西,就叫它 c_p 吧

```python
c_p = m_p*B + (e/2*sigma)
```
c_p 只是空间中的一个点。它与 GGH 密文类似。请回想一下 GGH 中密码文本的等式：

```python
c = m*B + e
c_p = m_p*B + (e/2*sigma)
```
我们将原始的 CVP 问题简化为另一个 CVP 问题，使用的误差向量是原始问题的更短版本，具有有效的随机信息。考虑到这是 CVP 问题的一个 “特殊 ”案例，我们可以使用专门的算法来解决与格点接近的点的 CVP 问题。Nguyen 还提到，当误差向量较小时，解决 CVP 特殊情况的 “传统方法 ”效果更好。


__这有用吗？__
当然有用！这种攻击背后还有一个有趣的故事。

有时，密码学家会提供某种形式的 “挑战”，以鼓励对其密码系统进行分析。如果系统经得起考验，挑战应该会增强人们对该方案的信心。然而，这些挑战并不总是很受欢迎，因为它们被认为是不现实和/或不公平的。

GGH 的作者举办了一次挑战赛，以证明 GGH 的安全性。他们展示了 5 个不同安全级别的公开密钥和 5 条使用 GGH 加密的信息。这种 “仅密文 ”攻击模式的门槛很低。可能有很多有问题的密码系统都能经受住这样的攻击，但在更大的压力下会立即崩溃。

Nguyen 使用这种技术在 “合理的时间内 ”破解了全部五项 GGH 挑战。引用阮博士论文中的一段话：

这证明，对于 Goldreich, Goldwasser 和 Halevi 建议的参数，GGH 是不安全的。得知我们的实验结果后，GGH 的一位作者宣布该方案 “已死”。


## LLL

> https://cn-sec.com/archives/2210983.html
  https://kel.bz/post/lll/


