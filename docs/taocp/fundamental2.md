[TOC]

## 1.2 数学准备

### 1.2.11 渐进表示
为了把一个量同其他量做比较，时常想要知道它的近似值而不是精确值。例如，当 n 是大数时， n! 的斯特林近似式就是这一类表示。也已经利用过 $`H_n\approx\ln n+\gamma`$ 这个结果。这种渐进式的推导一般要涉及高等数学。

#### 1.2.11.1 大 O 记号
保罗巴赫曼在其《解析数论》一书发明了一种非常方便的近似值记号 大 O 记号，它使可以用 = 代替 $`\approx`$，还能定量计算精确度。例如
```math
H_n=\ln n+\gamma + O\binom{1}{n}. \qquad (1)
```
一般而言，只要 f(n) 为正整数 n 的函数，就可以使用记号 O(f(n))。它代表一个 _显式表示未知_ 的量，只知道它的值不是太大。O(f(n)) 的准确含义是：存在正常数 M 和 $`n_0`$，使得对于所有正整数 $`n\geq n_0`$，由 O(f(n)) 代表的数 $`x_n`$ 满足条件 $`|x_n|\leq M|f(n)|`$。不说明 M 和 $`n_0`$ 是多少，其实在不同情况下出现大 O 时，这两个常数通常有不同的值。

例如等式(1)意味着当 $`n\geq n_0`$ 时，$`|H_n-\ln n-\gamma|\leq M/n`$ 。虽然对常数 M 和 $`n_0`$ 未加说明，但是可以肯定，如果 n 足够大，那么 O(1/n) 这个量将任意的小。
让我们再多考察几个例子。知道
```math
1^2+2^2+\cdots+n^2=\frac{1}{3}n(n+\frac{1}{2})(n+1) = \frac{1}{3}n^3+\frac{1}{2}n^2+\frac{1}{6}n
```
由此推出
```math
1^2+2^2+\cdots+n^2=O(n^4) \qquad (2)
```
```math
1^2+2^2+\cdots+n^2=O(n^3) \qquad (3)
```
```math
1^2+2^2+\cdots+n^2=\frac{1}{3}n^3 + O(n^2) \qquad (4)
```
等式(2)是相当粗略的，然而并非不正确；等式(3)更强；等式(4)则进一步加强。为了证实这几个等式，将要证明，如果 $`P(n)=a_0+a_1n+\cdots+a_mn^m`$ 是次数小于或等于 m 的任意多项式，那么 $`P(n)=O(n^m)`$。推出这个结果，是因为当 $`n\geq 1`$ 时，
```math
|P(n)|\leq|a_0|+|a_1|n+ \cdots+|a_m|n^m=(|a_0|/n^m+|a_1|/n^{m-1}+\cdots+|a_m|)n^m \\
\leq (|a_0|+|a_1|+\cdots+|a_m|)n^m.
```
所以，可以取 $`M=|a_0|+|a_1|+\cdots+|a_m|`$ 和 $`n_0=1`$。也可以取其他值，比如 $`M=|a_0|/2^m+|a_1|/2^m+\cdots+|a_m|/2^m`$ 和 $`n_0=2`$

大 O 记号对于近似值处理有很大帮助，因为它能简要描述一个经常出现的概念，同时又略去往往无关的详细信息。此外，它可以按照常见的方式进行代数计算，尽管需要记住某些重大的差别。最重要一点是 单向相等性：可以写出等式 $`\frac{1}{2}n^2+n=O(n^2)`$，但是绝对不会把它写成 $`O(n^2)=\frac{1}{2}n^2+n`$。不然由于 $`\frac{1}{4}n^2=O(n^2)`$，会得出荒谬的关系 $`\frac{1}{4}n^2=\frac{1}{2}n^2+n`$。始终约定：一个等式的右端不会给出比左端更多的信息量；等式右端是其左端的一种 “粗略表示”。

关于 = 用法的这种约定可更确切的表述如下：不妨把包含 O(f(n)) 记号的表达式看成 n 的函数集合。符号 O(f(n)) 代表所有以整数为自变量且满足下述条件的函数 g 的集合：存在常数 M 和 $`n_0`$，使得 $|`g(n)|\leq M|f(n)|`$ 对于所有整数 $`n\geq n_0`$ 成立。如果 S 和 T 是函数的集合，那么 S+T 表示集合 {$`g+h|g\in S and h\in T`$}；类似的，定义 $`S+c,S_T,S.T,logS,\cdots`$ 如果 $`\alpha(n)`$ 和 $`\beta(n)`$ 是包含大 O 记号的表达式，那么记号 $`\alpha(n)=\beta(n)`$ 意味着由 $`\alpha(n)`$ 表示的函数集合 _包含于_ 由 $`\beta(n)`$ 表示的函数集合。

因此，可以执行习惯上用 = 进行的大部分运算；如果 $`\alpha(n)=\beta(n)`$ 且 $`\beta(n)=\gamma(n)`$ ，那么 $`\alpha(n)=\gamma(n)`$。如果 $`\alpha(n)=\beta(n)`$，$`\delta(n)`$ 是用 $`\beta(n)`$ 替换 $`\gamma(n)`$ 式中的 $`\alpha(n)`$ 得到的公式，那么 $`\gamma(n)=\delta(n)`$。从这两个结果可以推出其他结论，例如 $`g(x_1,x_2,\cdot,x_m)`$ 是实函数，而 $`\alpha_k(n)=\beta_k(n)`$ 对 $`1\leq k\leq m`$ 成立，那么
```math
g(\alpha_1(n),\alpha_2(n),\cdot,\alpha_m(n))=g(\beta_1(n),\beta_2(n),\cdot,\beta_m(n))
```
下面是可以用大 O 记号进行的一些简单运算：
```math
f(n)=O(f(n)), \qquad (5)
```
```math
c.O(f(n))=O(f(n)), \qquad (6)
```
```math
O(f(n))+O(f(n))=O(f(n)), \qquad (7)
```
```math
O(O(f(n)))=O(f(n)), \qquad (8)
```
```math
O(f(n))O(g(n))=O(f(n)g(n)), \qquad (9)
```
```math
O(f(n)g(n))=f(n)O(g(n)). \qquad (10)
```
大 O 记号也经常用在关于复变量 z 的函数中，用在 z=0 的邻域内。 O(f(z))代表所有满足下述条件的量 g(z)：只要 |z|< r ， 就有 $`|g(z)|\leq M|f(z)|`$。同样，M 和 r 是未定的常数，尽管再需要时可以指定它们的值。大 O 记号的上下文应该指明相应的变量名称及其范围。当变量名是 n 时，隐含假定 O(f(n)) 是关于大整数 n 的函数；当变量名是 z 时，，隐含假定 O(f(z)) 是关于小复数 z 的函数。

假定 g(z) 是由无穷幂级数
```math
g(z)=\sum_{k\geq 0} a_kz^k
```
给出的函数，这个级数在 $`z=z_0`$ 时收敛。那么只要 $`|z|<|z_0|`$，绝对值之和 $`\sum_{k\geq 0} a_kz^k`$ 也必然收敛。因此如果 $`z_0\neq 0`$ 总是可以写
```math
g(z)=a_0+a_1z+\cdots+a_mz^m+O(z^{m+1}). \qquad (11)
```
因为 $`g(z)=a_0+a_1z+\cdots+a_mz^m+z^{m+1}(a_{m+1}+a_{m+2}z+\cdots)`$；仅需证明，存在正数 r，使得 $`|z|\leq r`$ 时括号中的量有界；容易看出，只要 $`|z|\leq r<|z_0|`$，$`|a_{m+1}|+|a_{m+2}|r+|a_{m+3}|r^2+\cdots)`$ 就是一个上界。

例如，在1.2.9节列出的那些生成函数给出了很多当 z 足够小时成立的重要渐进式，包括：
```math
e^z=1+z+\frac{1}{2!}z^2+\cdots+\frac{1}{m!}z^m+ O(z^{m+1}). \qquad (12)
```
```math
\ln(1+z)=z-\frac{1}{2}z^2+\cdots+\frac{(-1)^{m+1}}{m}z^m + O(z^{m+1}). \qquad (13)
```
```math
(1+z)^\alpha=1+\alpha z + \binom{\alpha}{2}z^2 + \cdots+ \binom{\alpha}{m}z^m + O(z^{m+1}). \qquad (14)
```
```math
\frac{1}{(1+z)}\ln\frac{1}{(1+z)}=z+H_2z^2 + \cdots+ H_mz^m + O(z^{m+1}). \qquad (15)
```
其中 m 为非负整数。任何具体的大 O 记号都隐含一对常数 M 和 r，两者彼此相关。例如，对于任何固定的 r，当 $`|z|\leq r`$ 时，$`e^z`$ 显然是 O(1)，因为 $`|e^z|\leq e^{|z|}`$；但是不存在对于一切 z 值都满足 $`|e^z|\leq M`$ 的常数 M。所以当范围 r 增加时，上界 M 也要增大。

有时一个渐进级数虽然不对应一个收敛的无穷级数，但也是正确的。例如，通过普通的幂表示阶乘幂的两个基本公式：
```math
n^{\overline r}=\sum_{k=0}^m\begin{bmatrix}r \\ r-k\end{bmatrix}n^{r-k}+O(n^{r-m-1}). \qquad (16)
```
```math
n^{\underline r}=\sum_{k=0}^m(-1)^k\begin{bmatrix}r\\r-k\end{bmatrix}n^{r-k}+O(n^{r-m-1}). \qquad (17)
```
对于任何实数 r 和任何固定的整数 都是渐进成立的，然而无限和
```math
\sum_{k=0}^\infty\begin{bmatrix}1/2 \\ 1/2-k\end{bmatrix}n^{1/2-k}
```
对于所有 n 发散。当然，但 r 为非负整数时，$`n^{\overline r}`$ 和 $`n^{\underline r}`$ 都只是 r 次多项式，式(17) 实际上即是1.2.6-(44)。当 r 是负整数且 |n|>|r| 时，无限和 $`\sum_{k=0}^\infty\begin{bmatrix}r \\ r-k\end{bmatrix}n^{r-k}`$ 确实收敛到 $`n^{\overline r} = 1/(n-)^{\underline {-r}}`$；利用等式1.2.6-(58)，还可以把这个和写成更自然的形式 $`\sum_{k=0}^\infty\begin{Bmatrix}k-r \\ -r\end{Bmatrix}n^{r-k}`$。

举一个简单的例子来说明至今所介绍的概念。考虑 $`\sqrt[n]{n}`$ 这个量：当 n 增大时，求 n 次根的运算使其值有减少的趋势，但是 $`\sqrt[n]{n}`$ 究竟是减少还是增大，并不是一目了然的。实际上， 会减少到 1 。再考虑稍微复杂一些的量 $`n(\sqrt[n]{n}-1)`$ 。当 n 变大时，现在知道 $`(\sqrt[n]{n}-1)`$ 却会变小，那么 $`n(\sqrt[n]{n}-1)`$ 会怎样变化？

应用上面的公式，这个问题迎刃而解，有
```math
\sqrt[n]{n}= e^{\ln n/n} = 1 + (\ln n/n) + O(\ln n/n)^2, \qquad (18)
```
因为当 $`n\Leftarrow \infty `$ 时，$`\ln n/n \Leftarrow 0`$。这个等式证明现前的论断，即 $`\sqrt[n]{n}\Leftarrow 1`$。此外
```math
n(\sqrt[n]{n}-1) = n(\ln n/n + O((\ln n/n)^2)) = \ln n + O((\ln n)^2/n). \qquad (19)
```
还句话说， $`n(\sqrt[n]{n}-1)`$ 近似等于 $`\ln n`$；两者之差为 $`O((\ln n)^2/n)`$，当 n 趋近无穷大时，它趋近于 0。

人们时常滥用大 O 记号，以为它表示确切的增长量级。有些人在使用它的时候，以为它不仅说明上界，还限定下界。例如，对 n 个数排序的一种算法有可能被斥为效率过低，理由是运行时间为 $`O(n^2)`$。但是 $`O(n^2)`$ 的运行时间并非一定意味着它不是 $`O(n)`$ 的。还有另外一个大 $`\Omega`$ 记号，它是用来表示下界的：
```math
g(n) = \Omega(f(n)). \qquad (20)
```
意味着存在两个正常数 L 和 $`n_0`$ 使得
```math
|g(n)| \geq L|f(n)| \forall n \geq n_0 . \qquad (20)
```
使用这个记号，能够正确的断定，如果 n 足够大，那么运行时间为 $`\Omega(n^2)`$ 的排序算法不如运行时间为 $`O(n\log n)`$ 的算法高效，但是如果不知道大 O 和 大 $`\Omega`$ 中隐含的常数因子，就完全不知道 $`O(n\log n)`$ 的算法将从多么大的 n 开始表现出优势。

最后，如果要说明严格的增长量级，但不想指明常数大小，那么可以使用大 $`\Theta`$：
```math
g(n) = \Theta(f(n)) \iff g(n) = O(f(n)) and g(n) = \Omega(f(n)). \qquad (21)
```


#### 1.2.11.2 欧拉求和公式
欧拉提出了一种极有用的求和方法，能获得令人满意的近似值。它的方法是用积分逼近有限和，在许多情况下，利用这种手段可以不断改进近似值。

当函数 可微，欧拉给出了计算 $`\int_1^n f(x)dx`$ 和 $`\sum_{k=1}^{n-1}f(k)`$ 这两个公式之差的有用的公式 。

为方便起见，将使用记号
```math
{x} = x \mod 1 = x -  \lfloor x\rfloor . \qquad (1)
```
推导将从下述恒等式开始：
```math
\int_k^{k+1}({x}-\frac{1}{2})f'(x)dx = (x-k-\frac{1}{2})f(x)\big|_k^{k+1} - \int_k^{k+1}f(x)dx \\
= \frac{1}{2}(f(k+1)+f(k)) -  \int_k^{k+1}f(x)dx . \qquad (2)
```
等式的两端都对 $`1\leq k < n`$ 求和，得到
```math
\int_1^n({x}-\frac{1}{2})f'(x)dx = \sum_{1\leq k < n}f(k)+\frac{1}{2}(f(n)-f(1)) - \int_1^nf(x)dx 
```
即
```math
\sum_{1\leq k < n}f(x) = \int_1^nf(x)dx - \frac{1}{2}(f(n)-f(1)) + \int_1^n B_1({x})f'(x)dx, \qquad (3)
``` 
其中 $`B_1(x)`$ 是多项式 $`x-\frac{1}{2}`$。这便是所求的有限和与积分之间的联系。

如果继续分部积分，可以进一步求近似值。但是在此之前，先来讨论 伯努利数，即下述无穷级数的系数：
```math
\frac{z}{e^z-1}= B_0 + B_1z + \frac{B_2z^2}{2!} + ... = \sum_{k\geq 0}\frac{B_kz^k}{k!}. \qquad (4)
``` 
几个级数的系数出现在形形色色的应用问题中。雅各布伯努利去世后出版的著作《猜度术》将它介绍给了欧洲数学家。无独有偶，日本的关孝和也发现了这类数。

前几个伯努利数是
```math
B_0=1, B_1 = -\frac{1}{2}, B_2 = \frac{1}{6}, B_3 = 0, B_4 = -\frac{1}{30}. \qquad (5)
``` 
附录A的表3中列出了接下去的一些数值。由于
```math
\frac{z}{e^z-1} + \frac{z}{2} = \frac{z}{2}\frac{e^z+1}{e^z-1}=-\frac{z}{2}\frac{e^{-z}+1}{e^{-z}-1}
``` 
是一个偶函数，因此
```math
B_3 = B_5 = B_7 = B_9 = \cdots = 0.  \qquad (6)
``` 
如果伯努利数的定义式 (4) 两端同事乘以 ，并令 z 的同次幂的系数相等，便等到公式
```math
\sum_k\binom{n}{k}B_k = B_n + \delta_{n1}. \qquad (7)
``` 
现在定义的 _伯努利多项式_
```math
B_m(x)=\sum_k\binom{m}{k}B_kx^{m-k}. \qquad (8)
``` 
如果 m=1，那么 $`B_1(x)=B_0+B_1=x-\frac{1}{2}`$，对应于上面 (3) 中使用的多项式。如果 m>1，那么由 (7) 有 $`B_m(1)=B_m=B_m(0)`$；还句话说，$`B_m({x})`$ 在整数点 x 处不间断。


讲了伯努利多项式和伯努利数，它们与我们的问题之间有什么关系？答案立即揭晓。对等式 (8) 求导，得到
```math
B_m'(x)=\sum_k\binom{m}{k}(m-k)B_kx^{m-k-1} \\
= m\sum_k\binom{m-1}{k}B_kx^{m-k-1} 
= mB_{m-1}(x). \qquad (9)
``` 
因此，当 $`m\geq 1`$ 时，可以分部积分如下：
```math
\frac{1}{m!}\int_1^n B_m({x})f^{(m)}(x)dx = \frac{1}{(m+1)!}(B_{m+1}(1)f^{(m)}(n)-B_{m+1}(0)f^{(m)}(1)) \\
- \frac{1}{(m+1)!}\int_1^n B_{m+1}({x})f^{(m+1)}(x)dx.
``` 
据此可以继续改进式 (3) 的近似值，并且利用式 (6) 得到欧拉的一般公式：
```math
\sum_{1\leq k < n}f(k) = \int_1^nf(x)dx - \frac{1}{2}(f(n)-f(1)) + \frac{B_2}(f'(n)-f'(1)) + \cdots \\
+ \frac{(-1)^mB_m}{m!}(f^{(m-1)}(n)-f^{(m-1)}(1)) + R_{mn}
= \int_1^n f(x)dx + \sum_{k=1}^m\frac{B_k}{k!}(f^{(k-1)}(n)-f^{(k-1)}(1)) + R_{mn}, \qquad (10)
``` 
其中
```math
R_{mn} = \frac{(-1)^{m+1}}{m!}\int_1^n B_m({x})f^{(m)}(x)dx. \qquad (11)
```
当 $`B_m({x})f^{(m)}(x)/m!`$ 非常小的时候，余项 $`R_{mn}`$ 是很小的。事实上，可以证明，当 m 为偶数时，
```math
\left| \frac{B_m({x})}{m!}\right| \leq \frac{B_m}{m!} < \frac{4}{(2\pi)^m}. \qquad (12)
``` 
另外，当 m 增加时，$`f^{(m)}(x)`$ 通常随之变大。所以对于给定的 n，存在 m 的“最佳”值，使 $`|R_{mn}|`$ 取最小值。

已经知道，当 m 为偶数时，存在数 $`\theta`$ 满足：只要 $`f^{(m+2)}(x)f^{(m+4)}(x) > 0`$ 对于 成立，就有
```math
R_{mn} = \theta \frac{B_{m+2}}{(m+2)!}(f^{(m+1)}(n)-f^{(m+1)}(1)), 0 < \theta < 1. \qquad (13)
```
所以此时余项与第一个舍弃项符号相同，而绝对值更小。这个结果有一种更简单的形式，将在习题 3 证明。

现在把欧拉公式应用到两个重要的例子中。首先，置 f(x)=1/x。它的 m 阶导数为 $`f^{(m)}(x)=(-1)^mm!/x^{m+1}`$，所以由式 (10) 得到
```math
H_{n-1} = \ln n + \sum_{k=1}^m\frac{B_k}{k}(-1)^{k-1}(\frac{1}{n^k}-1) + R_{mn}. \qquad (14)
```
现在求出
```math
\gamma = \lim_{n\to \infty}(H_{n-1}-\ln n) = \sum_{k=1}^\frac{B_k}{k}(-1)^k + \lim_{n\to \infty}R_{mn}. \qquad (15)
```
由于 $`\lim_{n\to \infty}R_{mn}=-\int_1^n B_m({x})dx/x^{m+1}`$ 存在，证明确实存在常数 $`\gamma`$ 。因此可以结合式 (14) 和 (15)，推出调和数的一般近似值：
```math
H_{n-1} = \ln n + \gamma + \sum_{k=1}^m\frac{(-1)^{k-1}B_k}{kn^k} + \int_n^\infty \frac{B_m({x})}{x^{m+1}}dx.
= \ln n + \gamma + \sum_{k=1}^m\frac{(-1)^{k-1}B_k}{kn^k} + O(\frac{1}{n^m}).
```
把 m 换成 m+1 ，得出
```math
H_{n-1} = \ln n + \gamma + \sum_{k=1}^m\frac{(-1)^{k-1}B_k}{kn^k} + O(\frac{1}{n^{m+1}}). \qquad (16)
```
此外，从等式 (13) 看出，误差小于第个舍弃项。可以得到一个特例，对两端加 1/n：

这就是式1.2.7-(3) 看出，对于很大的 k，伯努利数 $`B_k`$ 将变得非常大，当 k 为偶数时近似等于 $`(-1)^{1+k/2}2(k!/(2\pi)^k)`$，所以式 (16) 对于任何固定的 n 值，不可能扩展为一个收敛的无穷级数。

可以用同样的方式推导出斯特林近似公式。这一次置 $`f(x)=\ln x`$，由式 (10) 得到
```math
\ln (n-1)! = n\ln n - n + 1 - \frac{1}{2}\ln n + \sum_{k=1}^m\frac{B_k(-1)^{k-1}}{k(k-1)}(\frac{1}{n^k}-1) + R_{mn}. \qquad (17)
```
沿用上面的做法，发现极限
```math
\lim_{n\to \infty}(\ln n! - n\ln n + n - \frac{1}{2}\ln n) = 
1 + \sum_{k=1}^m\frac{B_k(-1)^{k-1}}{k(k-1)} + \lim_{n\to \infty}R_{mn}. 
```
存在；暂且把它称为 “斯特林常数”，得到斯特林的结果
```math
\ln n!=(n+\frac{1}{2})\ln n - n + \sigma + \sum_{k=1}^m\frac{B_k(-1)^{k-1}}{k(k-1)n^{k-1}} + O(\frac{1}{n^m}). \qquad (18)
```
特别地，令 m=5，得到
```math
\ln n!=(n+\frac{1}{2})\ln n - n + \sigma + \frac{1}{12n} - \frac{1}{360n^3} + O(\frac{1}{n^5}). 
```
为两端为指数，求 e 的幂
```math
n!=e^\sigma\sqrt{n}(\frac{n}{e})^n exp(\frac{1}{12n}-\frac{1}{360n^3} + O(\frac{1}{n^5}))
```
利用 $`e^\sigma=sqrt{2\pi}`$，展开指数部分，获得最终结果
```math
n!=\sqrt{2\pi n}(\frac{n}{e})^n(1+\frac{1}{12n} + \frac{1}{288n^2} - \frac{139}{51840n^3} -\frac{571}{2488320n^4} + O(\frac{1}{n^5})). \qquad (19)
```


#### 1.2.11.3 若干渐进计算式
这一节研究下面三个令人感兴趣的和，目的在于推导它们的近似值：
```math
P(n) = 1 + \frac{n-1}{n} + \frac{n-2}{n}\frac{n-2}{n-1} + \cdots = \sum_{k=0}^{n} \frac{(n-k)^k(n-k)!}{n!} . \qquad (1)
```
```math
Q(n) = 1 + \frac{n-1}{n} + \frac{n-1}{n}\frac{n-2}{n} + \cdots = \sum_{k=0}^{n} \frac{n!}{(n-k)!n^k} . \qquad (2)
```
```math
R(n) = 1 + \frac{n}{+1n} + \frac{n}{n+1}\frac{n}{n+2} + \cdots = \sum_{k\geq 0} \frac{n!n^k}{(n+k)!} . \qquad (3)
```
这三个函数出现在后面将要遇到的若干算法中，它们的形式相似而内在性质不同。P(n) 和 Q(n) 为有限和，而 R(n) 是无限和。当 n 为很大的数时，这三个函数看上去近乎相等，不过不能明显看出它们当中的任何一个近似值是什么。探讨这三个函数的近似值，将带来很多富有启发性的附带结果。

首先，注意 P(n) 和 Q(n) 之间的了一个重要联系：
```math
Q(n)+R(n) = \frac{n!}{n^n}((1+n+\cdots+\frac{n^{n-1}}{(n-1)!})+(\frac{n^n}{n!}+\frac{n^{n+1}}{(n+1)!})) = \frac{n!e^n}{n^n} . \qquad (4)
```
斯特林公式告诉，$`n!e^n/n^n`$ 近似等于 $`\sqrt{2\pi n}`$，所以可以推测 Q(n) 和 R(n) 都粗略地等于 $`\sqrt{\pi n/2}`$。

下一步，必须考虑 的级数的部分和。利用带余项的泰勒公式
```math
f(x) = f(0) + f'(0)x + \cdots + \frac{f^{(n)}(0)x^n}{n!} + \int_0^x \frac{t^n}{n!} f^{(n+1)}(x-t)dt. \qquad (5)
```
立即导出一个重要的函数
```math
\gamma(a,x) = \int_0^x e^{-t}t^{a-1}dt . \qquad (6)
```
这个函数称为 _不完全 $`\gamma(a,x)`$ 函数_。假定 a>0。 有 $`\gamma(a,\infty)=\Gamma(a)`$；这就是 “不完全 $`\gamma(a,x)`$ 函数” 这个名称的由来。它有两个很有用的按 x 展开的级数:
```math
\gamma(a,x) = \frac{x^a}{a} - \frac{x^{a+1}}{a+1} + \frac{x^{a+2}}{a+2} - \cdots . = \sum_{k\geq 0}  \frac{(-1)^kx^{a+k}}{k!(a+k)} \qquad (7)
```
```math
e^{x}\gamma(a,x) = \frac{x^a}{a} + \frac{x^{a+1}}{a(a+1)} + \frac{x^{a+2}}{a(a+1)(a+2)} + \cdots . = \sum_{k\geq 0} \frac{x^{a+k}}{a(a+1)\cdots(a+k)} \qquad (8)
```
从第二个公式看出它同 R(n) 的联系：
```math
R(n) = \frac{n!e^n}{n^n}(\frac{\Gamma(n,n)}{(n-1)!})  \qquad (9)
```
这里特意不把这个等式写成最简形式，因为 $`\gamma(n,n)`$ 是 $`\gamma(n,\infty)=\Gamma(n)=(n-1)!`$ 的一部分，而 $`n!e^n/n^n`$ 是关系式 (4) 右端的量。

求近似值问题于是归结为求 $`\gamma(n,n)/(n-1)!`$ 的理想估计。现在假定 y 是固定的，x 取很大的值，来确定 $`\gamma(x=1,x+y)/\Gamma(x+1)`$ 的近似值。下面使用的方法比将要获得的结果更为重要。

按照定义有
```math
\frac{\gamma(x+1,x+y)}{\Gamma(x+1)} = \frac{1}{\Gamma(x+1)}\int_0^{x+y} e^{-t}t^{x}dt \\
= 1 - \frac{1}{\Gamma(x+1)}\int_x^\infty e^{-t}t^{x}dt + \frac{1}{\Gamma(x+1)}\int_x^{x+y} e^{-t}t^{x}dt \qquad (10)
```
置
```math
I_1 = \int_x^\infty e^{-t}t^{x}dt, \\
I_1 = \int_x^{x+y} e^{-t}t^{x}dt, \\
```
依次考察这两个积分。


$`I_1`$ 的估计：代入 t=x(1+u) ，把 $`I_1`$ 转换成从 0 到无穷大的积分；进一步代入 v=u-ln(1+u) 和 dv = (1 - 1/(1+u))du，
```math
I_1 = e^{-x}x^x\int_0^\infty xe{-xu}du = e^{-x}x^x\int_0^\infty xe^{-xv}(1+\frac{1}{u})dv. \qquad (11)
```
在最后这个积分中，用 的一个幂级数替换 。得到
```math
v = \frac{1}{2}u^2 - \frac{1}{3}u^3 + \frac{1}{4}u^4 - \frac{1}{5}u^5 + \cdots = 
(u^2/2)(1-\frac{2}{3}u+\frac{1}{2}u^2-\frac{2}{5}u^3+\cdots) .
```
置 $`w=\sqrt{2v}`$，因此有
```math
w = u(1-\frac{2}{3}u+\frac{1}{2}u^2-\frac{2}{5}u^3+\cdots)^\frac{1}{2} = u - \frac{1}{3}u^2 + \frac{7}{36}u^3 - \frac{73}{540}u^4 + \frac{1331}{12960}u^5 + O(u^6).
```
这个展开式可以通过二项式定理获得。，现在可以把 u 作为 w 的幂级数求解：
```math
u = w + \frac{1}{3}w^2 + \frac{1}{36}w^3 - \frac{1}{270}w^4 + \frac{1}{4320}w^5 + O(w^6).
```
```math
1 + \frac{1}{u} = 1 + \frac{1}{w} - \frac{1}{3} + \frac{1}{12}w - \frac{2}{135}w^2 + \frac{1}{864}w^3 + O(w^4)\\
= \frac{1}{\sqrt{2}}v^{-1/2} + \frac{2}{3} + \frac{\sqrt{2}}{12}v^{1/2} - \frac{4}{135}v + \frac{\sqrt{2}}{432}v^{3/2} + O(v^2) \qquad (12)
```
在所有这些公式中，大 O 记号都是指很小的变量值，就是说，对于足够小的正数 r，有 $`|u|\leq r,|v|\leq r,|w|\leq r`$。这样足以令人满意吗？在等式 (11) 中，用 v 代换 1+1/u 的时候，应当对于 $`0\leq x <\infty`$ 成立，而不仅对于 $`|v|\leq r`$ 成立。幸好，对于这个积分，从 0 到 $`\infty`$ 的积分值几乎完全依赖于被积函数在自变量接近零时的取值。事实上，对于任意固定的 r>0 以及很大的 x，有
```math
\infty xe^{-xv}(1+\frac{1}{u})dv = O(e^{-rx}) \qquad (13)
```
感兴趣的是一直到 $`O(x^{-m})`$ 项的近似值；由于对于任意正数 r 和 m，$`O((1/e^r)^x)`$ 都远远小于 $`O(x^{-m})`$，仅需要从 0 到任何固定的正数 r 积分。因此取足够小的 r，就可以保证上面对幂级数的所有处理都是正确的。
```math
\int_r^\infty xe^{-xv}(1+\frac{1}{u})dv = O(e^{-rx}) \qquad (13)
```
现在有
```math
\int_0^\infty xe^{-xv}v^\alpha dv = \frac{1}{x^\alpha}\int_0^\infty e^{-q}q^\alpha dq = \frac{1}{x^\alpha}\Gamma(\alpha+1) , where \alpha > -1, \qquad (14)
```
所以，通过把级数 (12) 插入积分 (11)，终于得到
```math
I_1 = e^{-x}x^x(\sqrt{\frac{\pi}{2}}x^{1/2} + \frac{2}{3} + \frac{\sqrt{2\pi}}{24}x^{-1/2} - \frac{4}{135}x^{-1} + \frac{\sqrt{2\pi}}{576}x^{-3/2} + O(x^{-2})) \qquad (15)
```
$`I_2`$ 的估计：在积分 中代入 t=u+x，得到
```math
I_2 = e^{-x}x^x\int_0^ye{-u}(1+\frac{u}{x})^x du \qquad (16)
```
于是有
```math
e{-u}(1+\frac{u}{x})^x = exp(-u + x\ln(1+\frac{u}{x})) = exp(\frac{-u^2}{2x} + \frac{x^3}{2x^2} + O(x^{-3})) \\
= 1 - \frac{u^2}{2x} + \frac{u^4}{8x^2} + \frac{u^3}{3x^2} + O(x^{-3})
```
其中 $`0\leq u\leq y`$，x 很大。因此求出
```math
I_2 = e^{-x}x^x(y-\frac{y^3}{6}x^{-1}+(\frac{y^4}{12} +\frac{y^5}{40})x^{-2} + O(x^{-3})) \qquad (17)
```
最后在分析式 (10) 中用因式 $`1/\Gamma(x+1)`$ 乘式 (15) 和 (17) 时出现的系数 $`e^{-x}x^x/\Gamma(x+1)`$。斯特林近似式对于 $`\Gamma`$ 函数成立；由此可得
```math
\frac{e^{-x}x^x}{\Gamma(x+1)}=\frac{e^{-1/12x+O(x^{-3})}}{\sqrt{2\pi x}} \\
= \frac{1}{\sqrt{2\pi}}x^{-1/2} - \frac{1}{12\sqrt{2\pi}}x^{-3/2} + \frac{1}{288\sqrt{2\pi}}x^{-5/2} + O(x^{-7/2}) \qquad (18)
```
现在集 (10)(15)(17)(18) 之大成，隆重推出 --

__定理 A.__ 对于很大的 x 和固定的 y，
```math
\frac{\gamma(x+1,x+y)}{\Gamma(x+1)} = \frac{1}{2} + \frac{y-2/3}{\sqrt{2\pi}}x^{-1/2} + 
\frac{1}{\sqrt{2\pi}}(\frac{23}{270}-\frac{y}{12}-\frac{y^3}{6})x^{-3/2} + O(x^{-5/2}) \qquad (19)
```
上面的方法已经表明，这个近似式可以扩展到想达到的任意阶 x 幂。

利用等式 (4) 和 (9)，可以用 __定理 A__ 求 R(n) 和 Q(n) 的近似值，但是此项计算以后再做。现在研究 P(n)，它似乎需要采用不同的方法。有
```math
P(n) = \sum_{k=0}^n\frac{k^{n-k}k!}{n!} = \frac{\sqrt{2\pi}}{n!}\sum_{k=0}^nk^{n+1/2}e{-k}(1+\frac{1}{12k}+O(k^{-2})) \qquad (20)
```
因此，为了得到 P(n) 的值，必须研究形如
```math
\sum_{k=0}^nk^{n+1/2}e{-k}
```
的和。

令 $`f(x)=x^{n+1/2}e{-x}`$，应用欧拉求和公式
```math
\sum_{k=0}^nk^{n+1/2}e{-k}=\int_0^n x^{n+1/2}e{-x} + \frac{1}{2}n^{n+1/2}e{-n} + \frac{1}{24}n^{n-1/2}e{-n} - R. qquad (21)
```
对余式的粗略分析表明，$`R=O(n^ne{-n})`$；又由于积分是一个不完全 $`\gamma`$ 函数，有
```math
\sum_{k=0}^nk^{n+1/2}e{-k}=\gamma(n+\frac{2}{3},n) + \frac{1}{2}n^{n+1/2}e{-n} + O(n^ne{-n}). qquad (22)
```
式 (20) 还需要估计和式
```math
\sum_{k=0}^nk^{n-1/2}e{-k}=\sum_{0\leq k\leq n-1}k^{(n-1)+1/2}e{-k} n^{n-1/2}e{-n},
```
这个估计也可以通过式 (22) 获得。

现在有足够的公式来确定 P(n) Q(n) R(n) 的近似值，只剩下代入和乘法等运算要做了。在这个过程中，将利用展开式
```math
(n+\alpha)^{n+\beta} = n^{n+\beta}e^\alpha(1+\alpha(\beta-\frac{\alpha}{2})\frac{1}{n} + O(n^{-2})) \qquad (23)
```
对于 P(n)，式 (21) 的方法仅产生渐进级数的前面两项，汇集上面的全部的计算结果，得到要求的渐进式：
```math
P(n) = \sqrt{\frac{\pi n}{2}} - \frac{2}{3} + \frac{11}{24}\sqrt{\frac{\pi}{2n}} + \frac{4}{135n} - \frac{71}{1152}\sqrt{\frac{\pi}{2n^3}}+ O(n^{-2})  \qquad (24)
```
```math
Q(n) = \sqrt{\frac{\pi n}{2}} - \frac{1}{3} + \frac{1}{12}\sqrt{\frac{\pi}{2n}} + \frac{4}{135n} - \frac{1}{288}\sqrt{\frac{\pi}{2n^3}}+ O(n^{-2})  \qquad (24)
```
```math
R(n) = \sqrt{\frac{\pi n}{2}}+\frac{1}{3} + \frac{1}{12}\sqrt{\frac{\pi}{2n}} + \frac{4}{135n}+\frac{1}{288}\sqrt{\frac{\pi}{2n^3}}+ O(n^{-2})  \qquad (25)
```
公开发表的文献对这里研究的三个函数只做了轻描淡写的讨论。 展开式中的第一项 有霍华德德姆斯在博士论文中给出。

同 Q(n) 和 R(n) 的渐进值的等价的公式是由自学成才的杰出印度数学家拉马努金首先确定的，他提出估计
```math
n!e^n/2n^n - Q(n)
```
的问题。他在解答中给出了渐进级数
```math
\frac{1}{3} + \frac{4}{135}n^{-1} - \frac{8}{2835}n^{-3} + \cdots
```
这个结果大大超过等式 (25) 的精度。他的推导比上面的描述的方法更为精巧：为了估计 $`I_1`$，他代入 $`t=x+u\sqrt{2x}`$，把被积函数表示成形如
```math
c_{jk}\int_0^\infty exp(-u^2)u^jx^{-k/2} du
```
的项的和。积分 $`I_2`$ 完全可以不推导，因为当 a > 0 时，
```math
\gamma(a,x) = x^ae^{-x} + \gamma(a+1,x)
```
求 Q(n) 的渐进表示还有一个更简单的方法，就是习题20。我们采用的推导方法尽管比较复杂，但是具有启示作用，作者是罗伯特弗兹，他主要关心满足
```math
\gamma(x+1,x+y) = \Gamma(x+1)/2
```
的 y 值。不完全 $`\gamma`$ 函数的渐进性质后来又由弗朗西斯科特里格米扩充到复变量函数。


## 1.3 MIX

我们经常用到计算机的内部机器语言。我们用的是一台虚拟的计算机，称为MIX。每位对于计算机不是单纯一时兴起的人士，大概迟早会了解至少一种机器语言。

MIX 经过特意设计，保留了历史上各种计算机的最简单形态，所有它的特性是很容易理解的。

> 然而必须承认，MIX如今已经完全过时。以后将改用一台新计算机，称为MMIX。MMIX将是一台所谓的精简指令集计算机 RISC，用 64 位的字作算术运算。把各种材料从 MIX 转换到 MMIX 将是一项长期的任务。


### 1.3.1 MIX的描述

MIX 是世界上第一台多不饱和计算机（可以从多方面扩展）。MIX 具有一种独特的性质：它同时采用二进制和十进制。MIX的程序员实际上并不知道他们是在为 2 还是 10 为基数做四则运算的计算机编程。

#### 字
MIX数据的基本单位是字节。每个字节包含数量不确定的信息，但它必须至少能够保存 64 个不同的值。

用 MIX 的语言编写程序时，应保证绝不假设一个字节能表示超过 64 个值。如果想要处理 80 这个数，就必须留两个相邻的字节来表示它，尽管在十进制计算机上用一个字节就足够了。无论字节大小如何，用 MIX 语言编写的某些算法都应能正确运行。本书只认可对各种字节大小都能给出正确结果的程序。

一个计算机 __字__ 由五个字节和一个符号位组成。符号位只有 + 和 - 两个可能取值。


#### 寄存器
MIX 有9个寄存器
- A 寄存器， 累加器，Accumulator，包含 5 个字节和 1 个符号位
- X 寄存器， 扩展寄存器，Extension，包含 5 个字节和 1 个符号位
- I 寄存器， 变址寄存器，Index register，有 6 个。分别称为 I1, I2, I3, I4, I5, I6，各包含 2 个字节和 1 个符号位
- J 寄存器， 转址寄存器，Jump address，包含 2 个字节，隐含符号默认永远取 +。

在寄存器名称前加小写字母 r 以标识 MIX 寄存器。因此 rA 就表示 __A寄存器__

A 寄存器具有许多用途，特别是在四则运算和数据操作中。X 寄存器是对 A 寄存器的一种“右侧”扩展，它同 rA 结合使用，保存一个 10 字节的乘积或被除数，也可以用来保存从 rA 右端移出的数据。变址寄存器 rI1, rI2, rI3, rI4, rI5, rI6 主要用于计数和用于引用可变的存储地址。J 寄存器总是用来保存最近一次“转移”操作之后一条指令的地址，主要与子例程配合使用。

除寄存器之外，MIX 还包含：
- 上溢开关
- 比较指示器，有三种取值小于，等于，大于
- 内存储器，4000个字存储空间，每个字有 5 个字节和 1 个符号位
- 输入输出设备



#### 字的部分字段
0|1|2|3|4|5
|---|---|---|---|---|---|
$\pm$ | 字节 | 字节 | 字节 | 字节 | 字节

大多数指令允许程序员仅使用字的一部分。在这种情况下，程序员可以给出一个非标准的“字段说明”。允许使用的字段是计算机字中的相邻字节，用 (L:R) 表示，其中 L 是字段左端字节的编号，R 是字段右端字节的编号。字段说明的例子有：
(0:0)，只用符号位
(0:2)，符号位和前两个字节
(0:5)，整个字；这是最常见的字段说明
(1:5)，除符号位之外的整个字
(4:4)，只用第4个字节
(4:5)，最后2个字节

字段说明的用法随指令的不同而略有差异。实际上，每个字段说明 (L:R) 在计算机内部是用 8L + R 这个数表示的。


#### 指令格式

用于保存指令的计算机字具有下列形式：

0|1|2|3|4|5
|---|---|---|---|---|---|
$\pm$ | A | A | I | F | C

(3)

- 最右边的字节 C 是操作码，说明执行什么操作，例如，C=8 指定“装入A寄存器”的 LDA。

- F 字段保存对操作码的限定（或修改）。
  - 它通常是一个字段说明 (L:R) = 8L + R。例如，如果 C=8, F=11，操作码代表“把(1:3) 字段装入寄存器A”的操作。
  - 有时 F 也有其他用途，例如在输入输出指令中，F 是相关的输入输出设备的设备号。

- 指令左端部分的 $\pm AA$ 是地址。（符号是地址的一部分）地址后面的 I 字段是变址说明，可以用于改变有效地址。
  - 如果 I=0，地址 $\pm AA$ 直接使用；
  - 其他情况下，I 将包含最小取 1 最大取 6 的一个数 i，在指令执行之前，要把变址寄存器 $I_i$ 中的数同 $\pm AA$ 按代数方式相加，用结果作为操作地址。
  - 用字母 M 表示任何指定的变址发生后的新地址

在大多数指令中，M 指的是一个存储单元。在本书中“存储单元”与“存储位置”基本可以互换使用。我们假定内存存储器有 4000 个存储单元，从 0 到 3999 编号，因此每个存储位置可以用两个字节编址。在指令中，只要 M 是一个存储单元，必须有 $0\leq M\leq 3999$，而且此时用 CONTENT(M) 表示存放在存储位置 M 的值。

__记号__
为了用便于阅读的方式讨论指令，将使用记号：
`OP ADDRESS, I(F)  (4)`
表示像(3)那样的指令。

此处 OP 是指令操作码 C 的符号名称，即操作符； ADDRESS 是 $\pm AA$ 部分；
如果 I 为 0，那么省略。如果 F 是这个特定操作符的标准 F 字段说明，就不需写出 "(F)"。几乎所有操作符的标准字段说明都是(0:5)，代表一个完整的字。

例如，把一个数装入累加器的指令称为 LDA，操作码为 8。对于这条指令我们有
`LDA 2000, 2(1:3)  + 2000 2 11 8`
上面这条指令可读作“向 A 寄存器装入单元 2000 按 2 变址后 (1:3) 字段内容


#### 每条指令的操作规则
前面格式 (3) 之后的说明已经定义了每个指令字的 M，F，C 这三个量。现在逐一定义每条指令对应的操作。


#### 装入操作符

- LDA 装入 A， C = 8；F = 字段。
  由 CONTENT(M) 的指定字段取代寄存器 A 原来的内容。
  对于所有用部分字段作为输入的操作，符合如果是字段的一部分则应使用，否则默认为 + 号。当装入寄存器时，该字段会移到寄存器的右侧。

- LDX 装入 X， C = 15；F = 字段。
  和 LDA 一样，唯一的区别是装入 rX 而不是 rA。

- LDi 装入 i， C = 8+i；F = 字段。
  和 LDA 一样，唯一的区别是装入 rIi 而不是 rA。一个变址寄存器只有两个字节和一个符号位；始终假定1,2,3字节为零。如果一条 LDi 指令将置1,2,3字节为非零值，那么这条指令无定义。
  在所有指令的描述中，“i”始终代表满足 $1\leq i\leq 6$ 的整数。

- LDAN 反号装入 A， C = 16；F = 字段。
- LDXN 反号装入 X， C = 23；F = 字段。
- LDiN 反号装入 i， C = 16+i；F = 字段。
  这 8 条指令分别和 LDA, LDX, LDi 一样，唯一区别是装入带相反符号的值。


#### 存储操作符

- STA 存储 A， C = 24；F = 字段。
  用 rA 的部分内容取代由 F 指定的 CONTENT(M) 的字段。CONTENT(M) 的其他部分保持不变。
  在存储操作中，F 字段的有效位高低同装入操作相反；从寄存器右侧取出字段的若干个字节，在需要时向左移位，然后插入到 CONTENT(M) 的相应字段。符号位不会改变，除非它是字段的一部分。寄存器的内容不受影响。

- STA 存储 X， C = 31；F = 字段。
  和 STA 一样，唯一的区别是存储 rX 而不是 rA。

- STi 存储 i， C = 24 + i；F = 字段。
  和 STA 一样，唯一的区别是存储 rIi 而不是 rA。变址寄存器的1,2,3字节均为零。

- STJ 存储 J， C = 32；F = 字段。
  和 STi 一样，唯一的区别是存储 rJ，而且符号恒为 +。
  对于 STJ 指令，F 的标准字段说明是 (0:2) 而不是 (0:5)。这是很自然的，因为 STJ 几乎总是用于指令的地址字段。

- STZ 存储零， C = 33；F = 字段。
  和 STA 一样，唯一的区别是存储正零。换句话说，它把 CONTENT(M) 的指定字段清零。


#### 算术操作符

加法、减法和触发运算都允许附有字段说明。可以用字段说明“(0:6)”表示运算是浮点运算。标准字段说明照例是 (0:5)。其他字段的处理同 LDA 中的处理一样。用字母 V 表示 CONTENT(M) 的指定字段。

- ADD 加法。 C = 1；F = 字段。
  把 V 加进 rA。如果所得结果数值太大，寄存器 A 容纳不下，那么上溢开关就会打开。如果结果为零，rA 的符号位不改变。
  例：下面的指令序列计算寄存器 A 的 5 个字节之和
  ```
  STA 2000
  LDA 2000(5:5)
  ADD 2000(4:4)
  ADD 2000(3:3)
  ADD 2000(2:2)
  ADD 2000(1:1)
  ```
  有时把这样的相加称为“横向加法”

- SUB 加法。 C = 2；F = 字段。
  从 rA 中减去 V。等价于在 ADD 中用 -V 代替 V。

- MUL 加法。 C = 3；F = 字段。
  以 V 与 rA 的 10 字节乘积替换寄存器 A 和 X 的值。rA 和 rX 的符合均设置为乘积的代数符号，若 V 与 rA 原先同号则取 +，异号则取 - 。

- DIV 除法。 C = 4；F = 字段。
  把 rA 和 rX 的值合起来当作一个 10 字节数 rAX，并除以 V值。
  - 如果 V=0，或者商的值超出 5 个字节，那么寄存器 A 和 X 填入无定义的信息，并打开上溢开关。
  - 其他情况下，把商存入 rA，余数存入 rX


#### 地址传送操作符

在下面的操作中，“地址” M 在使用时当成一个符号的数，而不是作为存储器中的单元地址。

- ENTA 送入A。 C = 48；F = 2。
  把数值 M 装入 rA。这个操作等价于从包含带符号值 M 的存储字执行 “LDA” 操作。如果 M = 0, 装入这条指令的符号。

- ENTX 送入X。 C = 55；F = 2。

- ENTi 送入i。 C = 48+i；F = 2。
  类似于 ENTA，装入相应的寄存器

- ENNA 反号送入 A。 C = 48；F = 3。

- ENNX 反号送入 X。 C = 55；F = 3。

- ENNi 反号送入 i。 C = 48+i；F = 3。
  和ENTA、ENNX、ENNi一样，唯一的区别是装入相反的符号。

- INCA 增加 A。 C = 48；F = 0。
  把值 M 加进 rA。这个操作等价于从包含 M 值的存储字执行 “ADD”。可能出现上溢，处理方法于 ADD 完全一样。
  例如 INCA 1，对 rA 的值加 1。

- INCX 增加 X。 C = 55；F = 0。
  把值 M 加进 rX。如果出现上溢，这个操作操作等价于 ADD，不过是用 rX 而不是 rA。寄存器 A 不会受这条指令的影响。

- INCi 增加 i。 C = 48+i；F = 0。
  把值 M 加进 rIi。一定不出现上溢；如果 M + rIi 不能容纳在 2 个字节中，这条指令的结果是未定义的。

- DECA 减少 A。 C = 48；F = 1。

- DECX 减少 X。 C = 55；F = 1。

- DECi 减少 i。 C = 48+i；F = 1。

这3条指令分别和 INCA，INCX，INCi 一样，唯一区别是对寄存器减 M 而不是加 M。


#### 比较操作符

MIX 的所有比较操作符用来比较的两个值，都是在一个寄存器中，一个在存储器中。依据寄存器中的值小于、等于、大于存储单元的值，相应将比较指示器设置为LESS、EQUAL、GREATER。

- CMPA 比较 A。 C = 56；F = 字段。
  用 rA 的指定字段与 CONTENT(M) 的相同字段做比较。如果 F 不包括符号位，两者的字段都认为是非负的；不然，也要比较符号。

- CMPX 比较 X。 C = 63；F = 字段。

- CMPi 比较 i。 C = 56+i；F = 字段。


#### 转移操作符

指令通常是按顺序执行的，也就是说，在执行单元 P 中的指令后，一般是执行单元 P+1 中的指令。但是几种转移指令会中断这种执行顺序。程序员如果愿意，可以用一条“存储 J”的指令，以便设置以后将要用于返回程序远处的另一条指令的地址字段。每当程序中实际出现一次转移时，J 寄存器都会改变。

- JMP 转移。 C = 39；F = 0。
  无条件转移：下一条指令从位置 M 取出的指令。

- JSJ 转移，保留 J。 C = 39；F = 1。
  和 JMP 一样，但是 rJ 内容不改变

- JOV 上溢时转移。 C = 39；F = 2。
  如果上溢开关置于“开”状态，则关闭之并出现JMP；否则不产生任何操作

- JNOV 无上溢时转移。 C = 39；F = 3。
  如果上溢开关置于“关”状态，则出现JMP；否则关闭之

- JL JE JG JGE JNE JLE 比较出现小于、等于、大于、大于等于、不等于、小于等于时转移。 C = 39；F = 4 5 6 7 8 9。
  当比较指示器置于指定的条件时转移。例如，如果比较指示器位 LESS 或 GREATER，那么 JNE 将发生转移。这些转移指令不改变比较指示器。

- JAN JAZ JAP JANN JANZ JANP A 寄存器为负值、零、正数、非负数、非零、非正数时转移。C = 40；F = 0 1 2 3 4 5
  如果 rA 中的数满足指定的条件，出现一次 JMP；不满足则不产生任何操作。

- JXN JXZ JXP JXNN JXNZ JXNP X 寄存器为负值、零、正数、非负数、非零、非正数时转移。C = 47；F = 0 1 2 3 4 5

- JiN JiZ JiP JiNN JiNZ JiNP i 寄存器为负值、零、正数、非负数、非零、非正数时转移。C = 40 + i；F = 0 1 2 3 4 5
  这 42 个转移指令类似于对 rA 的相应操作。


#### 其他操作符
- SLA SRA SLAX SRAX SLC SRC 左移 A 右移 A 左移 AX 右移 AX 循环左移 AX 循环右移 AX。C = 6；F = 0 1 2 3 4 5
  这些是“移位”指令，其中 M 指定左移后者右移的 MIX 字节数，因此 M 必须是非负的。SLA 和 SRA 不影响 rX；其他移位同时影响寄存器 A 和 X，把它们视为一个 10 字节寄存器。

- MOVE 传送或移动。C = 7；F = 数字，正常情况下为 1
  传送由 F 指定数量的字，原位置的起始单元是 M，新位置的起始单元由变址寄存器 1 的值指定。一次传送一个字，当操作结束时，rIi 的值增加 F。如果 F=0,不发生任何操作。

- NOP 无操作。C = 0；
  不出现操作，略过这条指令，省略 F 和 M

- HLT 停机 C = 5；F = 2
  机器停止操作。当计算机操作员重新启动机器时，最终净效果等价于 NOP。


#### 输入输出操作符

MIX 有不少输入输出设备，每种设备都给定一个号码：

用磁带、磁盘或磁鼓设备输入或输出时，读入或写出的是完整的字（5 个字节和 1 位符号位）。但是卡片读入机、打字机终端、纸带等设备总是用字符代码输入或输出，其中每个字节表示一个字母数字字符。代码 00 对应于 ，表示一个空格；代码 01-29 表示字母 A 至 Z 和额外的 3 个希腊字姆；代码 30-39 代表数字 0, 1, ..., 9；代码 40, 41, ...代表标点负号和其他特殊字符。

- IN 输入。C = 36；F = 设备。
  这条指令启动信息传输，从指定的输入设备传到从 M 开始的连续存储单元。传输的单元个数是这个设备的信息块大小。如果此前对同一台设备进行的操作尚未完成，计算机在此等待。

- OUT 输出。C = 37；F = 设备。
  这条指令启动信息传输，从 M 开始的连续存储单元传输到从指定的输入设备上。如果设备尚未就绪，计算机在此等待。

- IOC 输入输出控制。C = 35；F = 设备。
  如果设备忙碌，那么机器等待，直到设备处于不忙碌栈太。然后执行一个控制操作。具体操作取决于设备。
  - 磁带，如果 M = 0,那么反绕磁带。如果 M < 0，则磁带向回跳过 -M 个信息块。如果 M > 0，则磁带向前跳过 M 个信息块。
  - 磁盘和磁鼓，M 应当为 0。

- JRED 就绪时转移。C = 38；F = 设备。
  如果指定的设备就绪，也就是此前由 IN 或 OUT 或者 IOC 启动的从哦阿再结束，那么出现转移。

- JBUS 忙碌时转移。C = 34；F = 设备。
  类似于 JRED，但是当指定的设备没有就绪时出现转移。


#### 转换操作符

- NUM 转换为数字。C = 5；F = 0。
  用于把字符代码转换成数字代码。

- CHAR 转换为字符。C = 5；F = 1。
  用于把数字代码转换成式和输出的字符代码。

#### 计时

为了对 MIX 程序性能给出定量信息，MIX 的每个操作都赋有执行时间。


### 1.3.2 MIX 汇编语言

MIX 汇编语言 MIXAL (MIX Assembly Language) 是前一小节使用的指令记号的扩充。它的主要特征是选用字母符号名代表数字，并且用单元字段(位置字段)把存储单元与符号关联起来。


