import numpy as np
A = np.array([
    [0, 1, 1, 0, 0, 0, 0, 0, 1, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0],
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 1, 1, 0, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]])

# A.sum(axis=1) 为每行的和
# np.diag 功能以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一维数组转换成方阵（非对角线元素为0）
# 如下语句将一维的数组转换为对角线
D = np.diag(A.sum(axis=1))
print(D)

# Thus the Graph Laplacian Matrix is defined as: L = D-A      
L = D-A
print(L)

# np.linalg.eig 计算一个正方形阵列的特征值和右特征向量。
# 输入参数：
#   （…，M，M）阵列 ：计算其特征值和右特征向量的矩阵
# 
# 返回值：
#   w（…，M）阵列 ：特征值，每个特征值根据其多重性重复。特征值不一定是有序的。得到的数组将是复杂类型，除非虚部为零，在这种情况下，
#                 它将被强制转换为实类型。当a是实的时，得到的特征值将是实的（0虚部）或出现在共轭对中
#   v（…，M，M）阵列 ：归一化的（单位“长度”）特征向量，使得列v[：，i]是与特征值w[i]相对应的特征向量。
vals, vecs = np.linalg.eig(A)

print(vals)
print(vecs)

